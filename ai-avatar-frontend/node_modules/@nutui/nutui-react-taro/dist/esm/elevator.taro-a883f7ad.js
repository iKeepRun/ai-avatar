import React__default, { createContext, useRef, useState, useEffect } from 'react';
import Taro, { nextTick, createSelectorQuery } from '@tarojs/taro';
import { ScrollView } from '@tarojs/components';
import { c as cn } from './bem-350c1702.js';

const elevatorContext = createContext({});
const defaultProps = {
    height: '200px',
    acceptKey: 'title',
    indexList: [],
    isSticky: false,
    spaceHeight: 23,
    titleHeight: 35,
    className: 'weapp-elevator',
};
const Elevator = (props) => {
    const { height, acceptKey, indexList, isSticky, spaceHeight, titleHeight, className, onClickItem, onClickIndex, children, ...rest } = {
        ...defaultProps,
        ...props,
    };
    const b = cn('elevator');
    const listview = useRef(null);
    const initData = {
        anchorIndex: 0,
        listHeight: [],
        listGroup: [],
        scrollY: 0,
    };
    const touchState = useRef({
        y1: 0,
        y2: 0,
    });
    const [currentData, setCurrentData] = useState({});
    const [currentKey, setCurrentKey] = useState('');
    const [currentIndex, setCurrentIndex] = useState(0);
    const [codeIndex, setCodeIndex] = useState(0);
    const [scrollStart, setScrollStart] = useState(false);
    const state = useRef(initData);
    const [scrollTop, setScrollTop] = useState(0);
    const [scrollY, setScrollY] = useState(0);
    // 重置滚动参数
    const resetScrollState = () => {
        setScrollStart(false);
    };
    const getData = (el) => {
        if (!el.dataset.index) {
            return '0';
        }
        return el.dataset.index;
    };
    const calculateHeight = () => {
        let height = 0;
        state.current.listHeight.push(height);
        for (let i = 0; i < state.current.listGroup.length; i++) {
            const query = createSelectorQuery();
            query
                .selectAll(`.${className} .elevator__item__${i}`)
                .boundingClientRect();
            // eslint-disable-next-line no-loop-func
            query.exec((res) => {
                if (res[0][0])
                    height += res[0][0].height;
                // console.log(res, res[0][0].height, height, 'res')
                state.current.listHeight.push(height);
            });
        }
    };
    const scrollTo = (index) => {
        if (!index && index !== 0) {
            return;
        }
        if (!state.current.listHeight.length) {
            calculateHeight();
        }
        let cacheIndex = index;
        if (index < 0) {
            cacheIndex = 0;
        }
        if (index > state.current.listHeight.length - 2) {
            cacheIndex = state.current.listHeight.length - 2;
        }
        setCodeIndex(cacheIndex);
        const scrollTop = state.current.listHeight[cacheIndex];
        setScrollTop(scrollTop);
        if (isSticky && scrollY !== scrollTop) {
            setScrollY(Math.floor(scrollTop) > 0 ? 1 : 0);
        }
    };
    const touchMove = (e) => {
        const firstTouch = e.touches[0];
        touchState.current.y2 = firstTouch.pageY;
        const delta = (touchState.current.y2 - touchState.current.y1) / spaceHeight || 0;
        const cacheIndex = state.current.anchorIndex + Math.floor(delta);
        setCodeIndex(cacheIndex);
        scrollTo(cacheIndex);
    };
    const touchEnd = () => {
        resetScrollState();
    };
    const touchStart = (e) => {
        setScrollStart(true);
        const index = Number(getData(e.target));
        const firstTouch = e.touches[0];
        touchState.current.y1 = firstTouch.pageY;
        state.current.anchorIndex = +index;
        setCodeIndex((codeIndex) => {
            return codeIndex + index;
        });
        scrollTo(index);
    };
    const handleClickItem = (key, item) => {
        onClickItem && onClickItem(key, item);
        setCurrentData(item);
        setCurrentKey(key);
    };
    const handleClickIndex = (key) => {
        onClickIndex && onClickIndex(key);
    };
    const setListGroup = () => {
        if (listview.current) {
            createSelectorQuery()
                .selectAll(`.${className} .nut-elevator__list__item`)
                .node((el) => {
                state.current.listGroup = [...Object.keys(el)];
                calculateHeight();
            })
                .exec();
        }
    };
    const listViewScroll = (e) => {
        const { listHeight } = state.current;
        if (!listHeight.length) {
            calculateHeight();
        }
        const target = e.target;
        const { scrollTop } = target;
        state.current.scrollY = Math.floor(scrollTop);
        Taro.getEnv() === 'WEB' && setScrollTop(scrollTop);
        if (isSticky && scrollTop !== scrollY) {
            setScrollY(Math.floor(scrollTop) > 0 ? 1 : 0);
        }
        for (let i = 0; i < listHeight.length - 1; i++) {
            const height1 = listHeight[i];
            const height2 = listHeight[i + 1];
            if (state.current.scrollY >= height1 && state.current.scrollY < height2) {
                setCurrentIndex(i);
                return;
            }
        }
    };
    useEffect(() => {
        if (listview.current) {
            nextTick(() => {
                setListGroup();
            });
        }
    }, [listview]);
    return (React__default.createElement("div", { className: `${b()} ${className} `, ...rest },
        React__default.createElement("div", { className: b('list'), style: { height: Number.isNaN(+height) ? height : `${height}px` } },
            React__default.createElement(ScrollView, { scrollTop: scrollTop, scrollY: true, scrollWithAnimation: true, scrollAnchoring: true, className: b('list__inner'), ref: listview, onScroll: listViewScroll }, indexList.map((item, idx) => {
                return (React__default.createElement("div", { className: `${b('list__item')} elevator__item__${idx}`, key: idx },
                    React__default.createElement("div", { className: b('list__item__code') }, item[acceptKey]),
                    React__default.createElement(React__default.Fragment, null, item.list.map((subitem) => {
                        return (React__default.createElement("div", { className: b('list__item__name', {
                                highcolor: currentData.id === subitem.id &&
                                    currentKey === item[acceptKey],
                            }), key: subitem.id, onClick: () => handleClickItem(item[acceptKey], subitem) }, children ? (React__default.createElement(React__default.Fragment, null,
                            React__default.createElement(elevatorContext.Provider, { value: subitem }, children))) : (subitem.name)));
                    }))));
            }))),
        indexList.length && scrollStart ? (React__default.createElement("div", { className: b('code--current', { current: true }) }, indexList[codeIndex][acceptKey])) : null,
        React__default.createElement("div", { className: b('bars') },
            React__default.createElement("div", { className: b('bars__inner'), onTouchStart: (event) => touchStart(event), onTouchMove: (event) => touchMove(event), onTouchEnd: touchEnd, style: { touchAction: 'pan-y' } }, indexList.map((item, index) => {
                return (React__default.createElement("div", { className: `${b('bars__inner__item', {
                        active: item[acceptKey] === indexList[currentIndex][acceptKey],
                    })} `, "data-index": index, key: index, onClick: () => handleClickIndex(item[acceptKey]) }, item[acceptKey]));
            }))),
        isSticky && scrollY > 0 ? (React__default.createElement("div", { className: b('list__fixed') },
            React__default.createElement("span", { className: "fixed-title" }, indexList[currentIndex][acceptKey]))) : null));
};
Elevator.defaultProps = defaultProps;
Elevator.displayName = 'NutElevator';
Elevator.Context = elevatorContext;

export { Elevator as E };
