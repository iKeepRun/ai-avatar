import React__default, { useState, useRef, useEffect, useCallback } from 'react';
import { u as useTouch } from './useTouch-db24bb5c.js';
import { g as getRectByTaro } from './useClientRect-1f8ed1fe.js';
import { T as Toast } from './toast.taro-d6c14811.js';
import { u as useConfig } from './configprovider.taro-8d71eb49.js';

const defaultProps = {
    range: false,
    hiddenRange: false,
    hiddenTag: false,
    min: 0,
    max: 100,
    step: 1,
    modelValue: 0,
    vertical: false,
    marks: {},
};
let startValue;
let currentValue;
const Range = (props) => {
    const { locale } = useConfig();
    const { className, range, disabled, activeColor, inactiveColor, buttonColor, hiddenRange, hiddenTag, modelValue, button, vertical, marks, dragStart, dragEnd, onChange, onDragStart, onDragEnd, minDesc, maxDesc, curValueDesc, } = { ...defaultProps, ...props };
    let { min, max, step } = { ...defaultProps, ...props };
    min = Number(min);
    max = Number(max);
    step = Number(step);
    const [buttonIndex, SetButtonIndex] = useState(0);
    const [initValue, SetInitValue] = useState();
    const [dragStatus, SetDragStatus] = useState('start'  );
    const touch = useTouch();
    const root = useRef(null);
    const [marksList, SetMarksList] = useState([]);
    const [show, SetShow] = useState(false);
    const [toastMsg, SetToastMsg] = useState('');
    const toastShow = (msg) => {
        SetToastMsg(msg);
        SetShow(true);
    };
    useEffect(() => {
        if (!range && typeof modelValue === 'number') {
            if (modelValue < min || modelValue > max) {
                SetInitValue(0);
                toastShow(`${modelValue} ${locale.range.rangeText}`);
                return;
            }
            SetInitValue(modelValue);
        }
        else if (range &&
            Array.isArray(modelValue) &&
            [0, 1].every((i) => typeof modelValue[i] === 'number')) {
            SetInitValue(modelValue);
        }
    }, [modelValue]);
    useEffect(() => {
        if (marks) {
            const marksKeys = Object.keys(marks);
            const list = marksKeys
                .map(parseFloat)
                .sort((a, b) => a - b)
                .filter((point) => point >= min && point <= max);
            SetMarksList(list);
        }
    }, [marks]);
    const scope = () => {
        return Number(max) - Number(min);
    };
    const classes = useCallback(() => {
        const prefixCls = 'nut-range';
        return [
            prefixCls,
            `${disabled ? `${prefixCls}-disabled` : ''}`,
            `${vertical ? `${prefixCls}-vertical` : ''}`,
            `${!hiddenRange ? `${prefixCls}-show-number` : ''}`,
        ]
            .filter(Boolean)
            .join(' ');
    }, [disabled, vertical, hiddenRange]);
    const containerClasses = useCallback(() => {
        const prefixCls = 'nut-range-container';
        return [prefixCls, `${vertical ? `${prefixCls}-vertical` : ''}`, className]
            .filter(Boolean)
            .join(' ');
    }, [vertical, className]);
    const markClassName = useCallback((mark) => {
        const classPrefix = 'nut-range-mark';
        let lowerBound = Number(min);
        let upperBound = Number(max);
        if (range) {
            const [left, right] = modelValue;
            lowerBound = left;
            upperBound = right;
        }
        else {
            upperBound = modelValue;
        }
        const isActive = mark <= upperBound && mark >= lowerBound;
        return [
            `${classPrefix}-text`,
            `${isActive ? `${classPrefix}-text-active` : ''}`,
        ]
            .filter(Boolean)
            .join(' ');
    }, [range, modelValue, min, max]);
    const [rangeName, setRangeName] = useState(classes());
    const [containerName, setContainerName] = useState(containerClasses());
    useEffect(() => {
        setRangeName(classes());
        setContainerName(containerClasses());
    }, [classes, containerClasses]);
    const wrapperStyle = () => {
        return {
            background: inactiveColor,
        };
    };
    const buttonStyle = () => {
        return {
            borderColor: buttonColor,
        };
    };
    const isRange = (val) => {
        return !!range && Array.isArray(val);
    };
    const calcMainAxis = () => {
        const modelVal = initValue || initValue === 0 ? initValue : modelValue;
        if (isRange(modelVal)) {
            return `${((modelVal[1] - modelVal[0]) * 100) / scope()}%`;
        }
        return `${((modelVal - Number(min)) * 100) / scope()}%`;
    };
    const calcOffset = () => {
        const modelVal = initValue || initValue === 0 ? initValue : modelValue;
        if (isRange(modelVal)) {
            return `${((modelVal[0] - Number(min)) * 100) / scope()}%`;
        }
        return `0%`;
    };
    const barStyle = () => {
        if (vertical) {
            return {
                height: calcMainAxis(),
                top: calcOffset(),
                background: activeColor,
                transition: dragStatus ? 'none' : undefined,
            };
        }
        return {
            width: calcMainAxis(),
            left: calcOffset(),
            background: activeColor,
            transition: dragStatus ? 'none' : undefined,
        };
    };
    const marksStyle = (mark) => {
        let style = {
            left: `${((mark - Number(min)) / scope()) * 100}%`,
        };
        if (vertical) {
            style = {
                top: `${((mark - Number(min)) / scope()) * 100}%`,
            };
        }
        return style;
    };
    const tickStyle = (mark) => {
        let lowerBound = Number(min);
        let upperBound = Number(max);
        if (range) {
            const [left, right] = modelValue;
            lowerBound = left;
            upperBound = right;
        }
        const isActive = mark <= upperBound && mark >= lowerBound;
        const style = {
            background: !isActive ? inactiveColor : activeColor,
        };
        return style;
    };
    const format = (value) => {
        value = Math.max(+min, Math.min(value, +max));
        return Math.round(value / +step) * +step;
    };
    const isSameValue = (newValue, oldValue) => {
        return JSON.stringify(newValue) === JSON.stringify(oldValue);
    };
    const handleOverlap = (value) => {
        if (value[0] > value[1]) {
            return value.slice(0).reverse();
        }
        return value;
    };
    const updateValue = (value, end) => {
        if (isRange(value)) {
            value = handleOverlap(value).map(format);
        }
        else {
            value = format(value);
        }
        const modelVal = initValue || initValue === 0 ? initValue : modelValue;
        if (!isSameValue(value, modelVal)) {
            SetInitValue(value);
        }
        if ((marks || end) && !isSameValue(value, startValue)) {
            onChange && onChange(value);
        }
    };
    const click = async (event) => {
        if (disabled || !root.current) {
            return;
        }
        SetDragStatus('');
        const rect = await getRectByTaro(root.current);
        let delta = (event.detail.x ? event.detail.x : event.clientX) - rect.left;
        let total = rect.width;
        if (vertical) {
            delta = (event.detail.y ? event.detail.y : event.clientY) - rect.top;
            total = rect.height;
        }
        const value = Number(min) + (delta / total) * scope();
        currentValue = initValue || initValue === 0 ? initValue : modelValue;
        if (isRange(currentValue)) {
            const [left, right] = currentValue;
            const middle = (left + right) / 2;
            if (value <= middle) {
                updateValue([value, right], true);
            }
            else {
                updateValue([left, value], true);
            }
        }
        else {
            updateValue(value, true);
        }
    };
    const onTouchStart = (event) => {
        if (disabled) {
            return;
        }
        touch.start(event);
        currentValue = initValue || initValue === 0 ? initValue : modelValue;
        if (isRange(currentValue)) {
            startValue = currentValue.map(format);
        }
        else {
            startValue = format(currentValue);
        }
        SetDragStatus('start');
    };
    const onTouchMove = async (event) => {
        if (disabled || !root.current) {
            return;
        }
        if (dragStatus === 'start') {
            dragStart && dragStart();
            onDragStart && onDragStart();
        }
        touch.move(event);
        SetDragStatus('draging');
        const rect = await getRectByTaro(root.current);
        let delta = touch.deltaX;
        let total = rect.width;
        let diff = (delta / total) * scope();
        if (vertical) {
            delta = touch.deltaY;
            total = rect.height;
            diff = (delta / total) * scope();
        }
        if (isRange(startValue)) {
            currentValue[buttonIndex] = startValue[buttonIndex] + diff;
        }
        else {
            currentValue = startValue + diff;
        }
        updateValue(currentValue);
    };
    const onTouchEnd = (event) => {
        if (disabled) {
            return;
        }
        if (dragStatus === 'draging') {
            updateValue(currentValue, true);
            dragEnd && dragEnd();
            onDragEnd && onDragEnd();
        }
        SetDragStatus('');
    };
    const curValue = (idx) => {
        const modelVal = initValue || initValue === 0 ? initValue : modelValue;
        const value = typeof idx === 'number' ? modelVal[idx] : modelVal;
        return value;
    };
    return (React__default.createElement("div", { className: `${containerName}` },
        !hiddenRange ? React__default.createElement("div", { className: "min" }, minDesc || +min) : null,
        React__default.createElement("div", { ref: root, style: wrapperStyle(), className: `${rangeName}`, onClick: (e) => {
                click(e);
            } },
            marksList.length > 0 ? (React__default.createElement("div", { className: "nut-range-mark" }, marksList.map((marks) => {
                return (React__default.createElement("span", { key: marks, className: markClassName(marks), style: marksStyle(marks) },
                    marks,
                    React__default.createElement("span", { className: "nut-range-tick", style: tickStyle(marks) })));
            }))) : null,
            React__default.createElement("div", { className: "nut-range-bar", style: barStyle() }, range ? ([0, 1].map((item, index) => {
                return (React__default.createElement("div", { role: "slider", key: index, className: `${index === 0 ? 'nut-range-button-wrapper-left' : ''}
                  ${index === 1 ? 'nut-range-button-wrapper-right' : ''}`, tabIndex: disabled ? -1 : 0, "aria-valuemin": +min, "aria-valuenow": curValue(index), "aria-valuemax": +max, "aria-orientation": vertical ? 'vertical' : 'horizontal', onTouchStart: (e) => {
                        if (typeof index === 'number') {
                            // 实时更新当前拖动的按钮索引
                            SetButtonIndex(index);
                        }
                        onTouchStart(e);
                    }, onTouchMove: (e) => {
                        onTouchMove(e);
                    }, onTouchEnd: (e) => {
                        onTouchEnd();
                    }, onTouchCancel: (e) => {
                        onTouchEnd();
                    }, onClick: (e) => {
                        e.stopPropagation();
                    } }, button || (React__default.createElement("div", { className: "nut-range-button", style: buttonStyle() }, !hiddenTag ? (React__default.createElement("div", { className: "number" }, curValueDesc || curValue(index))) : null))));
            })) : (React__default.createElement("div", { role: "slider", className: "nut-range-button-wrapper", tabIndex: disabled ? -1 : 0, "aria-valuemin": +min, "aria-valuenow": curValue(), "aria-valuemax": +max, "aria-orientation": vertical ? 'vertical' : 'horizontal', onTouchStart: (e) => {
                    onTouchStart(e);
                }, onTouchMove: (e) => {
                    onTouchMove(e);
                }, onTouchEnd: (e) => {
                    onTouchEnd();
                }, onTouchCancel: (e) => {
                    onTouchEnd();
                }, onClick: (e) => {
                    e.stopPropagation();
                } }, button || (React__default.createElement("div", { className: "nut-range-button", style: buttonStyle() }, !hiddenTag ? (React__default.createElement("div", { className: "number" }, curValueDesc || curValue())) : null)))))),
        !hiddenRange ? React__default.createElement("div", { className: "max" }, maxDesc || +max) : null,
        React__default.createElement(Toast, { type: "text", visible: show, msg: toastMsg, onClose: () => {
                SetShow(false);
            } })));
};
Range.defaultProps = defaultProps;
Range.displayName = 'NutRange';

export { Range as R };
