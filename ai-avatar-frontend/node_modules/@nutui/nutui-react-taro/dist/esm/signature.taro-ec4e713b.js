import React__default, { useRef, useState, useEffect } from 'react';
import { getEnv, nextTick, createSelectorQuery, canvasToTempFilePath } from '@tarojs/taro';
import { B as Button } from './button.taro-9244d065.js';
import { c as cn } from './bem-350c1702.js';
import { u as useConfig } from './configprovider.taro-8d71eb49.js';

/* eslint-disable react/no-unknown-property */
const defaultProps = {
    canvasId: 'spcanvas',
    type: 'png',
    lineWidth: 2,
    strokeStyle: '#000',
    className: '',
};
const Signature = (props) => {
    const { locale } = useConfig();
    const { canvasId, type, lineWidth, strokeStyle, unSupportTpl, className, confirm, clear, onConfirm, onClear, ...rest } = {
        ...defaultProps,
        ...props,
    };
    const b = cn('signature');
    const canvasRef = useRef(null);
    const wrapRef = useRef(null);
    const [canvasHeight, setCanvasHeight] = useState(0);
    const [canvasWidth, setCanvasWidth] = useState(0);
    const ctx = useRef(null);
    const [disalbeScroll] = useState('true');
    const startEventHandler = (event) => {
        if (ctx.current) {
            ctx.current.beginPath();
            ctx.current.lineWidth = lineWidth;
            ctx.current.strokeStyle = strokeStyle;
        }
    };
    const moveEventHandler = (event) => {
        if (ctx.current) {
            const evt = event.changedTouches[0];
            let mouseX = evt.x || evt.clientX;
            let mouseY = evt.y || evt.clientY;
            if (getEnv() === 'WEB' && canvasRef.current) {
                const coverPos = canvasRef.current.getBoundingClientRect();
                mouseX = evt.clientX - coverPos.left;
                mouseY = evt.clientY - coverPos.top;
            }
            nextTick(() => {
                // ctx.current.lineCap = 'round'
                // ctx.current.lineJoin = 'round'
                ctx.current?.lineTo(mouseX, mouseY);
                ctx.current?.stroke();
            });
        }
    };
    const endEventHandler = (event) => { };
    const handleClearBtn = () => {
        if (ctx.current) {
            ctx.current.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.current.closePath();
        }
        clear && clear();
        onClear && onClear();
    };
    const handleConfirmBtn = () => {
        onSave();
    };
    const onSave = () => {
        createSelectorQuery()
            .select(`#${canvasId}`)
            .fields({
            node: true,
            size: true,
        })
            .exec((res) => {
            canvasToTempFilePath({
                canvas: res[0].node,
                fileType: props.type,
                canvasId: `${canvasId}`,
                success: (res) => {
                    handleClearBtn();
                    confirm && confirm(res.tempFilePath);
                    onConfirm && onConfirm(res.tempFilePath);
                },
                fail: (res) => {
                    console.log('保存失败');
                },
            });
        });
    };
    const canvasSetting = (canvasDom, width, height) => {
        const canvas = canvasDom;
        canvas.current = canvas;
        ctx.current = canvas.getContext('2d');
        setCanvasWidth(width);
        setCanvasHeight(height);
        canvas.width = width;
        canvas.height = height;
        if (ctx.current) {
            ctx.current.clearRect(0, 0, width, height);
            ctx.current.beginPath();
            ctx.current.lineWidth = lineWidth;
            ctx.current.strokeStyle = strokeStyle;
        }
    };
    const initCanvas = () => {
        nextTick(() => {
            setTimeout(() => {
                if (getEnv() === 'WEAPP' || getEnv() === 'JD') {
                    createSelectorQuery()
                        .select(`#${canvasId}`)
                        .fields({
                        node: true,
                        size: true,
                    }, (res) => {
                        const { node, width, height } = res;
                        canvasSetting(node, width, height);
                    })
                        .exec();
                }
                else {
                    const canvasDom = document.getElementById(`${canvasId}`);
                    let canvas = canvasDom;
                    if (canvasDom?.tagName !== 'CANVAS') {
                        canvas = canvasDom?.getElementsByTagName('canvas')[0];
                    }
                    canvasSetting(canvas, canvasDom?.offsetWidth, canvasDom?.offsetHeight);
                }
            }, 1000);
        });
    };
    useEffect(() => {
        initCanvas();
    }, []);
    return (React__default.createElement("div", { className: `${b()} ${className}`, ...rest },
        React__default.createElement("div", { className: `${b('inner')} spcanvas_WEAPP`, ref: wrapRef }, getEnv() === 'WEAPP' || getEnv() === 'JD' ? (React__default.createElement("canvas", { id: canvasId, ref: canvasRef, 
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            canvasId: canvasId, disalbeScroll: true, type: "2d", onTouchStart: startEventHandler, onTouchMove: moveEventHandler, onTouchEnd: endEventHandler })) : (React__default.createElement("canvas", { id: canvasId, ref: canvasRef, "canvas-id": canvasId, "disalbe-scroll": disalbeScroll, onTouchStart: startEventHandler, onTouchMove: moveEventHandler, onTouchEnd: endEventHandler, onTouchCancel: endEventHandler }))),
        React__default.createElement(Button, { className: `${b('btn')}`, type: "default", onClick: () => handleClearBtn() }, locale.signature.reSign),
        React__default.createElement(Button, { className: `${b('btn')}`, type: "primary", onClick: () => handleConfirmBtn() }, locale.confirm)));
};
Signature.defaultProps = defaultProps;
Signature.displayName = 'NutSignature';

export { Signature as S };
