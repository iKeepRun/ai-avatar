import React__default, { useRef, useEffect, useState, useMemo, useCallback } from 'react';
import classNames from 'classnames';
import { getEnv, usePageScroll, getSystemInfoSync } from '@tarojs/taro';
import { g as getRectByTaro } from './useClientRect-1f8ed1fe.js';
import { g as getScrollParent } from './get-scroll-parent-b4a07e65.js';
import { c as cn } from './bem-350c1702.js';

function useWatch(dep, callback, config = { immediate: false }) {
    const { immediate } = config;
    const prev = useRef();
    const inited = useRef(false);
    const stop = useRef(false);
    useEffect(() => {
        const execute = () => callback(prev.current);
        if (!stop.current) {
            if (!inited.current) {
                inited.current = true;
                if (immediate) {
                    execute();
                }
            }
            else {
                execute();
            }
            prev.current = dep;
        }
    }, [dep]);
    return () => {
        stop.current = true;
    };
}

const defaultProps = {
    position: 'top',
    top: 0,
    bottom: 0,
    zIndex: 2000,
};
const b = cn('sticky');
const Sticky = (props) => {
    const { position = 'top', top = 0, bottom = 0, zIndex = 2000, children, container, className, onChange, ...rest } = props;
    const stickyRef = useRef(null);
    const rootRef = useRef(null);
    const offset = position === 'top' ? top : bottom;
    const [rootRect, setRootRect] = useState({});
    const [fixed, setFixed] = useState(false);
    const [transform, setTransform] = useState(0); // 相对容器偏移距离
    useWatch(fixed, () => {
        onChange && onChange(fixed);
    });
    const rootStyle = useMemo(() => {
        if (!fixed) {
            return {
                height: '',
                width: '',
            };
        }
        const style = {};
        if (rootRect.height) {
            style.height = rootRect.height;
        }
        if (rootRect.width) {
            style.width = rootRect.width;
        }
        return style;
    }, [fixed, rootRect.height, rootRect.width]);
    const stickyStyle = useMemo(() => {
        if (!fixed) {
            return {
                height: '',
                width: '',
                [position]: '',
            };
        }
        let style = {};
        if (rootRect.height)
            style.height = rootRect.height;
        if (rootRect.width)
            style.width = rootRect.width;
        style.transform = `translate3d(0, ${transform}px, 0)`;
        style[position] = offset;
        style.zIndex = zIndex;
        return style;
    }, [fixed, rootRect.height, rootRect.width, transform, position]);
    const handleScroll = async (scrollTop) => {
        const curRootRect = await getRectByTaro(rootRef.current);
        const stickyRect = await getRectByTaro(stickyRef.current);
        if (curRootRect && stickyRect) {
            setRootRect(curRootRect);
            if (position === 'top') {
                if (container) {
                    const containerRect = await getRectByTaro(container.current);
                    const difference = containerRect.bottom - top - curRootRect.height;
                    const curTransform = difference < 0 ? difference : 0;
                    setTransform(curTransform);
                    const curFixed = top > curRootRect.top && containerRect.bottom > 0;
                    setFixed(curFixed);
                }
                else {
                    setFixed(top > curRootRect.top);
                }
            }
            else {
                const windowHeight = getSystemInfoSync().windowHeight;
                setFixed(windowHeight - offset < curRootRect.bottom);
            }
        }
        else {
            console.log('getRectByTaro获取失败', { stickyRect, curRootRect });
        }
    };
    const getElement = useCallback(() => {
        return getScrollParent(rootRef.current);
    }, []);
    useEffect(() => {
        if (getEnv() === 'WEB' && getElement() !== window) {
            window.addEventListener('touchmove', handleScroll, true);
            window.addEventListener('scroll', handleScroll, true);
            return () => {
                window.removeEventListener('touchmove', handleScroll);
                window.removeEventListener('scroll', handleScroll);
            };
        }
    }, []);
    usePageScroll((res) => {
        if (getEnv() === 'WEAPP') {
            handleScroll(res.scrollTop);
        }
    });
    return (React__default.createElement("div", { ref: rootRef, style: rootStyle, className: classNames(b(), className), ...rest },
        React__default.createElement("div", { 
            // 应符合 bem 规范
            className: classNames('nut-sticky-box', { 'nut-sticky-fixed': fixed }), ref: stickyRef, style: stickyStyle }, children)));
};
Sticky.defaultProps = defaultProps;
Sticky.displayName = 'NutSticky';

export { Sticky as S };
