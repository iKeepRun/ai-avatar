import React__default, { forwardRef, useRef, useState, useMemo, useImperativeHandle, useEffect } from 'react';
import classNames from 'classnames';
import { useReady, nextTick } from '@tarojs/taro';
import { c as cn } from './bem-350c1702.js';
import { u as useTouch } from './useTouch-db24bb5c.js';
import { g as getRectByTaro } from './useClientRect-1f8ed1fe.js';

function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== 'boolean' || event.cancelable) {
        event.preventDefault();
    }
    if (isStopPropagation) {
        event.stopPropagation();
    }
}
const defaultProps = {
    name: '',
    leftWidth: 0,
    rightWidth: 0,
};
const Swipe = forwardRef((props, instanceRef) => {
    const swipeBem = cn('swipe');
    const touch = useTouch();
    // 获取元素的时候要在页面 onReady 后，需要参考小程序的事件周期
    useReady(() => {
        const getWidth = async () => {
            if (leftWrapper.current) {
                const leftRect = await getRectByTaro(leftWrapper.current);
                setActionWidth((v) => ({ ...v, left: leftRect.width }));
            }
            if (rightWrapper.current) {
                const rightRect = await getRectByTaro(rightWrapper.current);
                setActionWidth((v) => ({ ...v, right: rightRect.width }));
            }
        };
        nextTick(() => getWidth());
    });
    const { children, className, style } = { ...defaultProps, ...props };
    const root = useRef();
    const opened = useRef(false);
    const lockClick = useRef(false);
    const startOffset = useRef(0);
    const [state, setState] = useState({
        offset: 0,
        dragging: false,
    });
    const [actionWidth, setActionWidth] = useState({
        left: 0,
        right: 0,
    });
    const wrapperStyle = {
        transform: `translate3d(${state.offset}px, 0, 0)`,
        transitionDuration: state.dragging ? '0s' : '.6s',
    };
    const leftWidth = useMemo(() => (props.leftWidth ? props.leftWidth : actionWidth.left), [props.leftWidth, actionWidth.left]);
    const rightWidth = useMemo(() => (props.rightWidth ? props.rightWidth : actionWidth.right), [props.rightWidth, actionWidth.right]);
    const onTouchStart = async (event) => {
        if (leftWrapper.current) {
            const leftRect = await getRectByTaro(leftWrapper.current);
            setActionWidth((v) => ({ ...v, left: leftRect.width }));
        }
        if (rightWrapper.current) {
            const rightRect = await getRectByTaro(rightWrapper.current);
            setActionWidth((v) => ({ ...v, right: rightRect.width }));
        }
        if (!props.disabled) {
            startOffset.current = state.offset;
            touch.start(event);
            props.onTouchStart && props.onTouchStart(event);
        }
    };
    const onTouchMove = (event) => {
        if (props.disabled) {
            return;
        }
        touch.move(event);
        props.onTouchMove && props.onTouchMove(event);
        if (touch.isHorizontal()) {
            lockClick.current = true;
            const newState = { ...state, dragging: true };
            const isEdge = !opened || touch.deltaX * startOffset.current < 0;
            if (isEdge) {
                preventDefault(event, true);
            }
            newState.offset = rangeCalculation(touch.deltaX + startOffset.current, -rightWidth || 0, leftWidth || 0);
            setState(newState);
        }
    };
    const onTouchEnd = (event) => {
        if (state.dragging) {
            setState((v) => ({ ...v, dragging: false }));
            toggle(state.offset > 0 ? 'left' : 'right');
            setTimeout(() => {
                lockClick.current = false;
            }, 0);
            props.onTouchEnd && props.onTouchEnd(event);
        }
    };
    const toggle = (side) => {
        const offset = Math.abs(state.offset);
        const base = 0.3;
        const baseNum = opened ? 1 - base : base;
        const width = side === 'left' ? leftWidth : rightWidth;
        if (width && offset > Number(width) * baseNum) {
            open(side);
        }
        else {
            close(side);
        }
    };
    const open = (side) => {
        opened.current = true;
        const offset = side === 'left' ? leftWidth : -rightWidth;
        const name = props.name;
        props.onOpen?.({ name, position: side });
        setState((v) => ({ ...v, offset: Number(offset) || 0 }));
    };
    const close = (position) => {
        if (opened.current) {
            opened.current = false;
            props.onClose?.({
                name: props.name,
                position: position || 'left',
            });
        }
        setState((v) => ({ ...v, offset: 0 }));
    };
    const rangeCalculation = (num, min, max) => {
        return Math.min(Math.max(Number(num), Number(min)), Number(max));
    };
    const leftWrapper = useRef(null);
    const rightWrapper = useRef(null);
    const renderActionContent = (side) => {
        if (props[`${side}Action`]) {
            return (React__default.createElement("div", { id: "left", ref: side === 'left' ? leftWrapper : rightWrapper, className: `${swipeBem(side)}`, onClick: (e) => handleOperate(e, side) }, props[`${side}Action`]));
        }
        return null;
    };
    const handleOperate = (event, position) => {
        event.stopPropagation();
        if (props.beforeClose) {
            props.beforeClose(position);
        }
        else {
            props.onActionClick && props.onActionClick(event, position);
        }
    };
    useImperativeHandle(instanceRef, () => ({
        open,
        close: () => close(),
    }));
    useEffect(() => {
        const handler = (event) => {
            const targets = [root];
            if (targets.some((targetItem) => {
                const targetElement = targetItem.current || targetItem;
                return !targetElement || targetElement?.contains(event.target);
            })) {
                return;
            }
            close();
        };
        document.addEventListener('touchstart', handler);
        return () => {
            document.removeEventListener('touchstart', handler);
        };
    }, []);
    return (React__default.createElement("div", { ref: root, className: classNames(swipeBem(), className), onTouchStart: (e) => onTouchStart(e), onTouchMove: (e) => onTouchMove(e), onTouchEnd: (e) => onTouchEnd(e), style: style },
        React__default.createElement("div", { className: `${swipeBem('wrapper')}`, style: wrapperStyle },
            renderActionContent('left'),
            children,
            renderActionContent('right'))));
});
Swipe.defaultProps = defaultProps;
Swipe.displayName = 'NutSwipe';

export { Swipe as S };
