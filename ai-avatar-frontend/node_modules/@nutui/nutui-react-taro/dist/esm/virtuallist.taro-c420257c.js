import React__default, { useState, useRef, useEffect, useCallback } from 'react';
import { ScrollView } from '@tarojs/components';
import { getSystemInfoSync } from '@tarojs/taro';
import { u as useConfig } from './configprovider.taro-8d71eb49.js';

// 缓存列表初始化信息
const initPositinoCache = (reaItemSize, length = 0) => {
    let index = 0;
    const positions = Array(length);
    while (index < length) {
        positions[index] = {
            index,
            height: reaItemSize,
            width: reaItemSize,
            top: index * reaItemSize,
            bottom: (index + 1) * reaItemSize,
            left: index * reaItemSize,
            right: (index + 1) * reaItemSize,
        };
        index++;
    }
    return positions;
};
// 通过二分法找到 scrollOffset 对应的值
const binarySearch = (positionsList, value = 0, horizontal) => {
    let start = 0;
    let end = positionsList.length - 1;
    let tempIndex = null;
    const key = horizontal ? 'right' : 'bottom';
    while (start <= end) {
        const midIndex = Math.floor((start + end) / 2);
        const midValue = positionsList[midIndex][key];
        // 相等则直接返回（因为是bottom, 因此startIndex应该是下一个节点）
        if (midValue === value) {
            return midIndex + 1;
        }
        // 中间值 < 传入值，则说明 value对应的节点 大于 start, start往后移动一位
        if (midValue < value) {
            start = midIndex + 1;
        }
        // 中间值 > 传入值，则说明 value 在 中间值之前，end 节点移动到 mid - 1
        else if (midValue > value) {
            // tempIndex存放最靠近值为value的所有
            if (tempIndex === null || tempIndex > midIndex) {
                tempIndex = midIndex;
            }
            end = midIndex - 1;
        }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
};
// 更新Item大小
const updateItemSize = (positions, items, sizeKey) => {
    const newPos = positions.concat();
    Array.from(items).forEach((item) => {
        const index = Number(item.getAttribute('data-index'));
        const styleVal = item.getAttribute('style');
        if (styleVal && styleVal.includes('none'))
            return;
        const nowSize = item.getBoundingClientRect()[sizeKey];
        const oldSize = positions[index][sizeKey];
        // 存在差值, 更新该节点以后所有的节点
        const dValue = oldSize - nowSize;
        if (dValue) {
            if (sizeKey === 'width') {
                newPos[index].right -= dValue;
                newPos[index][sizeKey] = nowSize;
                for (let k = index + 1; k < positions.length; k++) {
                    newPos[k].left = positions[k - 1].right;
                    newPos[k].right -= dValue;
                }
            }
            else if (sizeKey === 'height') {
                newPos[index].bottom -= dValue;
                newPos[index][sizeKey] = nowSize;
                for (let k = index + 1; k < positions.length; k++) {
                    newPos[k].top = positions[k - 1].bottom;
                    newPos[k].bottom -= dValue;
                }
            }
        }
    });
};

const defaultProps = {
    sourceData: [],
    itemSize: 66,
    itemEqualSize: true,
    overscan: 2,
};
const clientHeight = getSystemInfoSync().windowHeight - 5 || 667;
getSystemInfoSync().windowWidth || 375;
const VirtualList = (props) => {
    const { sourceData = [], ItemRender, itemSize = 66, itemEqualSize = true, overscan = 2, key, onScroll, className, containerSize = clientHeight, ...rest } = props;
    //   const sizeKey = horizontal ? 'width' : 'height'
    //   const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'
    //   const offsetKey = horizontal ? 'left' : 'top'
    const [startOffset, setStartOffset] = useState(0);
    const [start, setStart] = useState(0);
    const [list, setList] = useState(sourceData.slice());
    useConfig();
    // 虚拟列表容器ref
    const scrollRef = useRef(null);
    // 虚拟列表显示区域ref
    const itemsRef = useRef(null);
    const firstItemRef = useRef(null);
    // 列表位置信息
    const [positions, setPositions] = useState([
        {
            index: 0,
            left: 0,
            top: 0,
            bottom: 0,
            width: 0,
            height: 0,
            right: 0,
        },
    ]);
    const [offSetSize, setOffSetSize] = useState(containerSize || 0);
    const [options, setOptions] = useState({
        startOffset: 0,
        startIndex: 0,
        overStart: 0,
        endIndex: 10, // 可视区域结束索引
    });
    useEffect(() => {
        if (sourceData.length) {
            setList(sourceData.slice());
        }
    }, [sourceData]);
    //   初始计算可视区域展示数量
    useEffect(() => {
        setPositions((options) => {
            return { ...options, endIndex: visibleCount() };
        });
    }, [itemSize, overscan, offSetSize]);
    useEffect(() => {
        if (containerSize)
            return;
        setOffSetSize(getContainerHeight());
    }, [containerSize]);
    useEffect(() => {
        const pos = initPositinoCache(itemSize, sourceData.length);
        setPositions(pos);
    }, [itemSize, sourceData]);
    // 可视区域总高度
    const getContainerHeight = () => {
        // 初始首页列表高度
        const initH = itemSize * sourceData.length;
        // 未设置containerSize高度，判断首页高度小于设备高度时，滚动容器高度为首页数据高度，减5为分页触发的偏移量
        return initH < clientHeight
            ? initH + overscan * itemSize - 5
            : Math.min(containerSize, clientHeight); // Math.min(containerSize, clientHeight)
    };
    // 可视区域条数
    const visibleCount = () => {
        return Math.ceil(getContainerHeight() / itemSize) + overscan;
    };
    const end = () => {
        return start + visibleCount();
    };
    const listHeight = () => {
        return list.length * itemSize;
    };
    const visibleData = () => {
        return list.slice(start, Math.min(end(), list.length));
    };
    const updateTotalSize = useCallback(() => {
        if (!itemsRef.current)
            return;
        const items = itemsRef.current.children;
        if (!items.length)
            return;
        // 更新缓存
        updateItemSize(positions, items, 'height');
    }, [positions]);
    // 滚动监听
    const listScroll = (e) => {
        const scrollTop = e.detail ? e.detail.scrollTop : e.target.scrollTop;
        const scrollSize = Math.floor(scrollTop);
        const startIndex = binarySearch(positions, scrollSize, false);
        const overStart = startIndex - overscan > -1 ? startIndex - overscan : 0;
        const endIndex = end();
        if (!itemEqualSize) {
            updateTotalSize();
        }
        setStart(Math.floor(scrollTop / itemSize));
        setOptions({ startOffset, startIndex, overStart, endIndex });
        if (end() > list.length - 1) {
            onScroll && onScroll();
        }
        setStartOffset(scrollTop - (scrollTop % itemSize));
    };
    return (React__default.createElement("div", { className: className ? `${className} nut-virtualList-box` : 'nut-virtualList-box', ...rest, style: {
            height: containerSize ? `${offSetSize}px` : '',
        } },
        React__default.createElement(ScrollView, { scrollY: true, ref: scrollRef, className: "nut-virtuallist", style: {
                height: `${getContainerHeight()}px`,
            }, onScroll: listScroll },
            React__default.createElement("div", { className: "nut-virtuallist-phantom", style: { height: `${listHeight()}px` } }),
            React__default.createElement("div", { className: "nut-virtuallist-container", ref: itemsRef, style: { transform: `translate3d(0, ${startOffset}px, 0)` } }, visibleData().map((data, index) => {
                const { overStart } = options;
                const dataIndex = overStart + index;
                key && data[key] ? data[key] : dataIndex;
                return (React__default.createElement("div", { ref: dataIndex === 0 ? firstItemRef : null, "data-index": `${dataIndex}`, className: "nut-virtuallist-item", key: `${data}`, style: {
                        height: `${itemEqualSize ? `${itemSize}px` : 'auto'}`,
                    } }, ItemRender ? (React__default.createElement(ItemRender, { data: data, index: `${index}` })) : (data)));
            })))));
};
VirtualList.defaultProps = defaultProps;
VirtualList.displayName = 'NutVirtualList';

export { VirtualList as V };
