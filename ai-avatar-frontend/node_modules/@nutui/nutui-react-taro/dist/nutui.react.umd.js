(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("@tarojs/taro"), require("@tarojs/components"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "@tarojs/taro", "@tarojs/components", "react-dom"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.nutui = global2.nutui || {}, global2.nutui.react = {}), global2.React, global2.Taro, global2.components, global2.ReactDOM));
})(this, function(exports2, React, Taro, components, ReactDOM) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
/*!
* @nutui/nutui-react-taro v1.5.13 Mon Dec 11 2023 14:53:27 GMT+0800 (China Standard Time)
* (c) 2023 @jdf2e.
* Released under the MIT License.
*/

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k in e) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var classnameExports = {};
  var classname = {
    get exports() {
      return classnameExports;
    },
    set exports(v) {
      classnameExports = v;
    }
  };
  var classname_production_min = {};
  var hasRequiredClassname_production_min;
  function requireClassname_production_min() {
    if (hasRequiredClassname_production_min)
      return classname_production_min;
    hasRequiredClassname_production_min = 1;
    function r(r2) {
      function t2(t3, i, a, o) {
        var f = i ? e + t3 + r2.e + i : e + t3, v = f;
        if (a) {
          var s = " " + v + r2.m;
          for (var u in a)
            if (a.hasOwnProperty(u)) {
              var p = a[u];
              true === p ? v += s + u : p && (v += s + u + n + p);
            }
        }
        if (void 0 !== o)
          for (var y = 0, c = (o = Array.isArray(o) ? o : [o]).length; y < c; y++) {
            var l = o[y];
            if (l && "string" == typeof l.valueOf())
              for (var g = l.valueOf().split(" "), d = 0; d < g.length; d++) {
                var h = g[d];
                h !== f && (v += " " + h);
              }
          }
        return v;
      }
      var e = r2.n || "", n = r2.v || r2.m;
      return function(r3, e2) {
        return function(n2, i, a) {
          return "string" == typeof n2 ? "string" == typeof i || Array.isArray(i) ? t2(r3, n2, void 0, i) : t2(r3, n2, i, a) : t2(r3, e2, n2, i);
        };
      };
    }
    Object.defineProperty(classname_production_min, "__esModule", { value: true });
    var t = r({ e: "-", m: "_" });
    classname_production_min.cn = t, classname_production_min.withNaming = r;
    return classname_production_min;
  }
  var classname_development = {};
  var hasRequiredClassname_development;
  function requireClassname_development() {
    if (hasRequiredClassname_development)
      return classname_development;
    hasRequiredClassname_development = 1;
    Object.defineProperty(classname_development, "__esModule", { value: true });
    function withNaming(preset) {
      var nameSpace = preset.n || "";
      var modValueDelimiter = preset.v || preset.m;
      function stringify(b2, e, m, mix) {
        var entityName = e ? nameSpace + b2 + preset.e + e : nameSpace + b2;
        var className = entityName;
        if (m) {
          var modPrefix = " " + className + preset.m;
          for (var k in m) {
            if (m.hasOwnProperty(k)) {
              var modVal = m[k];
              if (modVal === true) {
                className += modPrefix + k;
              } else if (modVal) {
                className += modPrefix + k + modValueDelimiter + modVal;
              }
            }
          }
        }
        if (mix !== void 0) {
          mix = Array.isArray(mix) ? mix : [mix];
          for (var i = 0, len = mix.length; i < len; i++) {
            var value = mix[i];
            if (!value || typeof value.valueOf() !== "string")
              continue;
            var mixes = value.valueOf().split(" ");
            for (var j = 0; j < mixes.length; j++) {
              var val = mixes[j];
              if (val !== entityName) {
                className += " " + val;
              }
            }
          }
        }
        return className;
      }
      return function cnGenerator(b2, e) {
        return function(elemOrMods, elemModsOrBlockMix, elemMix) {
          if (typeof elemOrMods === "string") {
            if (typeof elemModsOrBlockMix === "string" || Array.isArray(elemModsOrBlockMix)) {
              return stringify(b2, elemOrMods, void 0, elemModsOrBlockMix);
            }
            return stringify(b2, elemOrMods, elemModsOrBlockMix, elemMix);
          }
          return stringify(b2, e, elemOrMods, elemModsOrBlockMix);
        };
      };
    }
    var cn2 = withNaming({
      e: "-",
      m: "_"
    });
    classname_development.cn = cn2;
    classname_development.withNaming = withNaming;
    return classname_development;
  }
  (function(module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = requireClassname_production_min();
    } else {
      module2.exports = requireClassname_development();
    }
  })(classname);
  const cn = classnameExports.withNaming({ n: "nut-", e: "__", m: "--", v: "-" });
  const defaultProps$1v = {
    name: "",
    size: "",
    classPrefix: "nut-icon",
    fontClassName: "nutui-iconfont",
    color: "",
    tag: "i",
    onClick: (e) => {
    },
    className: ""
  };
  function pxCheck$3(value) {
    if (value === "") {
      return value;
    }
    if (Number.isNaN(Number(value))) {
      return String(value);
    }
    return `${value}px`;
  }
  function Icon$1(props) {
    const {
      name,
      size,
      classPrefix,
      color,
      tag,
      children,
      className,
      fontClassName,
      style,
      onClick,
      ...rest
    } = {
      ...defaultProps$1v,
      ...props
    };
    const isImage = name ? name.indexOf("/") !== -1 : false;
    const type = isImage ? "img" : tag;
    const b2 = cn("icon");
    const handleClick = (e) => {
      if (onClick) {
        onClick(e);
      }
    };
    const hasSrc = () => {
      if (isImage)
        return { src: name };
      return {};
    };
    const styles = {};
    const checkedSize = pxCheck$3(size);
    if (checkedSize) {
      styles.width = styles.height = styles.fontSize = checkedSize;
    }
    return React.createElement(
      type,
      {
        className: isImage ? `${b2("img")} ${className || ""} ` : `${fontClassName} ${b2(null)} ${classPrefix}-${name} ${className || ""}`,
        style: {
          color,
          ...styles,
          ...style
        },
        ...rest,
        onClick: handleClick,
        ...hasSrc()
      },
      children
    );
  }
  Icon$1.defaultProps = defaultProps$1v;
  Icon$1.displayName = "NutIcon";
  const ComponentDefaults = {
    // className: '',
    // style: {},
    // children: undefined,
    iconClassPrefix: "nut-icon",
    iconFontClassName: "nutui-iconfont"
  };
  const defaultProps$1u = {
    ...ComponentDefaults,
    className: "",
    color: "",
    shape: "round",
    plain: false,
    loading: false,
    disabled: false,
    type: "default",
    size: "normal",
    block: false,
    icon: "",
    iconSize: "16",
    style: {},
    children: void 0,
    onClick: (e) => {
    }
  };
  const Button = (props) => {
    const {
      color,
      shape,
      plain,
      loading,
      disabled,
      type,
      size,
      block,
      icon,
      iconSize,
      children,
      onClick,
      className,
      style,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$1u,
      ...props
    };
    const getStyle = React.useCallback(() => {
      const style2 = {};
      if (color) {
        if (plain) {
          style2.color = color;
          style2.background = "#fff";
          if (!(color == null ? void 0 : color.includes("gradient"))) {
            style2.borderColor = color;
          }
        } else {
          style2.color = "#fff";
          style2.background = color;
        }
      }
      return style2;
    }, [color, plain]);
    const classes = React.useCallback(() => {
      const prefixCls = "nut-button";
      return [
        prefixCls,
        `${type ? `${prefixCls}--${type}` : ""}`,
        `${size ? `${prefixCls}--${size}` : ""}`,
        `${shape ? `${prefixCls}--${shape}` : ""}`,
        `${plain ? `${prefixCls}--plain` : ""}`,
        `${block ? `${prefixCls}--block` : ""}`,
        `${disabled ? `${prefixCls}--disabled` : ""}`,
        `${loading ? `${prefixCls}--loading` : ""}`
      ].filter(Boolean).join(" ");
    }, [block, disabled, loading, plain, shape, size, type]);
    const [btnName, setBtnName] = React.useState(classes());
    const [btnStyle, setBtnStyle] = React.useState(getStyle());
    React.useEffect(() => {
      setBtnName(classes());
      setBtnStyle(getStyle());
    }, [
      className,
      color,
      shape,
      plain,
      loading,
      disabled,
      style,
      type,
      size,
      block,
      icon,
      iconSize,
      children,
      onClick,
      classes,
      getStyle
    ]);
    const handleClick = (e) => {
      if (!loading && !disabled && onClick) {
        onClick(e);
      }
    };
    return (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line react/button-has-type
      /* @__PURE__ */ React.createElement(
        "button",
        {
          className: `${btnName} ${className}`,
          style: { ...btnStyle, ...style },
          ...rest,
          onClick: (e) => handleClick(e)
        },
        /* @__PURE__ */ React.createElement("div", { className: "nut-button__warp" }, loading && /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "loading"
          }
        ), !loading && icon ? /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: icon,
            size: iconSize
          }
        ) : "", children && /* @__PURE__ */ React.createElement("div", { className: icon || loading ? "text" : "" }, children))
      )
    );
  };
  Button.defaultProps = defaultProps$1u;
  Button.displayName = "NutButton";
  const defaultProps$1t = {
    ...ComponentDefaults,
    title: null,
    subTitle: null,
    desc: "",
    descTextAlign: "right",
    isLink: false,
    icon: "",
    roundRadius: "6px",
    url: "",
    to: "",
    replace: false,
    center: false,
    size: "",
    className: "",
    iconSlot: null,
    linkSlot: null,
    onClick: (event) => {
    }
  };
  const Cell = (props) => {
    const {
      children,
      onClick,
      title,
      subTitle,
      desc,
      descTextAlign,
      isLink,
      icon,
      roundRadius,
      url,
      to: to2,
      replace,
      center,
      size,
      className,
      iconSlot,
      linkSlot,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$1t,
      ...props
    };
    const b2 = cn("cell");
    const handleClick = (event) => {
      onClick(event);
      const link = to2 || url;
      if (link) {
        replace ? Taro.redirectTo({ url: link }) : Taro.navigateTo({ url: link });
      }
    };
    const baseStyle = {
      borderRadius: Number.isNaN(Number(roundRadius)) ? String(roundRadius) : `${roundRadius}px`
    };
    const styles = title || subTitle || icon ? { textAlign: descTextAlign } : {
      textAlign: descTextAlign,
      flex: 1
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${b2(
          { clickable: !!(isLink || to2), center, large: size === "large" },
          [className]
        )} `,
        onClick: (event) => handleClick(event),
        style: baseStyle,
        ...rest
      },
      children || /* @__PURE__ */ React.createElement(React.Fragment, null, icon || iconSlot ? /* @__PURE__ */ React.createElement("div", { className: b2("icon") }, iconSlot || (icon ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: icon,
          className: "icon"
        }
      ) : null)) : null, title || subTitle ? /* @__PURE__ */ React.createElement("div", { className: `${b2("title")}` }, title ? /* @__PURE__ */ React.createElement("div", { className: b2("maintitle") }, title) : null, subTitle ? /* @__PURE__ */ React.createElement("div", { className: b2("subtitle") }, subTitle) : null) : null, desc ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: b2("value", {
            alone: !title && !subTitle
          }),
          style: styles
        },
        desc
      ) : null, !linkSlot && (isLink || to2) ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: "right",
          className: b2("link")
        }
      ) : linkSlot)
    );
  };
  Cell.defaultProps = defaultProps$1t;
  Cell.displayName = "NutCell";
  const defaultProps$1s = {
    title: "",
    desc: "",
    className: "",
    titleSlot: null,
    descSlot: null
  };
  const CellGroup = (props) => {
    const { children, className, title, desc, titleSlot, descSlot } = {
      ...defaultProps$1s,
      ...props
    };
    const b2 = cn("cell-group");
    return /* @__PURE__ */ React.createElement("div", { className: b2(null, [className]) }, titleSlot || /* @__PURE__ */ React.createElement(React.Fragment, null, title ? /* @__PURE__ */ React.createElement("div", { className: b2("title") }, title) : null), descSlot || /* @__PURE__ */ React.createElement(React.Fragment, null, desc ? /* @__PURE__ */ React.createElement("div", { className: b2("desc") }, desc) : null), /* @__PURE__ */ React.createElement("div", { className: b2("wrap") }, children));
  };
  CellGroup.defaultProps = defaultProps$1s;
  CellGroup.displayName = "NutCellGroup";
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    // Latin-1 Supplement block.
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    // Latin Extended-A block.
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "ss"
  };
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol$1 = root.Symbol;
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var kebabCase = createCompounder(function(result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
  });
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  var lodash_kebabcase = kebabCase;
  const zhCN = {
    save: "保存",
    confirm: "确认",
    cancel: "取消",
    done: "完成",
    noData: "暂无数据",
    placeholder: "请输入内容",
    select: "请选择",
    video: {
      errorTip: "视频加载失败",
      clickRetry: "点击重试"
    },
    fixednav: {
      activeText: "收起导航",
      unActiveText: "快速导航"
    },
    infiniteloading: {
      pullRefreshText: "松开刷新",
      loadText: "加载中……",
      loadMoreText: "哎呀，这里是底部了啦"
    },
    pagination: {
      prev: "上一页",
      next: "下一页"
    },
    range: {
      rangeText: "不在该区间内"
    },
    calendaritem: {
      weekdays: ["日", "一", "二", "三", "四", "五", "六"],
      end: "结束",
      start: "开始",
      confirm: "确认",
      title: "日历选择",
      monthTitle: (year, month) => `${year}年${month}月`,
      today: "今天",
      loadPreviousMonth: "加载上一个月",
      noEarlierMonth: "没有更早月份"
    },
    shortpassword: {
      title: "请输入密码",
      desc: "您使用了虚拟资产，请进行验证",
      tips: "忘记密码"
    },
    uploader: {
      ready: "准备完成",
      readyUpload: "准备上传",
      waitingUpload: "等待上传",
      uploading: "上传中...",
      success: "上传成功",
      error: "上传失败",
      deleteWord: "用户阻止了删除！"
    },
    countdown: {
      day: "天",
      hour: "时",
      minute: "分",
      second: "秒"
    },
    address: {
      selectRegion: "请选择所在地区",
      deliveryTo: "配送至",
      chooseAnotherAddress: "选择其他地址"
    },
    signature: {
      reSign: "重签",
      unSupportTpl: "对不起，当前浏览器不支持Canvas，无法使用本控件！"
    },
    ecard: {
      chooseText: "请选择电子卡面值",
      otherValueText: "其他面值",
      placeholder: "请输入1-5000整数"
    },
    timeselect: {
      pickupTime: "取件时间"
    },
    sku: {
      buyNow: "立即购买",
      buyNumber: "购买数量",
      addToCard: "加入购物车"
    },
    skuheader: {
      skuId: "商品编号"
    },
    addresslist: {
      addAddress: "新建地址"
    },
    comment: {
      complaintsText: "我要投诉",
      additionalReview: (day) => `购买${day}天后追评`,
      additionalImages: (length) => `${length}张追评图片`
    },
    searchbar: {
      basePlaceholder: "上京东，购好物",
      text: "文本",
      test: "测试",
      title1: "基础用法",
      title2: "搜索框形状及最大长度",
      title3: "搜索框内外背景设置",
      title4: "搜索框文本设置",
      title5: "自定义图标设置",
      title6: "数据改变监听"
    },
    audio: {
      back: "快退",
      forward: "快进",
      pause: "暂停",
      start: "开始",
      mute: "静音",
      tips: "onPlayEnd事件在loop=false时才会触发"
    },
    datepicker: {
      year: "年",
      month: "月",
      day: "日",
      hour: "时",
      min: "分",
      seconds: "秒"
    },
    pullToRefresh: {
      pullingText: "下拉刷新",
      canReleaseText: "松开刷新",
      refreshingText: "加载中...",
      completeText: "刷新成功"
    },
    watermark: {
      errorCanvasTips: "当前环境不支持Canvas"
    }
  };
  const defaultProps$1r = {
    locale: zhCN
  };
  const defaultConfigRef$1 = {
    current: {
      locale: zhCN
    }
  };
  const getDefaultConfig$1 = () => {
    return defaultConfigRef$1.current;
  };
  const ConfigContext$1 = React.createContext(null);
  const useConfig$1 = () => {
    return React.useContext(ConfigContext$1) ?? getDefaultConfig$1();
  };
  function convertThemeVarsToCSSVars(themeVars) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key) => {
      cssVars[`--${lodash_kebabcase(key)}`] = themeVars[key];
    });
    return cssVars;
  }
  const ConfigProvider = (props) => {
    const { children, ...config2 } = { ...defaultProps$1r, ...props };
    const parentConfig = useConfig$1();
    const theme = config2.theme || {};
    const style = React.useMemo(
      () => convertThemeVarsToCSSVars(theme),
      [theme]
    );
    return /* @__PURE__ */ React.createElement(
      ConfigContext$1.Provider,
      {
        value: {
          ...parentConfig,
          ...config2
        }
      },
      /* @__PURE__ */ React.createElement("div", { style }, children)
    );
  };
  ConfigProvider.defaultProps = defaultProps$1r;
  ConfigProvider.displayName = "NutConfigProvider";
  const defaultProps$1q = {
    fit: "fill",
    position: "center",
    alt: "",
    width: "center",
    height: "",
    round: false,
    showError: true,
    showLoading: true
  };
  const Image$1 = (props) => {
    useConfig$1();
    const {
      children,
      className,
      style,
      src,
      fit,
      position,
      alt,
      width,
      height,
      round,
      radius,
      showError,
      showLoading,
      slotError,
      slotLoding,
      onClick,
      onLoad,
      onError
    } = { ...defaultProps$1q, ...props };
    const [loading, setLoading] = React.useState(true);
    const [isError, setIsError] = React.useState(false);
    React.useEffect(() => {
      if (src) {
        setIsError(false);
        setLoading(true);
      }
    }, [src]);
    const load = () => {
      setLoading(false);
      onLoad && onLoad();
    };
    const error = () => {
      setIsError(true);
      setLoading(false);
      onError && onError();
    };
    const pxCheck2 = (value) => {
      return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
    };
    const stylebox = {
      height: height ? pxCheck2(height) : "",
      width: width ? pxCheck2(width) : "",
      overflow: radius !== void 0 && radius !== null ? "hidden" : "",
      borderRadius: radius !== void 0 && radius !== null ? pxCheck2(radius) : ""
    };
    const styles = {
      objectFit: fit,
      objectPosition: position,
      ...style
    };
    const imageClick = (event) => {
      onClick && onClick(event);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `nut-image ${round ? "nut-image-round" : ""}`,
        style: stylebox,
        onClick: (e) => {
          imageClick(e);
        }
      },
      /* @__PURE__ */ React.createElement(
        "img",
        {
          className: "nut-img",
          style: styles,
          src,
          alt,
          onLoad: load,
          onError: error
        }
      ),
      showLoading && loading ? /* @__PURE__ */ React.createElement("div", { className: "nut-img-loading" }, slotLoding || children || /* @__PURE__ */ React.createElement(Icon$1, { name: "image" })) : null,
      showError && isError && !loading ? /* @__PURE__ */ React.createElement("div", { className: "nut-img-error" }, slotError || children || /* @__PURE__ */ React.createElement(Icon$1, { name: "image-error" })) : null
    );
  };
  Image$1.defaultProps = defaultProps$1q;
  Image$1.displayName = "NutImage";
  var classnamesExports = {};
  var classnames = {
    get exports() {
      return classnamesExports;
    },
    set exports(v) {
      classnamesExports = v;
    }
  };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  (function(module2) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  const classNames = classnamesExports;
  const defaultOverlayProps = {
    zIndex: 2e3,
    duration: 0.3,
    overlayClass: "",
    closeOnClickOverlay: true,
    visible: false,
    lockScroll: true,
    overlayStyle: {}
  };
  const Overlay = (props) => {
    const {
      children,
      zIndex,
      duration,
      overlayClass,
      closeOnClickOverlay,
      visible,
      lockScroll,
      overlayStyle,
      onClick,
      ...rest
    } = {
      ...defaultOverlayProps,
      ...props
    };
    const [show, setShow] = React.useState(visible);
    const renderRef = React.useRef(true);
    const intervalRef = React.useRef(0);
    React.useEffect(() => {
      visible && setShow(visible);
      lock();
    }, [visible]);
    React.useEffect(() => {
      return () => {
        clearTimeout(intervalRef.current);
        document.body.classList.remove("nut-overflow-hidden");
      };
    }, []);
    const b2 = cn("overlay");
    const classes = classNames(
      {
        "overlay-fade-leave-active": !renderRef.current && !visible,
        "overlay-fade-enter-active": visible,
        "first-render": renderRef.current && !visible,
        "hidden-render": !visible
      },
      overlayClass,
      b2("")
    );
    const styles = {
      zIndex,
      animationDuration: `${props.duration}s`,
      ...overlayStyle
    };
    const lock = () => {
      if (lockScroll && visible) {
        document.body.classList.add("nut-overflow-hidden");
      } else {
        document.body.classList.remove("nut-overflow-hidden");
      }
    };
    const handleClick = (event) => {
      if (closeOnClickOverlay) {
        onClick && onClick(event);
        renderRef.current = false;
        const id = window.setTimeout(() => {
          setShow(!visible);
        }, duration * 1e3 * 0.8);
        intervalRef.current = id;
      }
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      components.View,
      {
        className: classes,
        style: styles,
        ...rest,
        catchMove: lockScroll,
        onClick: handleClick
      },
      children
    ));
  };
  Overlay.defaultProps = defaultOverlayProps;
  Overlay.displayName = "NutOverlay";
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  var propTypesExports = {};
  var propTypes = {
    get exports() {
      return propTypesExports;
    },
    set exports(v) {
      propTypesExports = v;
    }
  };
  var reactIsExports = {};
  var reactIs = {
    get exports() {
      return reactIsExports;
    },
    set exports(v) {
      reactIsExports = v;
    }
  };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min)
      return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b2 = "function" === typeof Symbol && Symbol.for, c = b2 ? Symbol.for("react.element") : 60103, d = b2 ? Symbol.for("react.portal") : 60106, e = b2 ? Symbol.for("react.fragment") : 60107, f = b2 ? Symbol.for("react.strict_mode") : 60108, g = b2 ? Symbol.for("react.profiler") : 60114, h = b2 ? Symbol.for("react.provider") : 60109, k = b2 ? Symbol.for("react.context") : 60110, l = b2 ? Symbol.for("react.async_mode") : 60111, m = b2 ? Symbol.for("react.concurrent_mode") : 60111, n = b2 ? Symbol.for("react.forward_ref") : 60112, p = b2 ? Symbol.for("react.suspense") : 60113, q = b2 ? Symbol.for("react.suspense_list") : 60120, r = b2 ? Symbol.for("react.memo") : 60115, t = b2 ? Symbol.for("react.lazy") : 60116, v = b2 ? Symbol.for("react.block") : 60121, w = b2 ? Symbol.for("react.fundamental") : 60117, x = b2 ? Symbol.for("react.responder") : 60118, y = b2 ? Symbol.for("react.scope") : 60119;
    function z(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a) {
      return z(a) === m;
    }
    reactIs_production_min.AsyncMode = l;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c;
    reactIs_production_min.ForwardRef = n;
    reactIs_production_min.Fragment = e;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f;
    reactIs_production_min.Suspense = p;
    reactIs_production_min.isAsyncMode = function(a) {
      return A(a) || z(a) === l;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a) {
      return z(a) === k;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return z(a) === h;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return z(a) === n;
    };
    reactIs_production_min.isFragment = function(a) {
      return z(a) === e;
    };
    reactIs_production_min.isLazy = function(a) {
      return z(a) === t;
    };
    reactIs_production_min.isMemo = function(a) {
      return z(a) === r;
    };
    reactIs_production_min.isPortal = function(a) {
      return z(a) === d;
    };
    reactIs_production_min.isProfiler = function(a) {
      return z(a) === g;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return z(a) === f;
    };
    reactIs_production_min.isSuspense = function(a) {
      return z(a) === p;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
    };
    reactIs_production_min.typeOf = z;
    return reactIs_production_min;
  }
  var reactIs_development = {};
  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_development;
  function requireReactIs_development() {
    if (hasRequiredReactIs_development)
      return reactIs_development;
    hasRequiredReactIs_development = 1;
    if (process.env.NODE_ENV !== "production") {
      (function() {
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        reactIs_development.AsyncMode = AsyncMode;
        reactIs_development.ConcurrentMode = ConcurrentMode;
        reactIs_development.ContextConsumer = ContextConsumer;
        reactIs_development.ContextProvider = ContextProvider;
        reactIs_development.Element = Element2;
        reactIs_development.ForwardRef = ForwardRef;
        reactIs_development.Fragment = Fragment;
        reactIs_development.Lazy = Lazy;
        reactIs_development.Memo = Memo;
        reactIs_development.Portal = Portal;
        reactIs_development.Profiler = Profiler;
        reactIs_development.StrictMode = StrictMode;
        reactIs_development.Suspense = Suspense;
        reactIs_development.isAsyncMode = isAsyncMode;
        reactIs_development.isConcurrentMode = isConcurrentMode;
        reactIs_development.isContextConsumer = isContextConsumer;
        reactIs_development.isContextProvider = isContextProvider;
        reactIs_development.isElement = isElement2;
        reactIs_development.isForwardRef = isForwardRef;
        reactIs_development.isFragment = isFragment;
        reactIs_development.isLazy = isLazy;
        reactIs_development.isMemo = isMemo;
        reactIs_development.isPortal = isPortal;
        reactIs_development.isProfiler = isProfiler;
        reactIs_development.isStrictMode = isStrictMode;
        reactIs_development.isSuspense = isSuspense;
        reactIs_development.isValidElementType = isValidElementType;
        reactIs_development.typeOf = typeOf;
      })();
    }
    return reactIs_development;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs)
      return reactIsExports;
    hasRequiredReactIs = 1;
    (function(module2) {
      if (process.env.NODE_ENV === "production") {
        module2.exports = requireReactIs_production_min();
      } else {
        module2.exports = requireReactIs_development();
      }
    })(reactIs);
    return reactIsExports;
  }
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var objectAssign;
  var hasRequiredObjectAssign;
  function requireObjectAssign() {
    if (hasRequiredObjectAssign)
      return objectAssign;
    hasRequiredObjectAssign = 1;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to2 = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to2[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to2[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to2;
    };
    return objectAssign;
  }
  var ReactPropTypesSecret_1;
  var hasRequiredReactPropTypesSecret;
  function requireReactPropTypesSecret() {
    if (hasRequiredReactPropTypesSecret)
      return ReactPropTypesSecret_1;
    hasRequiredReactPropTypesSecret = 1;
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    ReactPropTypesSecret_1 = ReactPropTypesSecret;
    return ReactPropTypesSecret_1;
  }
  var has;
  var hasRequiredHas;
  function requireHas() {
    if (hasRequiredHas)
      return has;
    hasRequiredHas = 1;
    has = Function.call.bind(Object.prototype.hasOwnProperty);
    return has;
  }
  var checkPropTypes_1;
  var hasRequiredCheckPropTypes;
  function requireCheckPropTypes() {
    if (hasRequiredCheckPropTypes)
      return checkPropTypes_1;
    hasRequiredCheckPropTypes = 1;
    var printWarning = function() {
    };
    if (process.env.NODE_ENV !== "production") {
      var ReactPropTypesSecret = requireReactPropTypesSecret();
      var loggedTypeFailures = {};
      var has2 = requireHas();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (process.env.NODE_ENV !== "production") {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (process.env.NODE_ENV !== "production") {
        loggedTypeFailures = {};
      }
    };
    checkPropTypes_1 = checkPropTypes;
    return checkPropTypes_1;
  }
  var factoryWithTypeCheckers;
  var hasRequiredFactoryWithTypeCheckers;
  function requireFactoryWithTypeCheckers() {
    if (hasRequiredFactoryWithTypeCheckers)
      return factoryWithTypeCheckers;
    hasRequiredFactoryWithTypeCheckers = 1;
    var ReactIs2 = requireReactIs();
    var assign2 = requireObjectAssign();
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    var has2 = requireHas();
    var checkPropTypes = requireCheckPropTypes();
    var printWarning = function() {
    };
    if (process.env.NODE_ENV !== "production") {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess2) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (process.env.NODE_ENV !== "production") {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess2) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (process.env.NODE_ENV !== "production" && typeof console !== "undefined") {
              var cacheKey2 = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey2] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey2] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs2.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (process.env.NODE_ENV !== "production") {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is2(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has2(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          process.env.NODE_ENV !== "production" ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has2(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    return factoryWithTypeCheckers;
  }
  var factoryWithThrowingShims;
  var hasRequiredFactoryWithThrowingShims;
  function requireFactoryWithThrowingShims() {
    if (hasRequiredFactoryWithThrowingShims)
      return factoryWithThrowingShims;
    hasRequiredFactoryWithThrowingShims = 1;
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    return factoryWithThrowingShims;
  }
  if (process.env.NODE_ENV !== "production") {
    var ReactIs = requireReactIs();
    var throwOnDirectAccess = true;
    propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
  } else {
    propTypes.exports = requireFactoryWithThrowingShims()();
  }
  function hasClass(element, className) {
    if (element.classList)
      return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!hasClass(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  const config$1 = {
    disabled: false
  };
  var timeoutsShape = process.env.NODE_ENV !== "production" ? propTypesExports.oneOfType([propTypesExports.number, propTypesExports.shape({
    enter: propTypesExports.number,
    exit: propTypesExports.number,
    appear: propTypesExports.number
  }).isRequired]) : null;
  var classNamesShape = process.env.NODE_ENV !== "production" ? propTypesExports.oneOfType([propTypesExports.string, propTypesExports.shape({
    enter: propTypesExports.string,
    exit: propTypesExports.string,
    active: propTypesExports.string
  }), propTypesExports.shape({
    enter: propTypesExports.string,
    enterDone: propTypesExports.string,
    enterActive: propTypesExports.string,
    exit: propTypesExports.string,
    exitDone: propTypesExports.string,
    exitActive: propTypesExports.string
  })]) : null;
  const TransitionGroupContext = React.createContext(null);
  var forceReflow = function forceReflow2(node) {
    return node.scrollTop;
  };
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== "number") {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear !== void 0 ? timeout.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
            if (node)
              forceReflow(node);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts2 = this.getTimeouts();
      var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
      if (!mounting && !enter || config$1.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts2 = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
      if (!exit || config$1.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts2.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose$3(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(React.Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = process.env.NODE_ENV !== "production" ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: propTypesExports.shape({
      current: typeof Element === "undefined" ? propTypesExports.any : function(propValue, key, componentName, location, propFullName, secret) {
        var value = propValue[key];
        return propTypesExports.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: propTypesExports.oneOfType([propTypesExports.func.isRequired, propTypesExports.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: propTypesExports.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: propTypesExports.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: propTypesExports.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: propTypesExports.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: propTypesExports.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: propTypesExports.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener)
        pt = pt.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt.apply(void 0, [props].concat(args));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: propTypesExports.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: propTypesExports.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: propTypesExports.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: propTypesExports.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: propTypesExports.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: propTypesExports.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: propTypesExports.func
  } : {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  const Transition$1 = Transition;
  var _addClass = function addClass$1(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
      return addClass(node, c);
    });
  };
  var removeClass = function removeClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c) {
      return removeClass$1(node, c);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node, type);
        _this.addClass(node, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames2 = _this.props.classNames;
        var isStringClassNames = typeof classNames2 === "string";
        var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames2[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        if (node)
          forceReflow(node);
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass(node, baseClassName);
      }
      if (activeClassName) {
        removeClass(node, activeClassName);
      }
      if (doneClassName) {
        removeClass(node, doneClassName);
      }
    };
    _proto.render = function render() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose$3(_this$props, ["classNames"]);
      return /* @__PURE__ */ React.createElement(Transition$1, _extends$3({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(React.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends$3({}, Transition$1.propTypes, {
    /**
     * The animation classNames applied to the component as it appears, enters,
     * exits or has finished the transition. A single name can be provided, which
     * will be suffixed for each stage, e.g. `classNames="fade"` applies:
     *
     * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
     * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
     * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
     *
     * A few details to note about how these classes are applied:
     *
     * 1. They are _joined_ with the ones that are already defined on the child
     *    component, so if you want to add some base styles, you can use
     *    `className` without worrying that it will be overridden.
     *
     * 2. If the transition component mounts with `in={false}`, no classes are
     *    applied yet. You might be expecting `*-exit-done`, but if you think
     *    about it, a component cannot finish exiting if it hasn't entered yet.
     *
     * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
     *    allows you to define different behavior for when appearing is done and
     *    when regular entering is done, using selectors like
     *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
     *    an epic entrance animation when element first appears in the DOM using
     *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
     *    simply use `fade-enter-done` for defining both cases.
     *
     * Each individual classNames can also be specified independently like:
     *
     * ```js
     * classNames={{
     *  appear: 'my-appear',
     *  appearActive: 'my-active-appear',
     *  appearDone: 'my-done-appear',
     *  enter: 'my-enter',
     *  enterActive: 'my-active-enter',
     *  enterDone: 'my-done-enter',
     *  exit: 'my-exit',
     *  exitActive: 'my-active-exit',
     *  exitDone: 'my-done-exit',
     * }}
     * ```
     *
     * If you want to set these classes using CSS Modules:
     *
     * ```js
     * import styles from './styles.css';
     * ```
     *
     * you might want to use camelCase in your CSS file, that way could simply
     * spread them instead of listing them one by one:
     *
     * ```js
     * classNames={{ ...styles }}
     * ```
     *
     * @type {string | {
     *  appear?: string,
     *  appearActive?: string,
     *  appearDone?: string,
     *  enter?: string,
     *  enterActive?: string,
     *  enterDone?: string,
     *  exit?: string,
     *  exitActive?: string,
     *  exitDone?: string,
     * }}
     */
    classNames: classNamesShape,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEnter: propTypesExports.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter-active' or
     * 'appear-active' class is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: propTypesExports.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or
     * 'appear' classes are **removed** and the `done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntered: propTypesExports.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExit: propTypesExports.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExiting: propTypesExports.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' classes
     * are **removed** and the `exit-done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExited: propTypesExports.func
  }) : {};
  const CSSTransition$1 = CSSTransition;
  const defaultProps$1p = {
    ...ComponentDefaults,
    position: "center",
    transition: "",
    style: {},
    popClass: "",
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    closeIconSize: "12px",
    destroyOnClose: true,
    teleport: null,
    overlay: true,
    round: false,
    onOpen: () => {
    },
    onClose: () => {
    },
    onOpened: (e) => {
    },
    onClosed: (e) => {
    },
    onClickOverlay: (e) => {
    },
    onClickCloseIcon: (e) => {
    },
    ...defaultOverlayProps
  };
  let _zIndex = 2e3;
  const Popup = (props) => {
    const {
      children,
      visible,
      overlay,
      closeOnClickOverlay,
      overlayStyle,
      overlayClass,
      zIndex,
      lockScroll,
      duration,
      closeable,
      closeIconPosition,
      closeIcon,
      style,
      transition,
      round,
      position,
      popClass,
      className,
      destroyOnClose,
      teleport,
      onOpen,
      onClose,
      onClickOverlay,
      onClickCloseIcon,
      onOpened,
      onClosed,
      onClick,
      iconClassPrefix,
      iconFontClassName,
      closeIconSize
    } = props;
    const [index, setIndex] = React.useState(zIndex || _zIndex);
    const [innerVisible, setInnerVisible] = React.useState(visible);
    const [showChildren, setShowChildren] = React.useState(true);
    const [transitionName, setTransitionName] = React.useState("");
    const b2 = cn("popup");
    const baseStyle = {
      zIndex: index,
      animationDuration: `${duration}s`
    };
    const overlayStyles = {
      ...overlayStyle,
      ...baseStyle
    };
    const popStyles = {
      ...style,
      ...baseStyle
    };
    const classes = classNames(
      {
        round,
        [`nut-popup-${position}`]: true,
        [`${popClass}`]: true,
        [`${className || ""}`]: true
      },
      b2("")
    );
    const closeClasses = classNames({
      "nut-popup__close-icon": true,
      [`nut-popup__close-icon--${closeIconPosition}`]: true
    });
    const open = () => {
      if (!innerVisible) {
        setInnerVisible(true);
        setIndex(++_zIndex);
      }
      if (destroyOnClose) {
        setShowChildren(true);
      }
      onOpen && onOpen();
    };
    const close = () => {
      if (innerVisible) {
        setInnerVisible(false);
        if (destroyOnClose) {
          setTimeout(() => {
            setShowChildren(false);
            onClose && onClose();
          }, Number(duration) * 1e3);
        }
      }
    };
    const onHandleClickOverlay = (e) => {
      if (closeOnClickOverlay) {
        onClickOverlay && onClickOverlay(e);
        close();
      }
    };
    const onHandleClick = (e) => {
      onClick && onClick(e);
    };
    const onHandleClickCloseIcon = (e) => {
      onClickCloseIcon && onClickCloseIcon(e);
      close();
    };
    const onHandleOpened = (e) => {
      onOpened && onOpened(e);
    };
    const onHandleClosed = (e) => {
      onClosed && onClosed(e);
    };
    const resolveContainer = (getContainer) => {
      const container = typeof getContainer === "function" ? getContainer() : getContainer;
      return container || document.body;
    };
    const renderToContainer = (getContainer, node) => {
      if (getContainer) {
        const container = resolveContainer(getContainer);
        return ReactDOM.createPortal(node, container);
      }
      return node;
    };
    const renderPop = () => {
      return /* @__PURE__ */ React.createElement(
        CSSTransition$1,
        {
          classNames: transitionName,
          unmountOnExit: true,
          timeout: 500,
          in: innerVisible,
          onEntered: onHandleOpened,
          onExited: onHandleClosed
        },
        /* @__PURE__ */ React.createElement("div", { style: popStyles, className: classes, onClick: onHandleClick }, showChildren ? children : "", closeable ? /* @__PURE__ */ React.createElement("div", { className: closeClasses, onClick: onHandleClickCloseIcon }, /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: closeIcon,
            size: closeIconSize
          }
        )) : "")
      );
    };
    const renderNode = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, overlay ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
        Overlay,
        {
          style: overlayStyles,
          overlayClass,
          visible: innerVisible,
          closeOnClickOverlay,
          zIndex,
          lockScroll,
          duration,
          onClick: onHandleClickOverlay
        }
      ), renderPop()) : /* @__PURE__ */ React.createElement(React.Fragment, null, renderPop()));
    };
    React.useEffect(() => {
      visible && open();
      !visible && close();
    }, [visible]);
    React.useEffect(() => {
      setTransitionName(transition || `nut-popup-slide-${position}`);
    }, [position]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, renderToContainer(teleport, renderNode()));
  };
  Popup.defaultProps = defaultProps$1p;
  Popup.displayName = "NutPopup";
  const DataContext$2 = React.createContext({});
  const defaultProps$1o = {
    span: "24",
    offset: "0",
    gutter: "0"
  };
  const Col = (props) => {
    const {
      className,
      style = {},
      span,
      offset,
      children,
      onClick
    } = {
      ...defaultProps$1o,
      ...props
    };
    const [colName, setColName] = React.useState("");
    const [colStyle, setColStyle] = React.useState({});
    const { gutter } = React.useContext(DataContext$2);
    const classs = () => {
      const prefixCls = "nut-col";
      return `${prefixCls} ${prefixCls}-${span} ${gutter ? `${prefixCls}-gutter` : ""} ${prefixCls}-${offset}`;
    };
    const getStyle = () => {
      const style2 = {};
      style2.paddingLeft = `${gutter / 2}px`;
      style2.paddingRight = `${gutter / 2}px`;
      return style2;
    };
    React.useEffect(() => {
      setColName(classs);
      setColStyle(getStyle);
    }, [span, offset, gutter]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames(colName, className),
        style: { ...style, ...colStyle },
        onClick: (e) => {
          onClick && onClick(e, "col");
        }
      },
      children
    );
  };
  Col.defaultProps = defaultProps$1o;
  Col.displayName = "NutCol";
  const defaultProps$1n = {
    contentPosition: "center",
    dashed: false,
    hairline: true,
    direction: "horizontal"
  };
  const Divider = (props) => {
    const {
      children,
      contentPosition,
      dashed,
      hairline,
      styles,
      className,
      direction,
      ...rest
    } = {
      ...defaultProps$1n,
      ...props
    };
    const dividerBem = cn("divider");
    const classes = direction === "horizontal" ? classNames({
      [dividerBem()]: true,
      [dividerBem("center")]: children,
      [dividerBem("left")]: contentPosition === "left",
      [dividerBem("right")]: contentPosition === "right",
      [dividerBem("dashed")]: dashed,
      [dividerBem("hairline")]: hairline
    }) : classNames({
      [dividerBem()]: true,
      [dividerBem("vertical")]: direction === "vertical"
    });
    return /* @__PURE__ */ React.createElement("div", { className: `${classes} ${className || ""}`, style: styles, ...rest }, children);
  };
  Divider.defaultProps = defaultProps$1n;
  Divider.displayName = "NutDivider";
  const gridContext = {
    onClick: (item, index) => {
    }
  };
  const GridContext = React.createContext(gridContext);
  const defaultProps$1m = {
    columnNum: 4,
    border: true,
    gutter: 0,
    center: true,
    square: false,
    reverse: false,
    direction: "vertical",
    iconSize: 28,
    iconColor: ""
  };
  const Grid = (props) => {
    useConfig$1();
    const {
      children,
      columnNum,
      border,
      gutter,
      center,
      square,
      reverse,
      direction,
      style,
      iconSize,
      iconColor,
      className,
      onClick,
      ...rest
    } = { ...defaultProps$1m, ...props };
    const childrenDom = React.Children.toArray(children);
    const pxCheck2 = (value) => {
      return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
    };
    const b2 = cn("grid");
    const rootClass = () => {
      const prefixCls = b2();
      return classNames(className, prefixCls, {
        [b2("border")]: border && !gutter
      });
    };
    const rootStyle = () => {
      let styleSelf = {};
      if (style) {
        styleSelf = style;
      }
      if (gutter) {
        styleSelf.paddingLeft = pxCheck2(gutter);
      }
      return styleSelf;
    };
    return /* @__PURE__ */ React.createElement("div", { className: rootClass(), style: rootStyle(), ...rest }, /* @__PURE__ */ React.createElement(GridContext.Provider, { value: { onClick } }, childrenDom.map((item, idex) => {
      return React.cloneElement(item, {
        index: idex,
        columnNum,
        center,
        border,
        gutter,
        square,
        reverse,
        direction,
        parentIconSize: iconSize,
        parentIconColor: iconColor
      });
    })));
  };
  Grid.defaultProps = defaultProps$1m;
  Grid.displayName = "NutGrid";
  const defaultProps$1l = {
    ...ComponentDefaults,
    text: "",
    fontSize: "",
    color: "",
    icon: "",
    iconSize: "",
    iconColor: "",
    parentIconSize: "",
    parentIconColor: "",
    columnNum: 4,
    border: true,
    gutter: 0,
    center: true,
    square: false,
    reverse: false,
    direction: "vertical"
  };
  const GridItem = (props) => {
    useConfig$1();
    const {
      children,
      columnNum,
      index,
      gutter,
      square,
      text,
      fontSize,
      color,
      icon,
      iconColor,
      iconSize,
      parentIconSize,
      parentIconColor,
      border,
      center,
      reverse,
      direction,
      iconClassPrefix,
      iconFontClassName,
      className,
      onClick,
      style,
      ...rest
    } = {
      ...defaultProps$1l,
      ...props
    };
    const b2 = cn("grid-item");
    const classes = classNames(b2(), className);
    const context = React.useContext(GridContext);
    const pxCheck2 = (value) => {
      return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
    };
    const rootStyle = () => {
      const rootStyle2 = {
        flexBasis: `${100 / +columnNum}%`
      };
      if (square) {
        rootStyle2.paddingTop = `${100 / +columnNum}%`;
      } else if (gutter) {
        rootStyle2.paddingRight = pxCheck2(gutter);
        if (index >= columnNum) {
          rootStyle2.marginTop = pxCheck2(gutter);
        }
      }
      return { ...rootStyle2, ...style };
    };
    const contentClass = () => {
      return classNames(b2("content"), {
        [b2("content--border")]: border,
        [b2("content--surround")]: border && gutter,
        [b2("content--center")]: center,
        [b2("content--square")]: square,
        [b2("content--reverse")]: reverse,
        [b2(`content--${direction}`)]: !!direction
      });
    };
    const isIconName = () => {
      return typeof icon === "string";
    };
    const handleClick = (e) => {
      onClick && onClick(e);
      context.onClick && context.onClick(
        {
          text,
          icon,
          iconSize,
          iconColor,
          parentIconSize,
          parentIconColor,
          index,
          columnNum,
          border,
          gutter,
          center,
          square,
          reverse,
          direction,
          fontSize,
          color
        },
        index
      );
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classes,
        style: rootStyle(),
        ...rest,
        onClick: handleClick
      },
      /* @__PURE__ */ React.createElement("div", { className: contentClass() }, icon && isIconName() ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: icon,
          size: iconSize || parentIconSize,
          color: iconColor || parentIconColor
        }
      ) : /* @__PURE__ */ React.createElement(React.Fragment, null, icon), text && /* @__PURE__ */ React.createElement("div", { className: "nut-grid-item__text", style: { fontSize, color } }, text), children && /* @__PURE__ */ React.createElement(React.Fragment, null, children))
    );
  };
  GridItem.defaultProps = defaultProps$1l;
  GridItem.displayName = "NutGridItem";
  const defaultProps$1k = {};
  const Layout = (props) => {
    ({ ...defaultProps$1k, ...props });
    return /* @__PURE__ */ React.createElement("div", { className: "nut-layout" }, "Layout");
  };
  Layout.defaultProps = defaultProps$1k;
  Layout.displayName = "NutLayout";
  const defaultProps$1j = {
    type: "",
    justify: "start",
    align: "flex-start",
    wrap: "nowrap",
    gutter: "0"
  };
  const Row = (props) => {
    const {
      className,
      style = {},
      children,
      type,
      justify,
      align,
      wrap,
      gutter,
      onClick
    } = {
      ...defaultProps$1j,
      ...props
    };
    const prefixCls = "nut-row";
    const getClass = (prefix2, type2) => {
      const classType = type2 ? `nut-row-${prefix2}-${type2}` : "";
      const className2 = prefix2 ? classType : `nut-row-${type2}`;
      return className2;
    };
    const getClasses = () => {
      return `
    ${getClass("", type)}
    ${getClass("justify", justify)}
    ${getClass("align", align)}
    ${getClass("flex", wrap)}
    ${prefixCls}
   `;
    };
    const parentRow = {
      gutter
    };
    return /* @__PURE__ */ React.createElement(DataContext$2.Provider, { value: parentRow }, React.createElement(
      "div",
      {
        className: classNames(getClasses(), className),
        style,
        onClick: (e) => {
          onClick && onClick(e, "row");
        }
      },
      children
    ));
  };
  Row.defaultProps = defaultProps$1j;
  Row.displayName = "NutRow";
  function useWatch(dep, callback, config2 = { immediate: false }) {
    const { immediate } = config2;
    const prev = React.useRef();
    const inited = React.useRef(false);
    const stop2 = React.useRef(false);
    React.useEffect(() => {
      const execute = () => callback(prev.current);
      if (!stop2.current) {
        if (!inited.current) {
          inited.current = true;
          if (immediate) {
            execute();
          }
        } else {
          execute();
        }
        prev.current = dep;
      }
    }, [dep]);
    return () => {
      stop2.current = true;
    };
  }
  const getRectByTaro = async (element) => {
    if (element) {
      const res = await element.getBoundingClientRect();
      return res;
    }
    return Promise.resolve({});
  };
  const canUseDom = !!(typeof window !== "undefined" && typeof document !== "undefined" && window.document && window.document.createElement);
  const defaultRoot = canUseDom ? window : void 0;
  const overflowStylePatterns = ["scroll", "auto", "overlay"];
  function isElement(node) {
    const ELEMENT_NODE_TYPE = 1;
    return node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent(el, root2 = defaultRoot) {
    let node = el;
    while (node && node !== root2 && isElement(node)) {
      if (node === document.body) {
        return root2;
      }
      const { overflowY } = window.getComputedStyle(node);
      if (overflowStylePatterns.includes(overflowY) && node.scrollHeight > node.clientHeight) {
        return node;
      }
      node = node.parentNode;
    }
    return root2;
  }
  const defaultProps$1i = {
    position: "top",
    top: 0,
    bottom: 0,
    zIndex: 2e3
  };
  const b$2 = cn("sticky");
  const Sticky = (props) => {
    const {
      position = "top",
      top = 0,
      bottom = 0,
      zIndex = 2e3,
      children,
      container,
      className,
      onChange,
      ...rest
    } = props;
    const stickyRef = React.useRef(null);
    const rootRef = React.useRef(null);
    const offset = position === "top" ? top : bottom;
    const [rootRect, setRootRect] = React.useState({});
    const [fixed, setFixed] = React.useState(false);
    const [transform, setTransform] = React.useState(0);
    useWatch(fixed, () => {
      onChange && onChange(fixed);
    });
    const rootStyle = React.useMemo(() => {
      if (!fixed) {
        return {
          height: "",
          width: ""
        };
      }
      const style = {};
      if (rootRect.height) {
        style.height = rootRect.height;
      }
      if (rootRect.width) {
        style.width = rootRect.width;
      }
      return style;
    }, [fixed, rootRect.height, rootRect.width]);
    const stickyStyle = React.useMemo(() => {
      if (!fixed) {
        return {
          height: "",
          width: "",
          [position]: ""
        };
      }
      let style = {};
      if (rootRect.height)
        style.height = rootRect.height;
      if (rootRect.width)
        style.width = rootRect.width;
      style.transform = `translate3d(0, ${transform}px, 0)`;
      style[position] = offset;
      style.zIndex = zIndex;
      return style;
    }, [fixed, rootRect.height, rootRect.width, transform, position]);
    const handleScroll = async (scrollTop) => {
      const curRootRect = await getRectByTaro(rootRef.current);
      const stickyRect = await getRectByTaro(stickyRef.current);
      if (curRootRect && stickyRect) {
        setRootRect(curRootRect);
        if (position === "top") {
          if (container) {
            const containerRect = await getRectByTaro(container.current);
            const difference = containerRect.bottom - top - curRootRect.height;
            const curTransform = difference < 0 ? difference : 0;
            setTransform(curTransform);
            const curFixed = top > curRootRect.top && containerRect.bottom > 0;
            setFixed(curFixed);
          } else {
            setFixed(top > curRootRect.top);
          }
        } else {
          const windowHeight = Taro.getSystemInfoSync().windowHeight;
          setFixed(windowHeight - offset < curRootRect.bottom);
        }
      } else {
        console.log("getRectByTaro获取失败", { stickyRect, curRootRect });
      }
    };
    const getElement = React.useCallback(() => {
      return getScrollParent(rootRef.current);
    }, []);
    React.useEffect(() => {
      if (Taro.getEnv() === "WEB" && getElement() !== window) {
        window.addEventListener("touchmove", handleScroll, true);
        window.addEventListener("scroll", handleScroll, true);
        return () => {
          window.removeEventListener("touchmove", handleScroll);
          window.removeEventListener("scroll", handleScroll);
        };
      }
    }, []);
    Taro.usePageScroll((res) => {
      if (Taro.getEnv() === "WEAPP") {
        handleScroll(res.scrollTop);
      }
    });
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: rootRef,
        style: rootStyle,
        className: classNames(b$2(), className),
        ...rest
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames("nut-sticky-box", { "nut-sticky-fixed": fixed }),
          ref: stickyRef,
          style: stickyStyle
        },
        children
      )
    );
  };
  Sticky.defaultProps = defaultProps$1i;
  Sticky.displayName = "NutSticky";
  const elevatorContext = React.createContext({});
  const defaultProps$1h = {
    height: "200px",
    acceptKey: "title",
    indexList: [],
    isSticky: false,
    spaceHeight: 23,
    titleHeight: 35,
    className: "weapp-elevator"
  };
  const Elevator = (props) => {
    const {
      height,
      acceptKey,
      indexList,
      isSticky,
      spaceHeight,
      titleHeight,
      className,
      onClickItem,
      onClickIndex,
      children,
      ...rest
    } = {
      ...defaultProps$1h,
      ...props
    };
    const b2 = cn("elevator");
    const listview = React.useRef(null);
    const initData = {
      anchorIndex: 0,
      listHeight: [],
      listGroup: [],
      scrollY: 0
    };
    const touchState = React.useRef({
      y1: 0,
      y2: 0
    });
    const [currentData, setCurrentData] = React.useState(
      {}
    );
    const [currentKey, setCurrentKey] = React.useState("");
    const [currentIndex, setCurrentIndex] = React.useState(0);
    const [codeIndex, setCodeIndex] = React.useState(0);
    const [scrollStart, setScrollStart] = React.useState(false);
    const state = React.useRef(initData);
    const [scrollTop, setScrollTop] = React.useState(0);
    const [scrollY, setScrollY] = React.useState(0);
    const resetScrollState = () => {
      setScrollStart(false);
    };
    const getData = (el) => {
      if (!el.dataset.index) {
        return "0";
      }
      return el.dataset.index;
    };
    const calculateHeight = () => {
      let height2 = 0;
      state.current.listHeight.push(height2);
      for (let i = 0; i < state.current.listGroup.length; i++) {
        const query = Taro.createSelectorQuery();
        query.selectAll(`.${className} .elevator__item__${i}`).boundingClientRect();
        query.exec((res) => {
          if (res[0][0])
            height2 += res[0][0].height;
          state.current.listHeight.push(height2);
        });
      }
    };
    const scrollTo = (index) => {
      if (!index && index !== 0) {
        return;
      }
      if (!state.current.listHeight.length) {
        calculateHeight();
      }
      let cacheIndex = index;
      if (index < 0) {
        cacheIndex = 0;
      }
      if (index > state.current.listHeight.length - 2) {
        cacheIndex = state.current.listHeight.length - 2;
      }
      setCodeIndex(cacheIndex);
      const scrollTop2 = state.current.listHeight[cacheIndex];
      setScrollTop(scrollTop2);
      if (isSticky && scrollY !== scrollTop2) {
        setScrollY(Math.floor(scrollTop2) > 0 ? 1 : 0);
      }
    };
    const touchMove = (e) => {
      const firstTouch = e.touches[0];
      touchState.current.y2 = firstTouch.pageY;
      const delta = (touchState.current.y2 - touchState.current.y1) / spaceHeight || 0;
      const cacheIndex = state.current.anchorIndex + Math.floor(delta);
      setCodeIndex(cacheIndex);
      scrollTo(cacheIndex);
    };
    const touchEnd = () => {
      resetScrollState();
    };
    const touchStart = (e) => {
      setScrollStart(true);
      const index = Number(getData(e.target));
      const firstTouch = e.touches[0];
      touchState.current.y1 = firstTouch.pageY;
      state.current.anchorIndex = +index;
      setCodeIndex((codeIndex2) => {
        return codeIndex2 + index;
      });
      scrollTo(index);
    };
    const handleClickItem = (key, item) => {
      onClickItem && onClickItem(key, item);
      setCurrentData(item);
      setCurrentKey(key);
    };
    const handleClickIndex = (key) => {
      onClickIndex && onClickIndex(key);
    };
    const setListGroup = () => {
      if (listview.current) {
        Taro.createSelectorQuery().selectAll(`.${className} .nut-elevator__list__item`).node((el) => {
          state.current.listGroup = [...Object.keys(el)];
          calculateHeight();
        }).exec();
      }
    };
    const listViewScroll = (e) => {
      const { listHeight } = state.current;
      if (!listHeight.length) {
        calculateHeight();
      }
      const target = e.target;
      const { scrollTop: scrollTop2 } = target;
      state.current.scrollY = Math.floor(scrollTop2);
      Taro.getEnv() === "WEB" && setScrollTop(scrollTop2);
      if (isSticky && scrollTop2 !== scrollY) {
        setScrollY(Math.floor(scrollTop2) > 0 ? 1 : 0);
      }
      for (let i = 0; i < listHeight.length - 1; i++) {
        const height1 = listHeight[i];
        const height2 = listHeight[i + 1];
        if (state.current.scrollY >= height1 && state.current.scrollY < height2) {
          setCurrentIndex(i);
          return;
        }
      }
    };
    React.useEffect(() => {
      if (listview.current) {
        Taro.nextTick(() => {
          setListGroup();
        });
      }
    }, [listview]);
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className} `, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: b2("list"),
        style: { height: Number.isNaN(+height) ? height : `${height}px` }
      },
      /* @__PURE__ */ React.createElement(
        components.ScrollView,
        {
          scrollTop,
          scrollY: true,
          scrollWithAnimation: true,
          scrollAnchoring: true,
          className: b2("list__inner"),
          ref: listview,
          onScroll: listViewScroll
        },
        indexList.map((item, idx) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `${b2("list__item")} elevator__item__${idx}`,
              key: idx
            },
            /* @__PURE__ */ React.createElement("div", { className: b2("list__item__code") }, item[acceptKey]),
            /* @__PURE__ */ React.createElement(React.Fragment, null, item.list.map((subitem) => {
              return /* @__PURE__ */ React.createElement(
                "div",
                {
                  className: b2("list__item__name", {
                    highcolor: currentData.id === subitem.id && currentKey === item[acceptKey]
                  }),
                  key: subitem.id,
                  onClick: () => handleClickItem(item[acceptKey], subitem)
                },
                children ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(elevatorContext.Provider, { value: subitem }, children)) : subitem.name
              );
            }))
          );
        })
      )
    ), indexList.length && scrollStart ? /* @__PURE__ */ React.createElement("div", { className: b2("code--current", { current: true }) }, indexList[codeIndex][acceptKey]) : null, /* @__PURE__ */ React.createElement("div", { className: b2("bars") }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: b2("bars__inner"),
        onTouchStart: (event) => touchStart(event),
        onTouchMove: (event) => touchMove(event),
        onTouchEnd: touchEnd,
        style: { touchAction: "pan-y" }
      },
      indexList.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2("bars__inner__item", {
              active: item[acceptKey] === indexList[currentIndex][acceptKey]
            })} `,
            "data-index": index,
            key: index,
            onClick: () => handleClickIndex(item[acceptKey])
          },
          item[acceptKey]
        );
      })
    )), isSticky && scrollY > 0 ? /* @__PURE__ */ React.createElement("div", { className: b2("list__fixed") }, /* @__PURE__ */ React.createElement("span", { className: "fixed-title" }, indexList[currentIndex][acceptKey])) : null);
  };
  Elevator.defaultProps = defaultProps$1h;
  Elevator.displayName = "NutElevator";
  Elevator.Context = elevatorContext;
  const defaultProps$1g = {
    ...ComponentDefaults,
    fixednavClass: "nut-fixednav",
    activeText: "",
    unActiveText: "",
    type: "right",
    position: {
      top: "auto",
      bottom: "auto"
    }
  };
  const FixedNav = (props) => {
    const { locale } = useConfig$1();
    const {
      fixednavClass,
      overlay,
      visible,
      navList,
      activeText,
      unActiveText,
      position,
      onChange,
      onSelected,
      type,
      slotList,
      slotBtn,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$1g,
      ...props
    };
    const b2 = cn("fixednav");
    const classes = classNames(
      {
        active: visible
      },
      type,
      fixednavClass,
      b2("")
    );
    const onSelectCb = (event, item) => {
      onSelected(item, event);
    };
    const onUpdateValue = (value = !visible) => {
      onChange(value);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style: position, ...rest }, overlay && /* @__PURE__ */ React.createElement(
      Overlay,
      {
        visible,
        zIndex: 200,
        onClick: () => onUpdateValue(false)
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "list" }, slotList || /* @__PURE__ */ React.createElement("div", { className: "nut-fixednav__list" }, navList.map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-fixednav__list-item",
          onClick: (event) => onSelectCb(event, item),
          key: item.id || index
        },
        /* @__PURE__ */ React.createElement("img", { src: item.icon, alt: "" }),
        /* @__PURE__ */ React.createElement("div", { className: "nut-fixednav__list-text" }, item.text),
        item.num && /* @__PURE__ */ React.createElement("div", { className: "b" }, item.num)
      );
    }))), /* @__PURE__ */ React.createElement("div", { className: "nut-fixednav__btn", onClick: () => onUpdateValue() }, slotBtn || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        name: "left",
        color: "#fff"
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "text" }, visible ? activeText || locale.fixednav.activeText : unActiveText || locale.fixednav.unActiveText))));
  };
  FixedNav.defaultProps = defaultProps$1g;
  FixedNav.displayName = "NutFixedNav";
  const defaultProps$1f = {
    size: 3,
    current: 1,
    block: false,
    align: "center",
    fillZero: true,
    vertical: false
  };
  const Indicator = (props) => {
    const {
      size,
      current,
      block,
      align,
      fillZero,
      children,
      className,
      vertical,
      ...rest
    } = {
      ...defaultProps$1f,
      ...props
    };
    const b2 = cn("indicator");
    const classes = classNames(
      {
        [`${b2("block")}`]: block,
        [`${b2("align")}__${align}`]: block && align,
        [`${b2("vertical")}`]: vertical
      },
      b2("")
    );
    const renderEles = () => {
      const childs = [];
      for (let item = 1; item <= size; item++) {
        childs.push(
          item === current ? /* @__PURE__ */ React.createElement("div", { key: item, className: b2("number") }, fillZero && item < 10 ? `0${item}` : item) : /* @__PURE__ */ React.createElement("div", { key: item, className: b2("dot") })
        );
      }
      return childs;
    };
    React.useEffect(() => {
    }, []);
    return /* @__PURE__ */ React.createElement("div", { className: classNames(classes, className), ...rest }, renderEles());
  };
  Indicator.defaultProps = defaultProps$1f;
  Indicator.displayName = "NutIndicator";
  const defaultProps$1e = {
    ...ComponentDefaults,
    className: "",
    style: {},
    activeColor: "#F2270C",
    closeOnClickOverlay: true,
    scrollFixed: false,
    lockScroll: true,
    titleIcon: ""
  };
  const Menu = (props) => {
    const {
      className,
      titleIcon,
      scrollFixed,
      lockScroll,
      closeOnClickOverlay,
      children,
      activeColor,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$1e,
      ...props
    };
    const parentRef = React.useRef(null);
    const onScroll = () => {
    };
    React.useEffect(() => {
      if (scrollFixed) {
        window.addEventListener("scroll", onScroll);
      }
      return () => window.removeEventListener("scroll", onScroll);
    }, []);
    const [itemShow, setItemShow] = React.useState([]);
    const [itemTitle, setItemTitle] = React.useState([]);
    const toggleItemShow = (index) => {
      itemShow[index] = !itemShow[index];
      const temp = itemShow.map((i, idx) => idx === index ? i : false);
      setItemShow([...temp]);
    };
    const hideItemShow = (index) => {
      itemShow[index] = false;
      setItemShow([...itemShow]);
    };
    const updateTitle = (text, index) => {
      itemTitle[index] = text;
      setItemTitle([...itemTitle]);
    };
    const parent = () => {
      return parentRef;
    };
    const cloneChildren = () => {
      return React.Children.map(children, (child, index) => {
        return React.cloneElement(child, {
          showPopup: itemShow[index],
          orderKey: index,
          activeColor,
          parent: {
            closeOnClickOverlay,
            lockScroll,
            toggleItemShow,
            updateTitle,
            hideItemShow,
            parent
          }
        });
      });
    };
    return /* @__PURE__ */ React.createElement("div", { className: `nut-menu ${className}`, ...rest, ref: parentRef }, /* @__PURE__ */ React.createElement("div", { className: "nut-menu-relative" }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `nut-menu__bar ${itemShow.includes(true) ? "opened" : ""} ${className}`
      },
      React.Children.toArray(children).map((child, index) => {
        if (!child)
          return null;
        const { disabled, title, value, direction, options, className: className2 } = child.props;
        const currentTitle = options == null ? void 0 : options.filter(
          (option) => option.value === value
        );
        function finallyTitle() {
          if (title)
            return title;
          if (itemTitle && itemTitle[index])
            return itemTitle[index];
          if (currentTitle && currentTitle[0] && currentTitle[0].text)
            return currentTitle[0].text;
          return "";
        }
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-menu__item ${classNames({
              active: itemShow[index],
              disabled
            })} ${className2}`,
            style: { color: itemShow[index] ? activeColor : "" },
            key: index,
            onClick: () => {
              !disabled && toggleItemShow(index);
            }
          },
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-menu__title ${classNames({
                active: itemShow[index],
                disabled
              })}`
            },
            /* @__PURE__ */ React.createElement("div", { className: "nut-menu__title-text" }, finallyTitle()),
            /* @__PURE__ */ React.createElement(
              Icon$1,
              {
                classPrefix: iconClassPrefix,
                fontClassName: iconFontClassName,
                className: "nut-menu__title-icon",
                size: "10",
                name: titleIcon || (direction === "up" ? "arrow-up" : "down-arrow")
              }
            )
          )
        );
      })
    ), cloneChildren()));
  };
  Menu.defaultProps = defaultProps$1e;
  Menu.displayName = "NutMenu";
  const defaultProps$1d = {
    ...ComponentDefaults,
    className: "",
    style: {},
    columns: 1,
    direction: "down",
    optionsIcon: "Check",
    activeTitleClass: "",
    inactiveTitleClass: "",
    iconClassPrefix: "nut-icon",
    fontClassName: "nutui-iconfont",
    onChange: (value) => void 0
  };
  const MenuItem = React.forwardRef((props, ref) => {
    const mergedProps = { ...defaultProps$1d, ...props };
    const {
      style,
      options,
      value,
      columns,
      title,
      optionsIcon,
      direction,
      onChange,
      activeTitleClass,
      inactiveTitleClass,
      children,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$1d,
      ...props
    };
    const { activeColor, showPopup, parent, orderKey } = mergedProps;
    const [_showPopup, setShowPopup] = React.useState(showPopup);
    const [_value, setValue] = React.useState(value);
    React.useEffect(() => {
      setShowPopup(showPopup);
    }, [showPopup]);
    React.useEffect(() => {
      getParentOffset();
    }, [_showPopup]);
    const windowHeight = React.useMemo(() => Taro.getSystemInfoSync().windowHeight, []);
    const updateItemOffset = React.useCallback(() => {
      const p = parent.parent().current;
      p.getBoundingClientRect().then((rect) => {
        if (rect) {
          setPosition({
            height: rect.height,
            top: rect.top
          });
        }
      });
    }, [direction, windowHeight]);
    Taro.usePageScroll(updateItemOffset);
    React.useImperativeHandle(ref, () => ({
      toggle: parent.toggleItemShow
    }));
    const getIconCName = (optionVal, value2) => {
      return classNames({
        [activeTitleClass]: optionVal === value2,
        [inactiveTitleClass]: optionVal !== value2
      });
    };
    const setTitle = (text) => {
      if (!title) {
        parent.updateTitle(text, orderKey);
      }
    };
    const handleClick = (item) => {
      parent.toggleItemShow(orderKey);
      setTitle(item.text);
      setValue(item.value);
      onChange && onChange(item);
    };
    const [position, setPosition] = React.useState({
      top: 0,
      height: 0
    });
    const getParentOffset = () => {
      setTimeout(async () => {
        const p = parent.parent().current;
        const rect = await p.getBoundingClientRect();
        setPosition({
          height: rect.height,
          top: rect.top
        });
      });
    };
    const isShow = () => {
      if (_showPopup)
        return {};
      return { display: "none" };
    };
    const getPosition = () => {
      return direction === "down" ? { top: `${position.top + position.height}px` } : {
        bottom: `${Taro.getSystemInfoSync().windowHeight - position.top}px`,
        top: "0",
        height: "initial"
      };
    };
    const placeholderStyle = () => {
      if (direction === "down") {
        return {
          height: `${position.top + position.height}px`,
          ...isShow(),
          ...style
        };
      }
      return {
        height: `${Taro.getSystemInfoSync().windowHeight - position.top}px`,
        top: "auto",
        ...isShow(),
        ...style
      };
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      components.View,
      {
        className: `placeholder-element ${classNames({
          up: direction === "up"
        })}`,
        style: placeholderStyle(),
        onClick: () => parent.toggleItemShow(orderKey)
      }
    ), /* @__PURE__ */ React.createElement(
      Overlay,
      {
        overlayClass: "nut-menu__overlay",
        style: getPosition(),
        lockScroll: parent.lockScroll,
        visible: _showPopup,
        closeOnClickOverlay: parent.closeOnClickOverlay,
        onClick: () => {
          parent.closeOnClickOverlay && parent.toggleItemShow(orderKey);
        }
      }
    ), /* @__PURE__ */ React.createElement(
      components.View,
      {
        className: direction === "down" ? "nut-menu-item__wrap" : "nut-menu-item__wrap-up",
        style: {
          // ...getPosition(),
          ...isShow()
        }
      },
      /* @__PURE__ */ React.createElement(
        CSSTransition$1,
        {
          in: _showPopup,
          timeout: 100,
          classNames: direction === "down" ? "menu-item" : "menu-item-up"
        },
        /* @__PURE__ */ React.createElement(components.View, { className: "nut-menu-item__content" }, options == null ? void 0 : options.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            components.View,
            {
              className: `nut-menu-item__option ${classNames({
                active: item.value === _value
              })}`,
              key: item.text,
              style: {
                flexBasis: `${100 / columns}%`
              },
              onClick: () => {
                handleClick(item);
              }
            },
            item.value === _value ? /* @__PURE__ */ React.createElement(
              Icon$1,
              {
                classPrefix: iconClassPrefix,
                fontClassName: iconFontClassName,
                className: getIconCName(item.value, value),
                name: optionsIcon,
                color: activeColor
              }
            ) : null,
            /* @__PURE__ */ React.createElement(
              components.View,
              {
                className: getIconCName(item.value, value),
                style: {
                  color: `${item.value === _value ? activeColor : ""}`
                }
              },
              item.text
            )
          );
        }), children)
      )
    ));
  });
  MenuItem.defaultProps = defaultProps$1d;
  MenuItem.displayName = "NutMenuItem";
  const defaultProps$1c = {
    ...ComponentDefaults,
    title: "",
    desc: "",
    leftShow: true,
    titIcon: "",
    className: "",
    leftText: "",
    fixed: false,
    safeAreaInsetTop: false,
    border: false,
    placeholder: false,
    zIndex: 10,
    style: {}
  };
  const NavBar = (props) => {
    const {
      desc,
      title,
      titIcon,
      leftShow,
      className,
      style,
      leftText,
      fixed,
      safeAreaInsetTop,
      border,
      placeholder,
      zIndex,
      onClickTitle,
      onClickIcon,
      onClickBack,
      onClickRight,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$1c,
      ...props
    };
    const b2 = cn("navbar");
    const children = Array.isArray(props.children) ? props.children : [props.children];
    const slot = children.reduce((slot2, item) => {
      const data = slot2;
      if (item && item.props) {
        data[item.props.slot] = item;
      }
      return data;
    }, {});
    const styles = () => {
      return {
        ...style,
        zIndex
      };
    };
    const renderLeft = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${b2("left")}`, onClick: (e) => onClickBack(e) }, leftShow && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: "left",
          color: "#979797"
        }
      ), leftText && /* @__PURE__ */ React.createElement("div", { className: `${b2("text")}` }, leftText), slot.left);
    };
    const renderContent = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${b2("title")}` }, title && /* @__PURE__ */ React.createElement("div", { className: "title", onClick: (e) => onClickTitle(e) }, title), titIcon && /* @__PURE__ */ React.createElement("div", { onClick: (e) => onClickIcon(e) }, /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: titIcon
        }
      )), slot.content);
    };
    const renderRight = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${b2("right")}`, onClick: (e) => onClickRight(e) }, desc && /* @__PURE__ */ React.createElement("div", { className: `${b2("text")}` }, desc), slot.right);
    };
    const renderWrapper = () => {
      return /* @__PURE__ */ React.createElement("div", { className: cls, style: styles() }, renderLeft(), renderContent(), renderRight());
    };
    const classes = classNames({
      [`nut-navbar--border`]: border,
      [`nut-navbar--fixed`]: fixed,
      [`nut-navbar--safe-area-inset-top`]: safeAreaInsetTop
    });
    const cls = classNames(b2(""), classes, className);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, fixed && placeholder ? /* @__PURE__ */ React.createElement("div", { className: `${b2("")}--placeholder` }, renderWrapper()) : renderWrapper());
  };
  NavBar.defaultProps = defaultProps$1c;
  NavBar.displayName = "NutNavBar";
  const defaultProps$1b = {
    defaultValue: 1,
    mode: "multi",
    prevText: "",
    nextText: "",
    pageCount: "",
    totalItems: "0",
    itemsPerPage: "10",
    showPageSize: "5",
    forceEllipses: false,
    className: "",
    pageNodeRender: (item) => {
      return item.text;
    }
  };
  const Pagination = (props) => {
    const { locale } = useConfig$1();
    ({ ...defaultProps$1b, ...props });
    const {
      modelValue,
      mode,
      prevText,
      nextText,
      pageCount,
      totalItems,
      itemsPerPage,
      showPageSize,
      onChange,
      updatecurrent,
      forceEllipses,
      pageNodeRender,
      defaultValue,
      className,
      ...rest
    } = props;
    const [currentPage, setCurrent] = React.useState(1);
    const [pages, setPages] = React.useState([]);
    const [countRef, setCountRef] = React.useState(Number(pageCount));
    const paginationBem = cn("pagination");
    const computedCountRef = () => {
      const num = Number(pageCount) || Math.ceil(Number(totalItems) / Number(itemsPerPage));
      return Number.isNaN(num) ? 1 : Math.max(1, num);
    };
    const computedPages = (_currentPage, _countRef) => {
      if (mode === "simple")
        return [];
      const items = [];
      const pageCount2 = _countRef || countRef;
      const pageSize = Number(showPageSize);
      const _current = _currentPage || Number(currentPage);
      let startPage = 1;
      let endPage = pageCount2;
      const partialShow = pageCount2 > pageSize;
      if (partialShow) {
        startPage = Math.max(_current - Math.floor(pageSize / 2), 1);
        endPage = startPage + pageSize - 1;
        if (endPage > pageCount2) {
          endPage = pageCount2;
          startPage = endPage - pageSize + 1;
        }
      }
      for (let i = startPage; i <= endPage; i++) {
        const page = setPage(i, i, _current === i);
        items.push(page);
      }
      if (partialShow && pageSize > 0 && forceEllipses) {
        if (startPage > 1) {
          const prevPage = setPage(startPage - 1, "...");
          items.unshift(prevPage);
        }
        if (endPage < pageCount2) {
          const nextPage = setPage(endPage + 1, "...");
          items.push(nextPage);
        }
      }
      return items;
    };
    const selectPage = (curPage, isSelect) => {
      if (curPage > countRef || curPage < 1)
        return;
      if (!("modelValue" in props)) {
        setCurrent(Number(curPage));
        if (curPage !== currentPage) {
          setPages(computedPages(curPage));
        }
      }
      if (curPage !== currentPage) {
        updatecurrent && updatecurrent(curPage);
      }
      if (isSelect)
        onChange && onChange(curPage);
    };
    const setPage = (number, text, active) => {
      return { number, text, active };
    };
    React.useEffect(() => {
      let currentValue2 = props.defaultValue || 1;
      if ("modelValue" in props) {
        currentValue2 = Number(props.modelValue);
      }
      const pageCount2 = computedCountRef();
      setCountRef(pageCount2);
      setPages(computedPages(currentValue2, pageCount2));
    }, []);
    if ("modelValue" in props) {
      const current = props.modelValue ? Number(props.modelValue) : 1;
      if (current !== currentPage) {
        setCurrent(current);
        setPages(computedPages(Number(current)));
      }
    }
    return /* @__PURE__ */ React.createElement("div", { className: `${paginationBem("")} ${className}`, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${paginationBem("prev")}  ${mode === "multi" ? "" : "simple-border"} ${currentPage === 1 ? "disabled" : ""}`,
        onClick: (e) => selectPage(Number(currentPage) - 1, true)
      },
      prevText || locale.pagination.prev
    ), mode === "multi" ? /* @__PURE__ */ React.createElement("div", { className: `${paginationBem("contain")}` }, pages.map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          key: `${index}pagination`,
          className: `${paginationBem("item")} ${item.active ? "active" : ""}`,
          onClick: (e) => !item.active ? selectPage(item.number, true) : ""
        },
        pageNodeRender ? pageNodeRender(item) : item.text
      );
    })) : "", mode === "simple" ? /* @__PURE__ */ React.createElement("div", { className: `${paginationBem("contain")}` }, /* @__PURE__ */ React.createElement("div", { className: `${paginationBem("simple")}` }, currentPage, "/", countRef)) : "", /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${paginationBem("next")}  ${Number(currentPage) >= countRef ? "disabled" : ""}`,
        onClick: (e) => selectPage(Number(currentPage) + 1, true)
      },
      nextText || locale.pagination.next
    ));
  };
  Pagination.defaultProps = defaultProps$1b;
  Pagination.displayName = "NutPagination";
  const OffsetContext = React.createContext(20);
  const defaultProps$1a = {
    showhead: false,
    position: "left",
    width: "80%"
  };
  const SideNavBar = (props) => {
    useConfig$1();
    const {
      title,
      visible,
      width,
      position,
      children,
      className,
      showhead,
      onClose,
      ...rest
    } = {
      ...defaultProps$1a,
      ...props
    };
    const offset = props.offset ? Number(props.offset) : 20;
    const [sidenavbarShow, setSidenavbarShow] = React.useState(true);
    const handleClick = () => {
      setSidenavbarShow(!sidenavbarShow);
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible,
        style: { width, height: "100%" },
        position,
        onClose
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: className ? `${className} nut-sidenavbar` : "nut-sidenavbar",
          ...rest
        },
        /* @__PURE__ */ React.createElement("div", { className: "nut-sidenavbar__content" }, /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-sidenavbar__list ${sidenavbarShow ? "nutShow" : "nutHide"}`,
            onClick: handleClick
          },
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: "nut-sidenavbar__title border-bt ",
              style: { paddingLeft: `${offset}px` }
            },
            title,
            /* @__PURE__ */ React.createElement(
              "i",
              {
                className: `arrow-icon ${sidenavbarShow ? "arrow-up" : "arrow-down"}`
              }
            )
          ),
          /* @__PURE__ */ React.createElement(OffsetContext.Provider, { value: offset }, /* @__PURE__ */ React.createElement("div", { className: "nut-sidenavbar__content" }, children))
        ))
      )
    );
  };
  SideNavBar.defaultProps = defaultProps$1a;
  SideNavBar.displayName = "NutSideNavBar";
  const SideNavBarItem = (props) => {
    const { title, ikey, children, onClick, ...rest } = props;
    const clickFn = (e) => {
      e.stopPropagation();
      onClick && onClick({ title, ikey });
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-subsidenavbar__item border-bt",
        onClick: clickFn,
        ...rest
      },
      title
    );
  };
  const defaultProps$19 = {
    open: true
  };
  const SubSideNavBar = (props) => {
    const { title, ikey, children, onClick, open, ...rest } = {
      ...defaultProps$19,
      ...props
    };
    const [subShow, setSubShow] = React.useState(open);
    const offset = React.useContext(OffsetContext);
    const listRef = React.useRef(null);
    const setListLevel = React.useCallback(
      (nodeList, level = 1) => {
        const titleClass = nodeList[0].className;
        if (titleClass.includes("nut-subsidenavbar__title")) {
          const left = offset * (level + 1);
          nodeList[0].style.paddingLeft = `${left}px`;
        }
        const childNodes = nodeList[1] && nodeList[1].children && Array.from(nodeList[1].children).filter(
          (item) => item.nodeType !== 3 && item.nodeType !== 8
        );
        childNodes.forEach((item) => {
          const itemClass = item.className;
          if (itemClass.includes("nut-subsidenavbar__item")) {
            const left = offset * (level + 2);
            item.style.paddingLeft = `${left}px`;
          }
          if (itemClass.includes("nut-subsidenavbar__list")) {
            let level2 = item.getAttribute("level") ? Number(item.getAttribute("level")) : 1;
            level2 += 1;
            item.setAttribute("level", level2.toString());
            item.children && setListLevel(item.children, level2);
          }
        });
      },
      [offset]
    );
    const clickFn = (e) => {
      e.stopPropagation();
      setSubShow(!subShow);
      const isShow = !subShow;
      onClick && onClick({ title, ikey, isShow });
    };
    React.useEffect(() => {
      var _a, _b;
      const childNodes = (_a = listRef.current) == null ? void 0 : _a.children;
      (_b = listRef.current) == null ? void 0 : _b.setAttribute("level", "1");
      childNodes && setListLevel(childNodes);
    }, [setListLevel]);
    const divClass = subShow ? "nut-subsidenavbar__list  nutShow" : "nut-subsidenavbar__list  nutHide";
    const iconClass = subShow ? "arrow-icon arrow-down" : "arrow-icon arrow-up";
    return /* @__PURE__ */ React.createElement("div", { className: divClass, ref: listRef, onClick: clickFn, ...rest }, /* @__PURE__ */ React.createElement("div", { className: "nut-subsidenavbar__title border-bt" }, title, " ", /* @__PURE__ */ React.createElement("i", { className: iconClass })), /* @__PURE__ */ React.createElement("div", { className: "nut-subsidenavbar__content" }, children));
  };
  const defaultProps$18 = {
    visible: 0,
    bottom: false,
    size: 20,
    unactiveColor: "",
    activeColor: "",
    safeAreaInsetBottom: false,
    className: "",
    style: {},
    onSwitch: (child, activeVisible) => {
    }
  };
  const Tabbar = (props) => {
    const {
      children,
      visible,
      activeVisible,
      bottom,
      size,
      activeColor,
      unactiveColor,
      safeAreaInsetBottom,
      className,
      style,
      onSwitch
    } = {
      ...defaultProps$18,
      ...props
    };
    const b2 = cn("tabbar");
    const [selectIndex, setSelectIndex] = React.useState(activeVisible || visible);
    const handleClick = (idx) => {
      if (!("activeVisible" in props)) {
        setSelectIndex(idx);
      }
    };
    React.useEffect(() => {
      if (activeVisible !== void 0) {
        setSelectIndex(activeVisible);
      }
    }, [activeVisible]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: [
          `${b2()}`,
          bottom ? `${b2("bottom")}` : "",
          safeAreaInsetBottom ? `${b2("bottom")} ${b2("safebottom")}` : "",
          className
        ].join(" "),
        style
      },
      React.Children.map(children, (child, idx) => {
        if (!React.isValidElement(child)) {
          return null;
        }
        const childProps = {
          ...child.props,
          active: idx === selectIndex,
          index: idx,
          unactiveColor,
          activeColor,
          size,
          handleClick: () => {
            handleClick(idx);
            onSwitch(child, idx);
          }
        };
        return React.cloneElement(child, childProps);
      })
    );
  };
  Tabbar.defaultProps = defaultProps$18;
  Tabbar.displayName = "NutTabbar";
  const defaultProps$17 = {
    ...ComponentDefaults,
    dot: false,
    size: "",
    iconSize: "",
    className: "",
    tabTitle: "",
    icon: "",
    href: "",
    to: "",
    num: "",
    active: false,
    activeColor: "",
    unactiveColor: "",
    index: 0,
    handleClick: (idx) => {
    }
  };
  const TabbarItem = (props) => {
    const {
      dot,
      size,
      iconSize,
      className,
      style,
      tabTitle,
      icon,
      href,
      to: to2,
      num,
      active,
      activeColor,
      unactiveColor,
      index,
      handleClick,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$17,
      ...props
    };
    const b2 = cn("tabbar-item");
    const bIcon = cn("tabbar-item__icon-box");
    React.useEffect(() => {
      if (active && href) {
        window.location.href = href;
        return;
      }
      if (active && to2) {
        Taro.navigateTo({
          url: to2
        });
      }
    }, [active, href, to2]);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${b2({ active })} ${className}`,
        style: {
          ...style,
          color: active ? activeColor : unactiveColor
        },
        onClick: () => {
          handleClick(index);
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${bIcon()}` }, !dot ? /* @__PURE__ */ React.createElement(React.Fragment, null, num && num <= 99 && /* @__PURE__ */ React.createElement("div", { className: `${bIcon("tips", [bIcon("num")])}` }, num), num && num >= 100 && /* @__PURE__ */ React.createElement("div", { className: `${bIcon("tips", [bIcon("nums")])}` }, "99+")) : /* @__PURE__ */ React.createElement("div", { className: `${bIcon("tips", [bIcon("dot")])}` }), icon && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          size: iconSize || size,
          name: icon
        }
      )),
      tabTitle && /* @__PURE__ */ React.createElement(
        "div",
        {
          className: bIcon({ "nav-word": true }, [
            bIcon({ "big-word": !icon })
          ])
        },
        tabTitle
      )
    );
  };
  const defaultProps$16 = {
    title: "",
    paneKey: "",
    activeKey: "",
    disabled: false
  };
  const TabPane = (props) => {
    const {
      children,
      paneKey,
      activeKey,
      autoHeightClassName,
      className,
      disabled
    } = {
      ...defaultProps$16,
      ...props
    };
    const b2 = cn("tabpane");
    const classes = classNames(
      {
        active: !disabled && paneKey === activeKey
      },
      b2(""),
      autoHeightClassName,
      className
    );
    return /* @__PURE__ */ React.createElement("div", { className: classes }, !disabled && children);
  };
  class Title {
    // eslint-disable-next-line no-useless-constructor
    constructor() {
      __publicField(this, "title", "");
      __publicField(this, "paneKey", "");
      __publicField(this, "disabled", false);
      __publicField(this, "index", 0);
    }
  }
  const defaultProps$15 = {
    ...ComponentDefaults,
    tabStyle: {},
    value: 0,
    color: "",
    background: "",
    direction: "horizontal",
    type: "line",
    titleScroll: false,
    ellipsis: true,
    animatedTime: 300,
    titleGutter: 0,
    size: "normal",
    leftAlign: false,
    autoHeight: false
  };
  const pxCheck$2 = (value) => {
    return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
  };
  const Tabs = (props) => {
    const {
      value,
      color,
      tabStyle,
      background,
      direction,
      type,
      titleScroll,
      ellipsis,
      animatedTime,
      titleGutter,
      size,
      leftAlign,
      titleNode,
      children,
      onClick,
      onChange,
      className,
      autoHeight,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$15,
      ...props
    };
    const [currentItem, setCurrentItem] = React.useState({ index: 0 });
    const titles = React.useRef([]);
    React.useEffect(() => {
      let currentIndex = 0;
      titles.current = [];
      React.Children.forEach(children, (child, idx) => {
        if (!React.isValidElement(child)) {
          return null;
        }
        const title = new Title();
        const childProps = child == null ? void 0 : child.props;
        if ((childProps == null ? void 0 : childProps.title) || (childProps == null ? void 0 : childProps.paneKey)) {
          title.title = childProps == null ? void 0 : childProps.title;
          title.paneKey = getPaneKey(childProps == null ? void 0 : childProps.paneKey, idx);
          title.disabled = childProps == null ? void 0 : childProps.disabled;
          title.index = idx;
          if (title.paneKey === value) {
            currentIndex = idx;
          }
        }
        titles.current.push(title);
      });
      setCurrentItem(titles.current[currentIndex]);
    }, [children]);
    const b2 = cn("tabs");
    const classes = classNames(direction, b2(""), className);
    const classesTitle = classNames(
      {
        [type]: type,
        scrollable: titleScroll,
        [size]: size
      },
      `${b2("")}__titles`
    );
    const titleStyle = {
      marginLeft: pxCheck$2(titleGutter),
      marginRight: pxCheck$2(titleGutter)
    };
    const tabsActiveStyle = {
      color: type === "smile" ? color : "",
      background: type === "line" ? color : ""
    };
    const index = titles.current.findIndex((t) => t.paneKey === value);
    const contentStyle = {
      transform: direction === "horizontal" ? `translate3d(-${index * 100}%, 0, 0)` : `translate3d( 0,-${index * 100}%, 0)`,
      transitionDuration: `${animatedTime}ms`
    };
    const getPaneKey = (paneKey, index2) => {
      return typeof paneKey === "string" ? paneKey : String(paneKey || index2);
    };
    const tabChange = (item, index2) => {
      onClick && onClick(item);
      if (item.disabled) {
        return;
      }
      setCurrentItem(item);
      onChange && onChange(item);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...rest }, /* @__PURE__ */ React.createElement("div", { className: classesTitle, style: { ...tabStyle, background } }, !!titleNode && typeof titleNode === "function" ? titleNode() : titles.current.map((item, index2) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          style: titleStyle,
          onClick: (e) => tabChange(item),
          className: classNames(
            {
              active: !item.disabled && String(item.paneKey) === String(value),
              disabled: item.disabled,
              "nut-tabs__titles-item-left-align": leftAlign
            },
            `${b2("")}__titles-item`
          ),
          key: item.paneKey
        },
        type === "line" && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2("")}__titles-item__line`,
            style: tabsActiveStyle
          }
        ),
        type === "smile" && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2("")}__titles-item__smile`,
            style: tabsActiveStyle
          },
          /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              color,
              name: "joy-smile"
            }
          )
        ),
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames(
              {
                ellipsis: ellipsis && !titleScroll && direction === "horizontal"
              },
              `${b2("")}__titles-item__text`
            )
          },
          item.title
        )
      );
    })), /* @__PURE__ */ React.createElement("div", { className: `${b2("")}__content__wrap` }, /* @__PURE__ */ React.createElement("div", { className: `${b2("")}__content`, style: contentStyle }, React.Children.map(children, (child, idx) => {
      var _a;
      if (!React.isValidElement(child)) {
        return null;
      }
      let childProps = {
        ...child.props,
        activeKey: value
      };
      if (String(value) !== getPaneKey((_a = child.props) == null ? void 0 : _a.paneKey, idx) && autoHeight) {
        childProps = {
          ...childProps,
          autoHeightClassName: "inactive"
        };
      }
      return React.cloneElement(child, childProps);
    }))));
  };
  Tabs.defaultProps = defaultProps$15;
  Tabs.displayName = "NutTabs";
  Tabs.TabPane = TabPane;
  const Utils = {
    /**
     * 是否为闫年
     * @return {Boolse} true|false
     */
    isLeapYear(y) {
      return y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
    },
    /**
     * 返回星期数
     * @return {String}
     */
    getWhatDay(year, month, day) {
      const date = /* @__PURE__ */ new Date(`${year}/${month}/${day}`);
      const index = date.getDay();
      const dayNames = [
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六"
      ];
      return dayNames[index];
    },
    /**
     * 返回星期数
     * @return {Number}
     */
    getMonthPreDay(year, month) {
      const date = /* @__PURE__ */ new Date(`${year}/${month}/01`);
      let day = date.getDay();
      if (day == 0) {
        day = 7;
      }
      return day;
    },
    /**
     * 返回月份天数
     * @return {Number}
     */
    getMonthDays(year, month) {
      if (/^0/.test(month)) {
        month = month.split("")[1];
      }
      return [
        0,
        31,
        this.isLeapYear(Number(year)) ? 29 : 28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
      ][month];
    },
    /**
     * 补齐数字位数
     * @return {string}
     */
    getNumTwoBit(n) {
      n = Number(n);
      return (n > 9 ? "" : "0") + n;
    },
    /**
     * 日期对象转成字符串
     * @return {string}
     */
    date2Str(date, split) {
      split = split || "-";
      const y = date.getFullYear();
      const m = this.getNumTwoBit(date.getMonth() + 1);
      const d = this.getNumTwoBit(date.getDate());
      return [y, m, d].join(split);
    },
    /**
     * 返回日期格式字符串
     * @param {Number} 0返回今天的日期、1返回明天的日期，2返回后天得日期，依次类推
     * @return {string} '2014-12-31'
     */
    getDay(i) {
      i = i || 0;
      let date = /* @__PURE__ */ new Date();
      const diff = i * (1e3 * 60 * 60 * 24);
      date = new Date(date.getTime() + diff);
      return this.date2Str(date);
    },
    /**
     * 时间比较
     * @return {Boolean}
     */
    compareDate(date1, date2) {
      const startTime = new Date(date1.replace("-", "/").replace("-", "/"));
      const endTime = new Date(date2.replace("-", "/").replace("-", "/"));
      if (startTime >= endTime) {
        return false;
      }
      return true;
    },
    /**
     * 时间是否相等
     * @return {Boolean}
     */
    isEqual(date1, date2) {
      const startTime = new Date(date1).getTime();
      const endTime = new Date(date2).getTime();
      if (startTime == endTime) {
        return true;
      }
      return false;
    }
  };
  function requestAniFrame() {
    if (typeof window !== "undefined") {
      return window.requestAnimationFrame || function(callback) {
        window.setTimeout(callback, 1e3 / 60);
      };
    }
    return function(callback) {
      setTimeout(callback, 1e3 / 60);
    };
  }
  const requestAniFrame$1 = requestAniFrame();
  const defaultProps$14 = {
    type: "one",
    isAutoBackFill: false,
    poppable: true,
    visible: false,
    title: "日历选择",
    defaultValue: "",
    startDate: Utils.getDay(0),
    endDate: Utils.getDay(365),
    showToday: true,
    startText: "开始",
    endText: "结束",
    confirmText: "确认",
    showTitle: true,
    showSubTitle: true,
    toDateAnimation: true,
    onBtn: void 0,
    onDay: void 0,
    onTopInfo: void 0,
    onBottomInfo: void 0,
    onChoose: (data) => {
    },
    onUpdate: () => {
    },
    onSelected: (data) => {
    },
    onYearMonthChange: (data) => {
    }
  };
  const CalendarItem = React.forwardRef((props, ref) => {
    const { locale } = useConfig$1();
    const {
      type,
      isAutoBackFill,
      poppable,
      title,
      defaultValue,
      showToday,
      startText,
      endText,
      confirmText,
      showTitle,
      showSubTitle,
      toDateAnimation,
      onBtn,
      onDay,
      onTopInfo,
      onBottomInfo,
      onChoose,
      onUpdate,
      onSelected,
      onYearMonthChange
    } = { ...defaultProps$14, ...props };
    const weeks = locale.calendaritem.weekdays;
    const [yearMonthTitle, setYearMonthTitle] = React.useState("");
    const [monthsData, setMonthsData] = React.useState([]);
    const [translateY, setTranslateY] = React.useState(0);
    const [monthDefaultRange, setMonthDefaultRange] = React.useState([]);
    const [scrollTop, setScrollTop] = React.useState(0);
    const [scrollWithAnimation, setScrollWithAnimation] = React.useState(false);
    const [state] = React.useState({
      currDate: "",
      propStartDate: "",
      propEndDate: "",
      unLoadPrev: false,
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0,
        lastTime: 0
      },
      transformY: 0,
      scrollDistance: 0,
      defaultData: [],
      chooseData: [],
      monthsData: [],
      dayPrefix: "calendar-month-day",
      startData: "",
      endData: "",
      isRange: props.type === "range",
      timer: 0,
      currentIndex: 0,
      avgHeight: 0,
      monthsNum: 0
    });
    const weeksPanel = React.useRef(null);
    const months = React.useRef(null);
    const monthsPanel = React.useRef(null);
    const viewArea = React.useRef(null);
    let viewHeight = 0;
    const b2 = cn("calendar");
    const classes = classNames(
      {
        [`${b2("")}-tile`]: !poppable,
        [`${b2("")}-nofooter`]: !!isAutoBackFill
      },
      b2("")
    );
    const headerClasses = classNames({
      [`${b2("")}-header`]: true,
      [`${b2("")}-header-tile`]: !poppable
    });
    const monthitemclasses = classNames({
      "calendar-month-item": true,
      [`${type === "range" ? "month-item-range" : ""}`]: true
    });
    const splitDate = (date) => {
      return date.split("-");
    };
    const isStart = (currDate) => {
      return Utils.isEqual(state.currDate[0], currDate);
    };
    const isEnd = (currDate) => {
      return Utils.isEqual(state.currDate[1], currDate);
    };
    const isMultiple = (currDate) => {
      if (state.currDate.length > 0) {
        return state.currDate.some((item) => {
          return Utils.isEqual(item, currDate);
        });
      }
      return false;
    };
    const getCurrDate = (day, month) => {
      return `${month.curData[0]}-${month.curData[1]}-${Utils.getNumTwoBit(
        +day.day
      )}`;
    };
    const getClass = (day, month) => {
      const currDate = getCurrDate(day, month);
      if (day.type === "curr") {
        if (Utils.isEqual(state.currDate, currDate) || type === "range" && (isStart(currDate) || isEnd(currDate)) || type === "multiple" && isMultiple(currDate)) {
          return `${state.dayPrefix}-active`;
        }
        if (state.propStartDate && Utils.compareDate(currDate, state.propStartDate) || state.propEndDate && Utils.compareDate(state.propEndDate, currDate)) {
          return `${state.dayPrefix}-disabled`;
        }
        if (type === "range" && Array.isArray(state.currDate) && Object.values(state.currDate).length === 2 && Utils.compareDate(state.currDate[0], currDate) && Utils.compareDate(currDate, state.currDate[1])) {
          return `${state.dayPrefix}-choose`;
        }
        return null;
      }
      return `${state.dayPrefix}-disabled`;
    };
    const isActive = (day, month) => {
      return state.isRange && day.type === "curr" && getClass(day, month) === "calendar-month-day-active";
    };
    const isCurrDay = (month, day) => {
      const date = `${month.curData[0]}-${month.curData[1]}-${day}`;
      return Utils.isEqual(date, Utils.date2Str(/* @__PURE__ */ new Date()));
    };
    const confirm = () => {
      const { type: type2 } = props;
      if (type2 === "range" && state.chooseData.length === 2 || type2 !== "range") {
        const chooseData = state.chooseData.slice(0);
        onChoose && onChoose(chooseData);
        if (poppable) {
          onUpdate && onUpdate();
        }
      }
    };
    const chooseDay = (day, month, isFirst) => {
      if (getClass(day, month) !== `${state.dayPrefix}-disabled`) {
        const { type: type2 } = props;
        const days = [...month.curData];
        days[2] = typeof day.day === "number" ? Utils.getNumTwoBit(day.day) : day.day;
        days[3] = `${days[0]}-${days[1]}-${days[2]}`;
        days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
        if (type2 === "multiple") {
          if (state.currDate.length > 0) {
            let hasIndex = "";
            state.currDate.forEach((item, index) => {
              if (item === days[3]) {
                hasIndex = index;
              }
            });
            if (isFirst) {
              state.chooseData.push([...days]);
            } else if (hasIndex !== "") {
              state.currDate.splice(hasIndex, 1);
              state.chooseData.splice(hasIndex, 1);
            } else {
              state.currDate.push(days[3]);
              state.chooseData.push([...days]);
            }
          } else {
            state.currDate = [days[3]];
            state.chooseData = [[...days]];
          }
        } else if (type2 === "range") {
          const curDataLength = Object.values(state.currDate).length;
          if (curDataLength === 2 || curDataLength === 0) {
            state.currDate = [days[3]];
          } else if (Utils.compareDate(state.currDate[0], days[3])) {
            Array.isArray(state.currDate) && state.currDate.push(days[3]);
          } else {
            Array.isArray(state.currDate) && state.currDate.unshift(days[3]);
          }
          if (state.chooseData.length === 2 || !state.chooseData.length) {
            state.chooseData = [[...days]];
          } else if (Utils.compareDate(state.chooseData[0][3], days[3])) {
            state.chooseData = [...state.chooseData, [...days]];
          } else {
            state.chooseData = [[...days], ...state.chooseData];
          }
        } else {
          state.currDate = days[3];
          state.chooseData = [...days];
        }
        if (!isFirst) {
          onSelected && onSelected(state.chooseData);
          if (isAutoBackFill || !poppable) {
            confirm();
          }
        }
        setMonthsData(state.monthsData.slice());
      }
    };
    const isStartTip = (day, month) => {
      return isActive(day, month) && isStart(getCurrDate(day, month));
    };
    const isEndTip = (day, month) => {
      if (state.currDate.length >= 2 && isEnd(getCurrDate(day, month))) {
        return isActive(day, month);
      }
      return false;
    };
    const rangeTip = () => {
      if (state.currDate.length >= 2) {
        return Utils.isEqual(state.currDate[0], state.currDate[1]);
      }
      return false;
    };
    const getCurrData = (type2) => {
      const monthData = type2 === "prev" ? state.monthsData[0] : state.monthsData[state.monthsData.length - 1];
      let year = parseInt(monthData.curData[0]);
      let month = parseInt(monthData.curData[1].toString().replace(/^0/, ""));
      switch (type2) {
        case "prev":
          month === 1 && (year -= 1);
          month = month === 1 ? 12 : --month;
          break;
        case "next":
          month === 12 && (year += 1);
          month = month === 12 ? 1 : ++month;
          break;
      }
      return [
        year,
        Utils.getNumTwoBit(month),
        Utils.getMonthDays(String(year), String(month))
      ];
    };
    const getDaysStatus = (days, type2, dateInfo) => {
      const { year, month } = dateInfo;
      if (type2 === "prev" && days >= 7) {
        days -= 7;
      }
      return Array.from(Array(days), (v, k) => {
        return {
          day: k + 1,
          type: type2,
          year,
          month
        };
      });
    };
    const getPreDaysStatus = (days, type2, dateInfo, preCurrMonthDays) => {
      const { year, month } = dateInfo;
      if (type2 === "prev" && days >= 7) {
        days -= 7;
      }
      const months2 = Array.from(Array(preCurrMonthDays), (v, k) => {
        return {
          day: k + 1,
          type: type2,
          year,
          month
        };
      });
      return months2.slice(preCurrMonthDays - days);
    };
    const getMonth = (curData, type2) => {
      const preMonthDays = Utils.getMonthPreDay(+curData[0], +curData[1]);
      let preMonth = +curData[1] - 1;
      let preYear = curData[0];
      if (preMonth <= 0) {
        preMonth = 12;
        preYear += 1;
      }
      const currMonthDays = Utils.getMonthDays(curData[0], curData[1]);
      const preCurrMonthDays = Utils.getMonthDays(`${preYear}`, `${preMonth}`);
      const title2 = {
        year: curData[0],
        month: curData[1]
      };
      const monthInfo = {
        curData,
        title: locale.calendaritem.monthTitle(title2.year, title2.month),
        monthData: [
          ...getPreDaysStatus(
            preMonthDays,
            "prev",
            { month: preMonth, year: preYear },
            preCurrMonthDays
          ),
          ...getDaysStatus(currMonthDays, "curr", title2)
        ]
      };
      monthInfo.cssHeight = 39 + (monthInfo.monthData.length > 35 ? 384 : 320);
      let cssScrollHeight = 0;
      if (state.monthsData.length > 0) {
        cssScrollHeight = state.monthsData[state.monthsData.length - 1].cssScrollHeight + state.monthsData[state.monthsData.length - 1].cssHeight;
      }
      monthInfo.cssScrollHeight = cssScrollHeight;
      if (type2 === "next") {
        if (!state.endData || !Utils.compareDate(
          `${state.endData[0]}-${state.endData[1]}-${Utils.getMonthDays(
            state.endData[0],
            state.endData[1]
          )}`,
          `${curData[0]}-${curData[1]}-${curData[2]}`
        )) {
          state.monthsData.push(monthInfo);
        }
      } else if (!state.startData || !Utils.compareDate(
        `${curData[0]}-${curData[1]}-${curData[2]}`,
        `${state.startData[0]}-${state.startData[1]}-01`
      )) {
        state.monthsData.unshift(monthInfo);
      }
      setMonthsData(state.monthsData);
    };
    const setReachedYearMonthInfo = () => {
      const currentMonthsData = state.monthsData[state.currentIndex];
      const [year, month] = currentMonthsData.curData;
      if (currentMonthsData.title === yearMonthTitle)
        return;
      onYearMonthChange && onYearMonthChange([year, month, `${year}-${month}`]);
      setYearMonthTitle(currentMonthsData.title);
    };
    const setDefaultRange = (monthsNum, current) => {
      let start2 = 0;
      let end = 0;
      if (monthsNum >= 3) {
        if (current > 0 && current < monthsNum) {
          start2 = current - 1;
          end = current + 3;
        } else if (current === 0) {
          start2 = current;
          end = current + 4;
        } else if (current === monthsNum) {
          start2 = current - 2;
          end = current + 2;
        }
      } else {
        start2 = 0;
        end = monthsNum + 2;
      }
      setMonthDefaultRange([start2, end]);
      setTranslateY(state.monthsData[start2].cssScrollHeight);
    };
    const monthsViewScroll = (e) => {
      if (state.monthsData.length <= 1) {
        return;
      }
      const target = e.target;
      const currentScrollTop = target.scrollTop;
      Taro.getEnv() === "WEB" && setScrollTop(currentScrollTop);
      let current = Math.floor(currentScrollTop / state.avgHeight);
      if (current === 0) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
      } else if (current > 0 && current < state.monthsNum - 1) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
        if (currentScrollTop < state.monthsData[current].cssScrollHeight) {
          current -= 1;
        }
      } else {
        const viewPosition = Math.round(currentScrollTop + viewHeight);
        if (current + 1 <= state.monthsNum && viewPosition >= state.monthsData[current + 1].cssScrollHeight + state.monthsData[current + 1].cssHeight) {
          current += 1;
        }
        if (current >= 1 && currentScrollTop < state.monthsData[current - 1].cssScrollHeight) {
          current -= 1;
        }
      }
      if (state.currentIndex !== current) {
        state.currentIndex = current;
        setDefaultRange(state.monthsNum, current);
      }
      setReachedYearMonthInfo();
    };
    const initData = () => {
      const propStartDate = props.startDate ? props.startDate : Utils.getDay(0);
      const propEndDate = props.endDate ? props.endDate : Utils.getDay(365);
      state.propStartDate = propStartDate;
      state.propEndDate = propEndDate;
      state.startData = splitDate(propStartDate);
      state.endData = splitDate(propEndDate);
      if (defaultValue || Array.isArray(defaultValue) && defaultValue.length > 0) {
        state.currDate = props.type !== "one" ? [...props.defaultValue] : props.defaultValue;
      }
      const startDate = {
        year: Number(state.startData[0]),
        month: Number(state.startData[1])
      };
      const endDate = {
        year: Number(state.endData[0]),
        month: Number(state.endData[1])
      };
      let monthsNum = endDate.month - startDate.month;
      if (endDate.year - startDate.year > 0) {
        monthsNum += 12 * (endDate.year - startDate.year);
      }
      if (monthsNum <= 0) {
        monthsNum = 1;
      }
      getMonth(state.startData, "next");
      let i = 1;
      do {
        getMonth(getCurrData("next"), "next");
      } while (i++ < monthsNum);
      state.monthsNum = monthsNum;
      if (type === "range" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          if (propStartDate && Utils.compareDate(state.currDate[0], propStartDate)) {
            state.currDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, state.currDate[1])) {
            state.currDate.splice(1, 1, propEndDate);
          }
          state.defaultData = [
            ...splitDate(state.currDate[0]),
            ...splitDate(state.currDate[1])
          ];
        }
      } else if (props.type === "multiple" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          const defaultArr = [];
          const obj = {};
          state.currDate.forEach((item) => {
            if (propStartDate && !Utils.compareDate(item, propStartDate) && propEndDate && !Utils.compareDate(propEndDate, item)) {
              if (!Object.hasOwnProperty.call(obj, item)) {
                defaultArr.push(item);
                obj[item] = item;
              }
            }
          });
          state.currDate = [...defaultArr];
          state.defaultData = [...splitDate(defaultArr[0])];
        }
      } else if (state.currDate) {
        if (propStartDate && Utils.compareDate(state.currDate, propStartDate)) {
          state.currDate = propStartDate;
        } else if (propEndDate && !Utils.compareDate(state.currDate, propEndDate)) {
          state.currDate = propEndDate;
        }
        state.defaultData = [...splitDate(state.currDate)];
      }
      let current = 0;
      let lastCurrent = 0;
      if (state.defaultData.length > 0) {
        state.monthsData.forEach((item, index) => {
          if (item.title === locale.calendaritem.monthTitle(
            state.defaultData[0],
            state.defaultData[1]
          )) {
            current = index;
          }
          if (props.type === "range") {
            if (item.title === locale.calendaritem.monthTitle(
              state.defaultData[3],
              state.defaultData[4]
            )) {
              lastCurrent = index;
            }
          }
        });
      } else {
        const currentYear2 = (/* @__PURE__ */ new Date()).getFullYear();
        const currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
        const currentYearMonthIndex = state.monthsData.findIndex((item) => {
          return +item.curData[0] === currentYear2 && +item.curData[1] === currentMonth;
        });
        if (currentYearMonthIndex > -1) {
          current = currentYearMonthIndex;
        }
      }
      setDefaultRange(monthsNum, current);
      state.currentIndex = current;
      setReachedYearMonthInfo();
      if (state.defaultData.length > 0) {
        if (type === "range") {
          chooseDay(
            { day: state.defaultData[2], type: "curr" },
            state.monthsData[state.currentIndex],
            true
          );
          chooseDay(
            { day: state.defaultData[5], type: "curr" },
            state.monthsData[lastCurrent],
            true
          );
        } else if (type === "multiple") {
          [...state.currDate].forEach((item) => {
            const dateArr = splitDate(item);
            let current2 = state.currentIndex;
            state.monthsData.forEach((item2, index) => {
              if (item2.title === locale.calendaritem.monthTitle(dateArr[0], dateArr[1])) {
                current2 = index;
              }
            });
            chooseDay(
              { day: dateArr[2], type: "curr" },
              state.monthsData[current2],
              true
            );
          });
        } else {
          chooseDay(
            { day: state.defaultData[2], type: "curr" },
            state.monthsData[state.currentIndex],
            true
          );
        }
      }
      const lastItem = state.monthsData[state.monthsData.length - 1];
      const containerHeight = lastItem.cssHeight + lastItem.cssScrollHeight;
      requestAniFrame$1(() => {
        if (months && monthsPanel && viewArea) {
          viewHeight = months.current.clientHeight;
          monthsPanel.current.style.height = `${containerHeight}px`;
          setScrollTop(state.monthsData[state.currentIndex].cssScrollHeight);
          Taro.nextTick(() => setScrollWithAnimation(true));
        }
      });
      state.avgHeight = Math.floor(containerHeight / (monthsNum + 1));
    };
    const resetRender = () => {
      state.chooseData.splice(0);
      state.monthsData.splice(0);
      initData();
    };
    const scrollToDate = (date) => {
      if (Utils.compareDate(date, state.propStartDate)) {
        date = state.propStartDate;
      } else if (!Utils.compareDate(date, state.propEndDate)) {
        date = state.propEndDate;
      }
      const dateArr = splitDate(date);
      state.monthsData.forEach((item, index) => {
        if (item.title === locale.calendaritem.monthTitle(dateArr[0], dateArr[1])) {
          if (months.current) {
            const distance = state.monthsData[index].cssScrollHeight - months.current.scrollTop;
            if (toDateAnimation) {
              let flag = 0;
              const interval = setInterval(() => {
                flag++;
                if (months.current) {
                  const offset = distance / 10;
                  months.current.scrollTop += offset;
                }
                if (flag >= 10) {
                  clearInterval(interval);
                  if (months.current) {
                    months.current.scrollTop = state.monthsData[index].cssScrollHeight;
                    setScrollTop(months.current.scrollTop);
                  }
                }
              }, 40);
            } else {
              months.current.scrollTop = state.monthsData[index].cssScrollHeight;
              setScrollTop(months.current.scrollTop);
            }
          }
        }
      });
    };
    React.useEffect(() => {
      initData();
    }, []);
    React.useEffect(() => {
      poppable && resetRender();
    }, [defaultValue]);
    React.useImperativeHandle(ref, () => ({
      scrollToDate
    }));
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: classes }, /* @__PURE__ */ React.createElement("div", { className: headerClasses }, showTitle && /* @__PURE__ */ React.createElement("div", { className: "calendar-title" }, title || locale.calendaritem.title), onBtn && /* @__PURE__ */ React.createElement("div", { className: "calendar-top-slot" }, onBtn()), showSubTitle && /* @__PURE__ */ React.createElement("div", { className: "calendar-curr-month" }, yearMonthTitle), /* @__PURE__ */ React.createElement("div", { className: "calendar-weeks", ref: weeksPanel }, weeks.map((item) => /* @__PURE__ */ React.createElement("div", { className: "calendar-week-item", key: item }, item)))), /* @__PURE__ */ React.createElement(
      components.ScrollView,
      {
        scrollTop,
        scrollY: true,
        scrollWithAnimation,
        className: "nut-calendar-content",
        onScroll: monthsViewScroll,
        ref: months
      },
      /* @__PURE__ */ React.createElement("div", { className: "calendar-months-panel", ref: monthsPanel }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "viewArea",
          ref: viewArea,
          style: { transform: `translateY(${translateY}px)` }
        },
        state.monthsData.slice(monthDefaultRange[0], monthDefaultRange[1]).map((month, key) => {
          return /* @__PURE__ */ React.createElement("div", { className: "calendar-month", key }, /* @__PURE__ */ React.createElement("div", { className: "calendar-month-title" }, month.title), /* @__PURE__ */ React.createElement("div", { className: "calendar-month-con" }, /* @__PURE__ */ React.createElement("div", { className: monthitemclasses }, month.monthData.map((day, i) => /* @__PURE__ */ React.createElement(
            "div",
            {
              className: [
                "calendar-month-day",
                getClass(day, month)
              ].join(" "),
              onClick: () => {
                chooseDay(day, month);
              },
              key: i
            },
            /* @__PURE__ */ React.createElement("div", { className: "calendar-day" }, onDay ? onDay(day) : day.day),
            onTopInfo && /* @__PURE__ */ React.createElement("div", { className: "calendar-curr-tips calendar-curr-tips-top" }, onTopInfo(day)),
            onBottomInfo && /* @__PURE__ */ React.createElement("div", { className: "calendar-curr-tips calendar-curr-tips-bottom" }, onBottomInfo(day)),
            !onBottomInfo && showToday && isCurrDay(month, day.day) && /* @__PURE__ */ React.createElement("div", { className: "calendar-curr-tip-curr" }, locale.calendaritem.today),
            isStartTip(day, month) && /* @__PURE__ */ React.createElement(
              "div",
              {
                className: `calendar-day-tip ${rangeTip() ? "calendar-curr-tips-top" : ""}`
              },
              startText || locale.calendaritem.start
            ),
            isEndTip(day, month) && /* @__PURE__ */ React.createElement("div", { className: "calendar-day-tip" }, endText || locale.calendaritem.end)
          )))));
        })
      ))
    ), poppable && !isAutoBackFill ? /* @__PURE__ */ React.createElement("div", { className: "nut-calendar-footer" }, /* @__PURE__ */ React.createElement("div", { className: "calendar-confirm-btn", onClick: confirm }, confirmText || locale.confirm)) : ""));
  });
  CalendarItem.defaultProps = defaultProps$14;
  CalendarItem.displayName = "NutCalendarItem";
  const defaultProps$13 = {
    type: "one",
    isAutoBackFill: false,
    poppable: true,
    visible: false,
    title: "",
    defaultValue: "",
    startDate: Utils.getDay(0),
    endDate: Utils.getDay(365),
    showToday: true,
    startText: "",
    endText: "",
    confirmText: "",
    showTitle: true,
    showSubTitle: true,
    toDateAnimation: true,
    onBtn: void 0,
    onDay: void 0,
    onTopInfo: void 0,
    onBottomInfo: void 0,
    onClose: () => {
    },
    onChoose: (param) => {
    },
    onSelected: (data) => {
    },
    onYearMonthChange: (param) => {
    }
  };
  const Calendar = React.forwardRef((props, ref) => {
    const { locale } = useConfig$1();
    const {
      children,
      poppable,
      visible,
      type,
      isAutoBackFill,
      title,
      defaultValue,
      startDate,
      endDate,
      showToday,
      startText,
      endText,
      confirmText,
      showTitle,
      showSubTitle,
      toDateAnimation,
      onBtn,
      onDay,
      onTopInfo,
      onBottomInfo,
      onClose,
      onChoose,
      onSelected,
      onYearMonthChange
    } = { ...defaultProps$13, ...props };
    const calendarRef = React.useRef(null);
    const close = () => {
      onClose && onClose();
    };
    const choose = (param) => {
      close();
      onChoose && onChoose(param);
    };
    const closePopup = () => {
      close();
    };
    const select = (param) => {
      onSelected && onSelected(param);
    };
    const scrollToDate = (date) => {
      var _a;
      (_a = calendarRef.current) == null ? void 0 : _a.scrollToDate(date);
    };
    const yearMonthChange = (param) => {
      onYearMonthChange && onYearMonthChange(param);
    };
    React.useImperativeHandle(ref, () => ({
      scrollToDate
    }));
    const renderItem = () => {
      return /* @__PURE__ */ React.createElement(
        CalendarItem,
        {
          ref: calendarRef,
          type,
          isAutoBackFill,
          poppable,
          title: title || locale.calendaritem.title,
          defaultValue,
          startDate,
          endDate,
          showToday,
          startText: startText || locale.calendaritem.start,
          endText: endText || locale.calendaritem.end,
          confirmText: confirmText || locale.calendaritem.confirm,
          showTitle,
          showSubTitle,
          toDateAnimation,
          onBtn,
          onDay,
          onTopInfo,
          onBottomInfo,
          onChoose: choose,
          onSelected: select,
          onYearMonthChange: yearMonthChange
        }
      );
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, poppable ? /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible,
        position: "bottom",
        round: true,
        duration: 0.5,
        closeable: true,
        destroyOnClose: true,
        onClickOverlay: closePopup,
        onClickCloseIcon: closePopup,
        style: { height: "85vh" }
      },
      renderItem()
    ) : renderItem());
  });
  Calendar.defaultProps = defaultProps$13;
  Calendar.displayName = "NutCalendar";
  const defaultProps$12 = {
    data: {
      text: "",
      value: "",
      paneKey: "",
      disabled: false,
      loading: false,
      children: []
    },
    activeColor: "#fa2c19",
    checked: false,
    checkedIcon: "checklist",
    chooseItem: () => {
    }
  };
  const InternalCascaderItem = (props, ref) => {
    const { data, checked, checkedIcon, chooseItem, activeColor } = {
      ...defaultProps$12,
      ...props
    };
    const b2 = cn("cascader-item");
    const classes = classNames(
      {
        active: checked,
        disabled: data.disabled
      },
      b2("")
    );
    const classesTitle = classNames({
      [`${b2("")}__title`]: true
    });
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        style: { color: checked ? activeColor : "" },
        className: classes,
        onClick: () => {
          chooseItem(data);
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: classesTitle }, data.text),
      data.loading ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          color: "#969799",
          className: "nut-cascader-item__icon-loading",
          name: "loading"
        }
      ) : /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          className: `${checked ? b2("icon-check") : ""}`,
          name: checked ? checkedIcon : ""
        }
      )
    );
  };
  const CascaderItem = React.forwardRef(InternalCascaderItem);
  CascaderItem.defaultProps = defaultProps$12;
  CascaderItem.displayName = "NutCascaderItem";
  const formatTree = (tree, parent, config2) => tree.map((node) => {
    const {
      value: valueKey = "value",
      text: textKey = "text",
      children: childrenKey = "children"
    } = config2;
    const {
      [valueKey]: value,
      [textKey]: text,
      [childrenKey]: children,
      ...others
    } = node;
    const newNode = {
      loading: false,
      ...others,
      level: parent ? (parent && parent.level || 0) + 1 : 0,
      value,
      text,
      children,
      _parent: parent
    };
    if (newNode.children && newNode.children.length) {
      newNode.children = formatTree(newNode.children, newNode, config2);
    }
    return newNode;
  });
  const eachTree = (tree, cb) => {
    let i = 0;
    let node;
    while (node = tree[i++]) {
      if (cb(node) === true) {
        break;
      }
      if (node.children && node.children.length) {
        eachTree(node.children, cb);
      }
    }
  };
  const defaultConvertConfig = {
    topId: null,
    idKey: "id",
    pidKey: "pid",
    sortKey: ""
  };
  const convertListToOptions = (list, options) => {
    const mergedOptions = {
      ...defaultConvertConfig,
      ...options || {}
    };
    const { topId, idKey, pidKey, sortKey } = mergedOptions;
    let result = [];
    let map = {};
    list.forEach((node) => {
      node = { ...node };
      const { [idKey]: id, [pidKey]: pid } = node;
      const children = map[pid] = map[pid] || [];
      if (!result.length && pid === topId) {
        result = children;
      }
      children.push(node);
      node.children = map[id] || (map[id] = []);
    });
    if (sortKey) {
      Object.keys(map).forEach((i) => {
        if (map[i].length > 1) {
          map[i].sort((a, b2) => a[sortKey] - b2[sortKey]);
        }
      });
    }
    map = null;
    return result;
  };
  class Tree {
    constructor(nodes, config2) {
      __publicField(this, "nodes");
      __publicField(this, "config");
      __publicField(this, "isLeaf", (node, lazy) => {
        const { leaf, children } = node;
        const hasChildren = Array.isArray(children) && Boolean(children.length);
        return leaf || !hasChildren && !lazy;
      });
      __publicField(this, "hasChildren", (node, lazy) => {
        const isLeaf = this.isLeaf(node, lazy);
        if (isLeaf) {
          return false;
        }
        const { children } = node;
        return Array.isArray(children) && Boolean(children.length);
      });
      this.config = {
        value: "value",
        text: "text",
        children: "children",
        ...config2 || {}
      };
      this.nodes = formatTree(nodes, null, this.config);
    }
    updateChildren(nodes, parent) {
      if (!parent) {
        this.nodes = formatTree(nodes, null, this.config);
      } else {
        parent.children = formatTree(nodes, parent, this.config);
      }
    }
    // for test
    getNodeByValue(value) {
      let foundNode;
      eachTree(this.nodes, (node) => {
        if (node.value === value) {
          foundNode = node;
          return true;
        }
        return null;
      });
      return foundNode;
    }
    getPathNodesByValue(value) {
      if (!value.length) {
        return [];
      }
      const pathNodes = [];
      let currentNodes = this.nodes;
      while (currentNodes && currentNodes.length) {
        const foundNode = currentNodes.find(
          (node) => node.value === value[node.level]
        );
        if (!foundNode) {
          break;
        }
        pathNodes.push(foundNode);
        currentNodes = foundNode.children;
      }
      return pathNodes;
    }
  }
  const Tree$1 = Tree;
  const defaultProps$11 = {
    className: "",
    style: {},
    activeColor: "#fa2c19",
    checkedIcon: "checklist",
    tabsColor: "",
    poppable: true,
    visible: false,
    options: [],
    value: [],
    title: "",
    textKey: "text",
    valueKey: "value",
    childrenKey: "children",
    convertConfig: {},
    closeable: false,
    closeIconPosition: "top-right",
    closeIcon: "close",
    lazy: false,
    lazyLoad: () => {
    },
    onClose: () => {
    },
    onChange: () => {
    },
    onPathChange: () => {
    },
    ...Popup.defaultProps
  };
  const InternalCascader = (props, ref) => {
    const {
      className,
      style,
      tabsColor,
      poppable,
      visible,
      options,
      value,
      title,
      textKey,
      valueKey,
      childrenKey,
      convertConfig: convertConfig2,
      closeable,
      closeIconPosition,
      closeIcon,
      lazy,
      lazyLoad,
      onClose,
      onChange,
      onPathChange
    } = { ...defaultProps$11, ...props };
    const [tabvalue, setTabvalue] = React.useState("c1");
    const [optionsData, setOptionsData] = React.useState([]);
    const isLazy = () => state.configs.lazy && Boolean(state.configs.lazyLoad);
    const [state] = React.useState({
      optionsData: [],
      panes: [
        {
          nodes: [],
          selectedNode: [],
          paneKey: ""
        }
      ],
      innerValue: value,
      tree: new Tree$1([], {}),
      tabsCursor: 0,
      // 选中的tab项
      initLoading: false,
      currentProcessNode: [],
      configs: {
        lazy,
        lazyLoad,
        valueKey,
        textKey,
        childrenKey,
        convertConfig: convertConfig2
      },
      lazyLoadMap: /* @__PURE__ */ new Map()
    });
    const b2 = cn("cascader");
    const classes = classNames(b2(""));
    const classesPane = classNames({
      [`${b2("")}-pane`]: true
    });
    React.useEffect(() => {
      initData();
    }, []);
    React.useEffect(() => {
      if (value !== state.innerValue) {
        state.innerValue = value;
      }
    }, [value]);
    React.useEffect(() => {
      initData();
    }, [options]);
    const initData = async () => {
      state.lazyLoadMap.clear();
      if (convertConfig2 && Object.keys(convertConfig2).length > 0) {
        state.optionsData = convertListToOptions(
          options,
          convertConfig2
        );
      } else {
        state.optionsData = options;
      }
      state.tree = new Tree$1(state.optionsData, {
        value: state.configs.valueKey,
        text: state.configs.textKey,
        children: state.configs.childrenKey
      });
      if (isLazy() && !state.tree.nodes.length) {
        await invokeLazyLoad({
          root: true,
          loading: true,
          text: "",
          value: ""
        });
      }
      state.panes = [
        {
          nodes: state.tree.nodes,
          selectedNode: null,
          paneKey: "c1"
        }
      ];
      syncValue();
      setOptionsData(state.panes);
    };
    const syncValue = async () => {
      const currentValue2 = state.innerValue;
      if (currentValue2 === void 0 || !state.tree.nodes.length) {
        return;
      }
      if (currentValue2.length === 0) {
        state.tabsCursor = 0;
        return;
      }
      let needToSync = currentValue2;
      if (isLazy() && Array.isArray(currentValue2) && currentValue2.length) {
        needToSync = [];
        const parent = state.tree.nodes.find(
          (node) => node.value === currentValue2[0]
        );
        if (parent) {
          needToSync = [parent.value];
          state.initLoading = true;
          const last = await currentValue2.slice(1).reduce(async (p, value2) => {
            var _a;
            const parent2 = await p;
            await invokeLazyLoad(parent2);
            const node = (_a = parent2 == null ? void 0 : parent2.children) == null ? void 0 : _a.find(
              (item) => item.value === value2
            );
            if (node) {
              needToSync.push(value2);
            }
            return Promise.resolve(node);
          }, Promise.resolve(parent));
          await invokeLazyLoad(last);
          state.initLoading = false;
        }
      }
      if (needToSync.length && currentValue2 === value) {
        const pathNodes = state.tree.getPathNodesByValue(needToSync);
        pathNodes.forEach((node, index) => {
          state.tabsCursor = index;
          chooseItem(node, true);
        });
      }
    };
    const invokeLazyLoad = async (node) => {
      if (!node) {
        return;
      }
      if (!state.configs.lazyLoad) {
        node.leaf = true;
        return;
      }
      if (state.tree.isLeaf(node, isLazy()) || state.tree.hasChildren(node, isLazy())) {
        return;
      }
      node.loading = true;
      const parent = node.root ? null : node;
      let lazyLoadPromise = state.lazyLoadMap.get(node);
      if (!lazyLoadPromise) {
        lazyLoadPromise = new Promise((resolve) => {
          var _a, _b;
          (_b = (_a = state.configs).lazyLoad) == null ? void 0 : _b.call(_a, node, resolve);
        });
        state.lazyLoadMap.set(node, lazyLoadPromise);
      }
      const nodes = await lazyLoadPromise;
      if (Array.isArray(nodes) && nodes.length > 0) {
        state.tree.updateChildren(nodes, parent);
      } else {
        node.leaf = true;
      }
      node.loading = false;
      state.lazyLoadMap.delete(node);
    };
    const close = () => {
      onClose && onClose();
    };
    const closePopup = () => {
      close();
    };
    const chooseItem = async (node, type) => {
      if (!type && node.disabled || !state.panes[state.tabsCursor]) {
        return;
      }
      if (state.tree.isLeaf(node, isLazy())) {
        node.leaf = true;
        state.panes[state.tabsCursor].selectedNode = node;
        state.panes = state.panes.slice(0, node.level + 1);
        if (!type) {
          const pathNodes = state.panes.map((item) => item.selectedNode);
          const optionParams = pathNodes.map((item) => item.value);
          onChange(optionParams, pathNodes);
          onPathChange(optionParams, pathNodes);
        }
        setOptionsData(state.panes);
        close();
        return;
      }
      if (state.tree.hasChildren(node, isLazy())) {
        const level = node.level + 1;
        state.panes[state.tabsCursor].selectedNode = node;
        state.panes = state.panes.slice(0, level);
        state.tabsCursor = level;
        state.panes.push({
          nodes: node.children || [],
          selectedNode: null,
          paneKey: `c${state.tabsCursor + 1}`
        });
        setTabvalue(`c${state.tabsCursor + 1}`);
        setOptionsData(state.panes);
        if (!type) {
          const pathNodes = state.panes.map((item) => item.selectedNode);
          const optionParams = pathNodes.map((item) => item == null ? void 0 : item.value);
          onPathChange(optionParams, pathNodes);
        }
        return;
      }
      state.currentProcessNode = node;
      if (node.loading) {
        return;
      }
      await invokeLazyLoad(node);
      if (state.currentProcessNode === node) {
        state.panes[state.tabsCursor].selectedNode = node;
        chooseItem(node, type);
      }
      setOptionsData(state.panes);
    };
    const renderItem = () => {
      return /* @__PURE__ */ React.createElement("div", { className: `${classes} ${className}`, style }, poppable && /* @__PURE__ */ React.createElement("div", { className: b2("title") }, title), /* @__PURE__ */ React.createElement(
        Tabs,
        {
          value: tabvalue,
          titleNode: () => {
            return optionsData.map((pane, index) => {
              var _a, _b;
              return /* @__PURE__ */ React.createElement(
                "div",
                {
                  onClick: () => {
                    setTabvalue(pane.paneKey);
                    state.tabsCursor = index;
                  },
                  className: `nut-tabs__titles-item ${tabvalue === pane.paneKey ? "active" : ""}`,
                  key: pane.paneKey
                },
                /* @__PURE__ */ React.createElement("span", { className: "nut-tabs__titles-item__text" }, !state.initLoading && state.panes.length && ((_a = pane == null ? void 0 : pane.selectedNode) == null ? void 0 : _a.text), !state.initLoading && state.panes.length && !((_b = pane == null ? void 0 : pane.selectedNode) == null ? void 0 : _b.text) && "请选择", !(!state.initLoading && state.panes.length) && "Loading..."),
                /* @__PURE__ */ React.createElement(
                  "span",
                  {
                    className: "nut-tabs__titles-item__line",
                    style: { background: tabsColor }
                  }
                )
              );
            });
          }
        },
        !state.initLoading && state.panes.length ? optionsData.map((pane) => /* @__PURE__ */ React.createElement(TabPane, { key: pane.paneKey, paneKey: pane.paneKey }, /* @__PURE__ */ React.createElement("div", { className: classesPane }, pane.nodes && pane.nodes.map((node, index) => {
          var _a;
          return /* @__PURE__ */ React.createElement(
            CascaderItem,
            {
              key: index,
              ...props,
              data: node,
              checked: ((_a = pane.selectedNode) == null ? void 0 : _a.value) === node.value,
              chooseItem: (node2) => chooseItem(node2, false)
            }
          );
        })))) : /* @__PURE__ */ React.createElement(TabPane, null, /* @__PURE__ */ React.createElement("div", { className: classesPane }))
      ));
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, poppable ? /* @__PURE__ */ React.createElement(
      Popup,
      {
        popClass: "cascadar-popup",
        visible,
        position: "bottom",
        round: true,
        closeable,
        closeIconPosition,
        closeIcon,
        onClickOverlay: closePopup,
        onClickCloseIcon: closePopup
      },
      renderItem()
    ) : renderItem());
  };
  const Cascader = React.forwardRef(InternalCascader);
  Cascader.defaultProps = defaultProps$11;
  Cascader.displayName = "NutCascader";
  const CheckboxGroupContext = React.createContext(null);
  const Context = CheckboxGroupContext;
  const defaultProps$10 = {
    disabled: false,
    checkedValue: [],
    max: void 0,
    textPosition: "right",
    direction: "vertical",
    onChange: (value) => {
    },
    options: []
  };
  const CheckboxGroup = React.forwardRef(
    (props, ref) => {
      const { children } = { ...defaultProps$10, ...props };
      const b2 = cn("checkboxgroup");
      const {
        className,
        disabled,
        onChange,
        checkedValue,
        max,
        textPosition,
        direction,
        options,
        ...rest
      } = props;
      React.useImperativeHandle(ref, () => ({
        toggleAll(state) {
          if (state === false) {
            setInnerValue([]);
          } else {
            const childrenLabel = [];
            React.Children.map(children, (child) => {
              const childProps = child.props;
              childrenLabel.push(childProps.label || child.children);
            });
            setInnerValue(childrenLabel);
          }
        },
        toggleReverse() {
          const childrenLabel = [];
          React.Children.map(children, (child) => {
            const childProps = child.props;
            childrenLabel.push(childProps.label || child.children);
          });
          const reverse = childrenLabel.filter(
            (c) => (innerValue == null ? void 0 : innerValue.findIndex((v) => v === c)) === -1
          );
          setInnerValue(reverse);
        }
      }));
      const [innerValue, setInnerValue] = React.useState(checkedValue || []);
      React.useEffect(() => {
        setInnerValue(checkedValue || []);
      }, [checkedValue]);
      const renderOptions = React.useCallback(() => {
        return options == null ? void 0 : options.map(({ label, value, disabled: disabled2, onChange: onChange2, ...rest2 }) => {
          return /* @__PURE__ */ React.createElement(
            Checkbox,
            {
              key: value == null ? void 0 : value.toString(),
              children: label,
              label: value,
              ...rest2
            }
          );
        });
      }, [options, max]);
      return /* @__PURE__ */ React.createElement(
        Context.Provider,
        {
          value: {
            textPosition: textPosition || "left",
            disabled,
            max,
            checkedValue: innerValue || [],
            check: (value) => {
              const combined = [...innerValue, value];
              setInnerValue(combined);
              onChange && onChange(combined);
            },
            uncheck: (value) => {
              const reduced = innerValue.filter((item) => item !== value);
              setInnerValue(reduced);
              onChange && onChange(reduced);
            }
          }
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2()} nut-checkboxgroup--${props.direction} ${className || ""}`,
            ...rest
          },
          (options == null ? void 0 : options.length) ? renderOptions() : children
        )
      );
    }
  );
  CheckboxGroup.defaultProps = defaultProps$10;
  CheckboxGroup.displayName = "NutCheckboxGroup";
  const defaultProps$$ = {
    ...ComponentDefaults,
    checked: false,
    disabled: false,
    textPosition: "right",
    iconSize: 18,
    iconName: "check-normal",
    iconActiveName: "checked",
    iconClassPrefix: "nut-icon",
    iconFontClassName: "nutui-iconfont",
    iconIndeterminateName: "check-disabled",
    onChange: (state, label) => {
    }
  };
  const Checkbox = (props) => {
    const { children } = {
      ...defaultProps$$,
      ...props
    };
    const b2 = cn("checkbox");
    const {
      iconName,
      iconSize,
      label,
      className,
      iconActiveName,
      checked,
      disabled,
      onChange,
      indeterminate,
      iconClassPrefix,
      iconFontClassName,
      iconIndeterminateName,
      ...others
    } = props;
    let { textPosition, ...rest } = others;
    const ctx2 = React.useContext(Context);
    let [innerChecked, setInnerChecked] = React.useState(checked);
    let [innerDisabled, setDisabled] = React.useState(disabled);
    const [_indeterminate, setIndeterminate] = React.useState(indeterminate);
    React.useEffect(() => {
      !ctx2 && setInnerChecked(checked);
      setDisabled(disabled);
      setIndeterminate(indeterminate);
    }, [disabled, checked, indeterminate]);
    if (ctx2) {
      if (ctx2.textPosition !== void 0) {
        textPosition = ctx2.textPosition;
      }
      innerDisabled = ctx2.disabled;
      innerChecked = ctx2.checkedValue.includes(label);
      setInnerChecked = (checked2) => {
        if (ctx2.disabled)
          return;
        if (checked2)
          ctx2.check(label);
        if (!checked2)
          ctx2.uncheck(label);
      };
    }
    const getIconName = () => {
      if (!innerChecked) {
        return iconName;
      }
      if (_indeterminate) {
        return iconIndeterminateName;
      }
      return iconActiveName;
    };
    const renderIcon = () => {
      return /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: getIconName(),
          size: iconSize,
          className: color()
        }
      );
    };
    const color = () => {
      if (innerDisabled) {
        return "nut-checkbox__icon--disable";
      }
      if (innerChecked) {
        if (_indeterminate) {
          return "nut-checkbox__icon--indeterminate";
        }
        return "nut-checkbox__icon";
      }
      return "nut-checkbox__icon--unchecked";
    };
    const renderLabel = () => {
      return /* @__PURE__ */ React.createElement("span", { className: `${b2("label", { disabled: innerDisabled })} ` }, children || label);
    };
    const handleClick = () => {
      if (disabled)
        return;
      const latestChecked = !innerChecked;
      if (ctx2 && ctx2.max !== void 0) {
        if (latestChecked && ctx2.checkedValue.length >= ctx2.max)
          return;
      }
      onChange && onChange(latestChecked, label || children);
      setInnerChecked(latestChecked);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${b2({ reverse: textPosition === "left" })} ${className || ""}`,
        ...rest,
        onClick: handleClick
      },
      renderIcon(),
      renderLabel()
    );
  };
  Checkbox.defaultProps = defaultProps$$;
  Checkbox.displayName = "NutCheckBox";
  Checkbox.Group = CheckboxGroup;
  const MIN_DISTANCE = 10;
  function getDirection(x, y) {
    if (x > y && x > MIN_DISTANCE) {
      return "horizontal";
    }
    if (y > x && y > MIN_DISTANCE) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    const [startX, SetStartX] = React.useState(0);
    const [startY, SetStartY] = React.useState(0);
    const [moveX, SetMoveX] = React.useState(0);
    const [moveY, SetMoveY] = React.useState(0);
    const [deltaX, SetDeltaX] = React.useState(0);
    const [deltaY, SetDeltaY] = React.useState(0);
    const [offsetX, SetOffsetX] = React.useState(0);
    const [offsetY, SetOffsetY] = React.useState(0);
    const [direction, SetDirection] = React.useState("");
    const isVertical = () => direction === "vertical";
    const isHorizontal = () => direction === "horizontal";
    const reset = () => {
      SetDeltaX(0);
      SetDeltaY(0);
      SetOffsetX(0);
      SetOffsetY(0);
      SetDirection("");
    };
    const start2 = (event) => {
      reset();
      SetStartX(event.touches[0].clientX);
      SetStartY(event.touches[0].clientY);
    };
    const move = (event) => {
      const touch = event.touches[0];
      const dX = touch.clientX - startX;
      const dY = touch.clientY - startY;
      SetDeltaX(dX);
      SetDeltaY(dY);
      SetMoveX(touch.clientX);
      SetMoveY(touch.clientY);
      SetOffsetX(Math.abs(dX));
      SetOffsetY(Math.abs(dY));
      if (!direction) {
        SetDirection(getDirection(offsetX, offsetY));
      }
    };
    return {
      move,
      start: start2,
      reset,
      startX,
      startY,
      moveX,
      moveY,
      deltaX,
      deltaY,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal
    };
  }
  let passiveSupported = false;
  if (canUseDom) {
    try {
      const opts = Object.defineProperty({}, "passive", {
        get() {
          passiveSupported = true;
        }
      });
      window.addEventListener("test-passive-supported", null, opts);
    } catch (e) {
      console.log(e);
    }
  }
  const InternalPickerSlot = (props, ref) => {
    const {
      keyIndex = 0,
      defaultValue,
      listData = [],
      threeDimensional = true,
      swipeDuration = 1e3,
      itemShow = false,
      chooseItem
    } = props;
    const touch = useTouch();
    const DEFAULT_DURATION = 200;
    const INERTIA_TIME = 300;
    const INERTIA_DISTANCE = 15;
    const [currIndex, setCurrIndex] = React.useState(1);
    const lineSpacing = React.useRef(36);
    const [touchTime, setTouchTime] = React.useState(0);
    const [touchDeg, setTouchDeg] = React.useState("0deg");
    const rotation = 20;
    const moving = React.useRef(false);
    let timer;
    const listRef = React.useRef(null);
    const rollerRef = React.useRef(null);
    const pickerSlotRef = React.useRef(null);
    const [startTime, setStartTime] = React.useState(0);
    const [startY, setStartY] = React.useState(0);
    const transformY = React.useRef(0);
    const [scrollDistance, setScrollDistance] = React.useState(0);
    const isHidden = (index) => {
      if (index >= currIndex + 8 || index <= currIndex - 8) {
        return true;
      }
      return false;
    };
    const setTransform = (translateY = 0, type, time = DEFAULT_DURATION, deg) => {
      let nTime = time;
      if (type !== "end") {
        nTime = 0;
      }
      setTouchTime(nTime);
      setTouchDeg(deg);
      setScrollDistance(translateY);
    };
    const setMove = (move, type, time) => {
      let updateMove = move + transformY.current;
      if (type === "end") {
        if (updateMove > 0) {
          updateMove = 0;
        }
        if (updateMove < -(listData.length - 1) * lineSpacing.current) {
          updateMove = -(listData.length - 1) * lineSpacing.current;
        }
        const endMove = Math.round(updateMove / lineSpacing.current) * lineSpacing.current;
        const deg = `${(Math.abs(Math.round(endMove / lineSpacing.current)) + 1) * rotation}deg`;
        setTransform(endMove, type, time, deg);
        setCurrIndex(Math.abs(Math.round(endMove / lineSpacing.current)) + 1);
      } else {
        let deg = 0;
        const currentDeg = (-updateMove / lineSpacing.current + 1) * rotation;
        const maxDeg = (listData.length + 1) * rotation;
        const minDeg = 0;
        deg = Math.min(Math.max(currentDeg, minDeg), maxDeg);
        if (minDeg < deg && deg < maxDeg) {
          setTransform(updateMove, "", void 0, `${deg}deg`);
          setCurrIndex(Math.abs(Math.round(updateMove / lineSpacing.current)) + 1);
        }
      }
    };
    const setChooseValue = (move) => {
      chooseItem && chooseItem(listData == null ? void 0 : listData[Math.round(-move / lineSpacing.current)], keyIndex);
    };
    const touchStart = (event) => {
      touch.start(event);
      setStartY(touch.deltaY);
      setStartTime(Date.now());
      transformY.current = scrollDistance;
    };
    const touchMove = (event) => {
      touch.move(event);
      if (touch.isVertical) {
        moving.current = true;
        preventDefault2(event, true);
      }
      const move = touch.deltaY - startY;
      setMove(move);
    };
    const touchEnd = (event) => {
      if (!moving.current)
        return;
      const move = touch.deltaY - startY;
      const moveTime = Date.now() - startTime;
      if (moveTime <= INERTIA_TIME && Math.abs(move) > INERTIA_DISTANCE) {
        const distance = momentum(move, moveTime);
        setMove(distance, "end", +swipeDuration);
      } else {
        setMove(move, "end");
      }
      setTimeout(() => {
        touch.reset();
      }, 0);
    };
    const momentum = (distance, duration) => {
      let nDistance = distance;
      const speed = Math.abs(nDistance / duration);
      nDistance = speed / 3e-3 * (nDistance < 0 ? -1 : 1);
      return nDistance;
    };
    const modifyStatus = (type, val) => {
      const value = val || defaultValue;
      let index = -1;
      if (value) {
        listData.some((item, idx) => {
          if (item.value === value) {
            index = idx;
            return true;
          }
          return false;
        });
      } else {
        listData.forEach((item, i) => {
          if (item.value === defaultValue) {
            index = i;
          }
        });
      }
      setCurrIndex(index === -1 ? 1 : index + 1);
      const move = index === -1 ? 0 : index * lineSpacing.current;
      type && setChooseValue(-move);
      setMove(-move);
    };
    const stopMomentum = () => {
      moving.current = false;
      setTouchTime(0);
      setChooseValue(scrollDistance);
    };
    const preventDefault2 = (event, isStopPropagation) => {
      if (!passiveSupported && (typeof event.cancelable !== "boolean" || event.cancelable)) {
        event.preventDefault();
      }
      if (isStopPropagation) {
        event.stopPropagation();
      }
    };
    const getReference = async () => {
      const refe = await getRectByTaro(listRef == null ? void 0 : listRef.current);
      lineSpacing.current = refe.height ? refe.height : 36;
      modifyStatus(true);
    };
    const touchRollerStyle = () => {
      return {
        transition: `transform ${touchTime}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `rotate3d(1, 0, 0, ${touchDeg})`
      };
    };
    const touchTileStyle = () => {
      return {
        transition: `transform ${touchTime}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `translate3d(0, ${scrollDistance}px, 0)`
      };
    };
    React.useEffect(() => {
      setScrollDistance(0);
      transformY.current = 0;
      modifyStatus(false);
      return () => {
        clearTimeout(timer);
      };
    }, [listData]);
    React.useEffect(() => {
      if (itemShow) {
        setTimeout(() => {
          getReference();
        }, 200);
      }
    }, [itemShow]);
    React.useImperativeHandle(ref, () => ({
      stopMomentum,
      moving: moving.current
    }));
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-picker-list",
        ref: pickerSlotRef,
        onTouchStart: touchStart,
        onTouchMove: touchMove,
        onTouchEnd: touchEnd
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-picker-roller",
          ref: rollerRef,
          style: threeDimensional ? touchRollerStyle() : touchTileStyle(),
          onTransitionEnd: stopMomentum
        },
        threeDimensional && listData.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: `nut-picker-roller-item ${isHidden(index + 1) && "nut-picker-roller-item-hidden"}`,
              style: {
                transform: `rotate3d(1, 0, 0, ${-rotation * (index + 1)}deg) translate3d(0px, 0px, 104px)`,
                height: `${lineSpacing.current}px`,
                lineHeight: `${lineSpacing.current}px`
              },
              key: item.value ? item.value : index
            },
            /* @__PURE__ */ React.createElement(React.Fragment, null, item.text ? item.text : item)
          );
        }),
        !threeDimensional && listData.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            "div",
            {
              className: "nut-picker-roller-item-title",
              key: item.value ? item.value : index,
              style: {
                height: `${lineSpacing.current}px`,
                lineHeight: `${lineSpacing.current}px`
              }
            },
            /* @__PURE__ */ React.createElement(React.Fragment, null, item.text ? item.text : item)
          );
        })
      ),
      /* @__PURE__ */ React.createElement("div", { className: "nut-picker-mask" }),
      /* @__PURE__ */ React.createElement("div", { className: "nut-picker-indicator", ref: listRef })
    );
  };
  const PickerSlot = React.forwardRef(InternalPickerSlot);
  const PickerSlot$1 = PickerSlot;
  function useRefs() {
    const refs = React.useRef([]);
    const setRefs = React.useCallback(
      (index) => (el) => {
        if (el)
          refs.current[index] = el;
      },
      []
    );
    const reset = React.useCallback(() => {
      refs.current = [];
    }, []);
    return [refs.current, setRefs, reset];
  }
  const InternalPicker = (props, ref) => {
    const { locale } = useConfig$1();
    const {
      isVisible,
      title,
      listData = [],
      defaultValueData,
      onConfirm,
      onClose,
      onCloseUpdate,
      onChange,
      className,
      style,
      threeDimensional,
      swipeDuration,
      ...rest
    } = props;
    const [chooseValueData, setchooseValueData] = React.useState([]);
    const [columnIndex, setcolumnIndex] = React.useState(0);
    const pickerRef = React.useRef(null);
    const [refs, setRefs] = useRefs();
    const [columnsList, setColumnsList] = React.useState([]);
    const b2 = cn("picker");
    const isConfirmEvent = React.useRef(false);
    const formatCascade = (columns, values) => {
      const formatted = [];
      let cursor = {
        text: "",
        value: "",
        children: columns
      };
      let columnIndex2 = 0;
      while (cursor && cursor.children) {
        const options = cursor.children;
        const value = values[columnIndex2];
        let index = options.findIndex(
          (columnItem) => columnItem.value === value
        );
        if (index === -1)
          index = 0;
        cursor = cursor.children[index];
        columnIndex2++;
        formatted.push(options);
      }
      return formatted;
    };
    const columnsType = () => {
      const firstColumn = listData[0];
      if (firstColumn) {
        if (Array.isArray(firstColumn)) {
          return "multiple";
        }
        if ("children" in firstColumn) {
          return "cascade";
        }
      }
      return "single";
    };
    const normalListData = () => {
      const type = columnsType();
      switch (type) {
        case "multiple":
          return listData;
        case "cascade":
          return formatCascade(listData, chooseValueData);
        default:
          return [listData];
      }
    };
    const init = () => {
      const normalData = normalListData();
      setColumnsList(normalData);
    };
    React.useEffect(() => {
      init();
    }, [listData]);
    React.useEffect(() => {
      if (defaultValueData && defaultValueData.length !== 0 && defaultValueData.toString() !== chooseValueData.toString() && !currentValue2.length) {
        const data = [...defaultValueData];
        setchooseValueData(data);
        setColumnsList(normalListData());
      }
    }, [defaultValueData]);
    const selectedOptions = () => {
      const optins = [];
      columnsList.map((column, index) => {
        let currOptions = [];
        currOptions = column.filter(
          (item) => item.value === chooseValueData[index]
        );
        if (currOptions[0]) {
          optins.push(currOptions[0]);
        } else {
          column[0] && optins.push(column[0]);
        }
        return column;
      });
      return optins;
    };
    React.useEffect(() => {
      Taro.getEnv() !== "WEB" && setCurrentValue(defaultValuesConvert());
      onChange && onChange(columnIndex, chooseValueData, selectedOptions());
      if (isConfirmEvent.current) {
        isConfirmEvent.current = false;
        onConfirm && onConfirm(chooseValueData, selectedOptions());
      }
    }, [chooseValueData]);
    const closeActionSheet = () => {
      onClose && onClose(chooseValueData, selectedOptions());
      onCloseUpdate && onCloseUpdate(chooseValueData, selectedOptions(), pickerRef);
    };
    const chooseItem = (option, columnIndex2) => {
      if (option && Object.keys(option).length) {
        if (chooseValueData[columnIndex2] !== option.value) {
          if (columnsType() === "cascade") {
            chooseValueData[columnIndex2] = option.value ? option.value : "";
            setchooseValueData([...chooseValueData]);
            let index = columnIndex2;
            let cursor = option;
            while (cursor && cursor.children && cursor.children[0]) {
              chooseValueData[index + 1] = cursor.children[0].value;
              setchooseValueData([...chooseValueData]);
              index++;
              cursor = cursor.children[0];
            }
            if (cursor && cursor.children) {
              chooseValueData[index + 1] = "";
              setchooseValueData([...chooseValueData]);
            }
            setColumnsList(normalListData());
          } else {
            setchooseValueData((data) => {
              const cdata = [...data];
              cdata[columnIndex2] = Object.prototype.hasOwnProperty.call(
                option,
                "value"
              ) ? option.value : "";
              return cdata;
            });
          }
          setcolumnIndex(columnIndex2);
        }
      }
    };
    const confirm = () => {
      let movings = false;
      refs.forEach((_ref) => {
        if (_ref.moving)
          movings = true;
        _ref.stopMomentum();
      });
      if (movings) {
        isConfirmEvent.current = true;
      } else {
        onConfirm && onConfirm(chooseValueData, selectedOptions());
      }
      onClose && onClose(chooseValueData, selectedOptions());
      setTimeout(() => {
        isConfirmEvent.current = false;
      }, 0);
    };
    const renderToolbar = () => {
      return /* @__PURE__ */ React.createElement("div", { className: b2("control") }, /* @__PURE__ */ React.createElement("span", { className: b2("cancel-btn"), onClick: () => closeActionSheet() }, locale.cancel), /* @__PURE__ */ React.createElement("div", { className: b2("title") }, title || ""), /* @__PURE__ */ React.createElement("span", { className: b2("confirm-btn"), onClick: confirm }, locale.confirm));
    };
    const [currentValue2, setCurrentValue] = React.useState([]);
    const [pickingStatus, setPickingStatus] = React.useState(false);
    const defaultValuesConvert = () => {
      const defaultIndexs = [];
      if (chooseValueData.length > 0) {
        chooseValueData.forEach((value, index) => {
          for (let i = 0; i < columnsList[index].length; i++) {
            if (columnsList[index][i].value === value) {
              defaultIndexs.push(i);
              break;
            }
          }
        });
      } else if (columnsList && columnsList.length > 0) {
        columnsList.forEach((item) => {
          defaultIndexs.push(0);
          item.length > 0 && chooseValueData.push(item[0].value);
        });
      }
      return defaultIndexs;
    };
    const pickerStart = () => {
      setPickingStatus(true);
    };
    const pickerEnd = () => {
      setPickingStatus(false);
    };
    const pickerChange = (data) => {
      const prevDefaultValue = currentValue2;
      let changeIndex = 0;
      const list = data.detail.value;
      for (let i = 0, len = list.length; i < len; i++) {
        if (prevDefaultValue[i] !== list[i]) {
          changeIndex = i;
          break;
        }
      }
      chooseItem(
        columnsList[changeIndex][data.detail.value[changeIndex]],
        changeIndex
      );
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: isVisible,
        position: "bottom",
        onClose: () => {
          closeActionSheet();
        }
      },
      /* @__PURE__ */ React.createElement(
        components.View,
        {
          className: `${b2()} ${className || ""}`,
          style,
          ...rest,
          catchMove: true
        },
        renderToolbar(),
        /* @__PURE__ */ React.createElement("div", { className: b2("panel"), ref: pickerRef }, Taro.getEnv() === "WEB" ? columnsList == null ? void 0 : columnsList.map((item, index) => {
          return /* @__PURE__ */ React.createElement(
            PickerSlot$1,
            {
              ref: setRefs(index),
              defaultValue: chooseValueData == null ? void 0 : chooseValueData[index],
              listData: item,
              threeDimensional,
              chooseItem: (value, index2) => chooseItem(value, index2),
              swipeDuration,
              key: index,
              keyIndex: index,
              itemShow: isVisible
            }
          );
        }) : /* @__PURE__ */ React.createElement(
          components.PickerView,
          {
            ref: pickerRef,
            value: currentValue2,
            immediateChange: true,
            onPickStart: pickerStart,
            onChange: pickerChange,
            onPickEnd: pickerEnd,
            className: "nut-picker-view-panel"
          },
          columnsList == null ? void 0 : columnsList.map((column, index) => {
            return /* @__PURE__ */ React.createElement(components.PickerViewColumn, { key: `col${index}` }, column.map((item, index2) => {
              return /* @__PURE__ */ React.createElement(
                components.View,
                {
                  key: item.value || index2,
                  className: "nut-picker-roller-item-title"
                },
                /* @__PURE__ */ React.createElement(React.Fragment, null, item.text || item)
              );
            }));
          })
        ))
      )
    );
  };
  const Picker = React.forwardRef(InternalPicker);
  const Picker$1 = Picker;
  const defaultConfigRef = {
    current: {
      locale: zhCN
    }
  };
  const getDefaultConfig = () => {
    return defaultConfigRef.current;
  };
  const ConfigContext = React.createContext(null);
  const useConfig = () => {
    return React.useContext(ConfigContext) ?? getDefaultConfig();
  };
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const defaultProps$_ = {
    modelValue: null,
    visible: false,
    title: "",
    type: "date",
    isShowChinese: false,
    threeDimensional: true,
    minuteStep: 1,
    minDate: new Date(currentYear - 10, 0, 1),
    maxDate: new Date(currentYear + 10, 11, 31)
  };
  const DatePicker = (props) => {
    const {
      minDate,
      maxDate,
      type,
      isShowChinese,
      minuteStep,
      modelValue,
      visible,
      title,
      formatter,
      onCloseDatePicker,
      onConfirmDatePicker,
      filter,
      onChange,
      threeDimensional,
      className,
      style,
      ...rest
    } = {
      ...defaultProps$_,
      ...props
    };
    const { locale } = useConfig();
    const [show, setShow] = React.useState(false);
    const [currentDate, setCurrentDate] = React.useState(modelValue);
    const [defaultValue, setDefaultValue] = React.useState([]);
    const [listData, setListData] = React.useState([]);
    const pickerRef = React.useRef(null);
    const isDate = (val) => {
      return Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
    };
    const datepickerLang = locale.datepicker;
    const zhCNType = {
      day: datepickerLang.day,
      year: datepickerLang.year,
      month: datepickerLang.month,
      hour: datepickerLang.hour,
      minute: datepickerLang.min,
      seconds: datepickerLang.seconds
    };
    const formatValue = (value) => {
      let cvalue = value;
      if (!cvalue || cvalue && !isDate(cvalue)) {
        cvalue = minDate;
      }
      let timestmp = Math.max(cvalue.getTime(), minDate.getTime());
      timestmp = Math.min(timestmp, maxDate.getTime());
      return new Date(timestmp);
    };
    function getMonthEndDay(year, month) {
      return new Date(year, month, 0).getDate();
    }
    const getBoundary = (type2, value) => {
      const boundary = type2 === "min" ? minDate : maxDate;
      const year = boundary.getFullYear();
      let month = 1;
      let date = 1;
      let hour = 0;
      let minute = 0;
      if (type2 === "max") {
        month = 12;
        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      const seconds = minute;
      if (value.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value.getMonth() + 1 === month) {
          date = boundary.getDate();
          if (value.getDate() === date) {
            hour = boundary.getHours();
            if (value.getHours() === hour) {
              minute = boundary.getMinutes();
            }
          }
        }
      }
      return {
        [`${type2}Year`]: year,
        [`${type2}Month`]: month,
        [`${type2}Date`]: date,
        [`${type2}Hour`]: hour,
        [`${type2}Minute`]: minute,
        [`${type2}Seconds`]: seconds
      };
    };
    const ranges = (date) => {
      const curDate = date || currentDate;
      if (!curDate)
        return [];
      const { maxYear, maxDate: maxDate2, maxMonth, maxHour, maxMinute, maxSeconds } = getBoundary("max", curDate);
      const { minYear, minDate: minDate2, minMonth, minHour, minMinute, minSeconds } = getBoundary("min", curDate);
      let result = [
        {
          type: "year",
          range: [minYear, maxYear]
        },
        {
          type: "month",
          range: [minMonth, maxMonth]
        },
        {
          type: "day",
          range: [minDate2, maxDate2]
        },
        {
          type: "hour",
          range: [minHour, maxHour]
        },
        {
          type: "minute",
          range: [minMinute, maxMinute]
        },
        {
          type: "seconds",
          range: [minSeconds, maxSeconds]
        }
      ];
      switch (type.toLocaleLowerCase()) {
        case "date":
          result = result.slice(0, 3);
          break;
        case "datetime":
          result = result.slice(0, 5);
          break;
        case "time":
          result = result.slice(3, 6);
          break;
        case "year-month":
          result = result.slice(0, 2);
          break;
        case "hour-minutes":
          result = result.slice(3, 5);
          break;
        case "month-day":
          result = result.slice(1, 3);
          break;
        case "datehour":
          result = result.slice(0, 4);
          break;
      }
      return result;
    };
    const updateChooseValueCustmer = (index, selectedValue, cacheValueData) => {
      if (["date", "datetime", "datehour", "month-day", "year-month"].includes(
        type.toLocaleLowerCase()
      )) {
        const formatDate = [];
        selectedValue.forEach((item) => {
          formatDate.push(item);
        });
        if (type.toLocaleLowerCase() === "month-day" && formatDate.length < 3) {
          formatDate.unshift(
            new Date(modelValue || minDate || maxDate).getFullYear()
          );
        }
        if (type.toLocaleLowerCase() === "year-month" && formatDate.length < 3) {
          formatDate.push(new Date(modelValue || minDate || maxDate).getDate());
        }
        const year = Number(formatDate[0]);
        const month = Number(formatDate[1]) - 1;
        const day = Math.min(
          Number(formatDate[2]),
          getMonthEndDay(Number(formatDate[0]), Number(formatDate[1]))
        );
        let date = null;
        if (type.toLocaleLowerCase() === "date" || type.toLocaleLowerCase() === "month-day" || type.toLocaleLowerCase() === "year-month") {
          date = new Date(year, month, day);
        } else if (type.toLocaleLowerCase() === "datetime") {
          date = new Date(
            year,
            month,
            day,
            Number(formatDate[3]),
            Number(formatDate[4])
          );
        } else if (type.toLocaleLowerCase() === "datehour") {
          date = new Date(year, month, day, Number(formatDate[3]));
        }
        const isEqual2 = (currentDate == null ? void 0 : currentDate.getTime()) === (date == null ? void 0 : date.getTime());
        date && isDate(date) && !isEqual2 && setCurrentDate(formatValue(date));
      }
      props.onChange && props.onChange(index, selectedValue, cacheValueData);
    };
    const padZero = (num, targetLength = 2) => {
      let str = `${num}`;
      while (str.length < targetLength) {
        str = `0${str}`;
      }
      return str;
    };
    const formatterOption = (type2, value) => {
      let fOption = null;
      if (formatter) {
        fOption = formatter(type2, {
          text: padZero(value, 2),
          value: padZero(value, 2)
        });
      } else {
        const padMin = padZero(value, 2);
        const fatter = isShowChinese ? zhCNType[type2] : "";
        fOption = { text: padMin + fatter, value: padMin };
      }
      return fOption;
    };
    const generateValue = (min, max, val, type2, columnIndex) => {
      let cmin = min;
      const arr = [];
      let index = 0;
      while (cmin <= max) {
        arr.push(formatterOption(type2, cmin));
        if (type2 === "minute") {
          cmin += minuteStep;
        } else {
          cmin++;
        }
        if (cmin <= val) {
          index++;
        }
      }
      defaultValue[columnIndex] = arr[index].value;
      setDefaultValue([...defaultValue]);
      if (props.filter && props.filter(type2, arr)) {
        return props.filter(type2, arr);
      }
      return arr;
    };
    const getDateIndex = (type2) => {
      if (!currentDate)
        return 0;
      let d = 0;
      if (type2 === "year") {
        d = currentDate.getFullYear();
      } else if (type2 === "month") {
        d = currentDate.getMonth() + 1;
      } else if (type2 === "day") {
        d = currentDate.getDate();
      } else if (type2 === "hour") {
        d = currentDate.getHours();
      } else if (type2 === "minute") {
        d = currentDate.getMinutes();
      } else if (type2 === "seconds") {
        d = currentDate.getSeconds();
      }
      return d;
    };
    const columns = (date) => {
      const val = ranges(date).map((res, columnIndex) => {
        return generateValue(
          res.range[0],
          res.range[1],
          getDateIndex(res.type),
          res.type,
          columnIndex
        );
      });
      return val || [];
    };
    React.useEffect(() => {
      setCurrentDate(formatValue(modelValue));
    }, []);
    React.useEffect(() => {
      setCurrentDate(formatValue(modelValue));
    }, [modelValue]);
    React.useEffect(() => {
      setShow(visible);
    }, [visible]);
    React.useEffect(() => {
      if (currentDate) {
        setListData(columns());
      }
    }, [currentDate]);
    return /* @__PURE__ */ React.createElement(
      components.View,
      {
        className: `nut-datepicker ${className || ""}`,
        style,
        ...rest,
        catchMove: true
      },
      listData.length > 0 && /* @__PURE__ */ React.createElement(
        Picker$1,
        {
          title,
          isVisible: show,
          listData,
          onClose: onCloseDatePicker,
          defaultValueData: defaultValue,
          onConfirm: (values, options) => onConfirmDatePicker && onConfirmDatePicker(values, options),
          onChange: (index, value, list) => updateChooseValueCustmer(index, value, list),
          threeDimensional,
          ref: pickerRef
        }
      )
    );
  };
  DatePicker.defaultProps = defaultProps$_;
  DatePicker.displayName = "NutDatePicker";
  const FormItemContext = React.createContext({});
  const defaultProps$Z = {
    ...ComponentDefaults,
    name: "",
    label: "",
    className: "",
    rules: [{ required: false, message: "" }],
    disabled: false,
    labelWidth: 90,
    errorMessageAlign: "left",
    showErrorLine: true,
    showErrorMessage: true
  };
  class FormItem extends React.Component {
    constructor() {
      super(...arguments);
      __publicField(this, "cancelRegister");
      // children添加value属性和onChange事件
      __publicField(this, "getControlled", (children) => {
        const { getFieldValue, setFieldsValue } = this.context;
        const { name } = this.props;
        const type = children.type.NAME;
        return {
          value: getFieldValue(name),
          onChange: (event) => {
            let newValue = event;
            switch (type) {
              case "checkbox":
                newValue = event.target.value;
                break;
            }
            setFieldsValue({ [name]: newValue });
          }
        };
      });
      __publicField(this, "onStoreChange", () => {
        this.forceUpdate();
      });
      __publicField(this, "renderLayout", (childNode) => {
        var _a, _b;
        const {
          label,
          name,
          rules = [{ required: false, message: "" }],
          className,
          labelWidth,
          errorMessageAlign,
          showErrorLine,
          showErrorMessage
        } = {
          ...defaultProps$Z,
          ...this.props
        };
        const item = ((_a = this.context.errList) == null ? void 0 : _a.length) > 0 && ((_b = this.context.errList) == null ? void 0 : _b.filter((item2) => {
          return item2.field === name;
        }));
        const { starPositon } = this.context;
        const renderStar = rules.length > 0 && rules[0].required && /* @__PURE__ */ React.createElement("i", { className: "required" });
        const renderLabel = starPositon === "Right" ? /* @__PURE__ */ React.createElement(React.Fragment, null, label, renderStar) : /* @__PURE__ */ React.createElement(React.Fragment, null, renderStar, label);
        return /* @__PURE__ */ React.createElement(Cell, { className: `nut-form-item ${className}` }, label ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-cell__title nut-form-item__label",
            style: {
              width: this.pxCheck(labelWidth)
            }
          },
          renderLabel
        ) : null, /* @__PURE__ */ React.createElement("div", { className: "nut-cell__value nut-form-item__body" }, /* @__PURE__ */ React.createElement("div", { className: "nut-form-item__body__slots" }, childNode), item.length > 0 && /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-form-item__body__tips",
            style: { textAlign: errorMessageAlign }
          },
          item[0].message
        )));
      });
      __publicField(this, "pxCheck", (value) => {
        return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
      });
    }
    componentDidMount() {
      this.cancelRegister = this.context.registerField(this);
    }
    componentWillUnmount() {
      if (this.cancelRegister) {
        this.cancelRegister();
      }
    }
    render() {
      const { children } = this.props;
      const c = Array.isArray(children) ? children[0] : children;
      const returnChildNode = React.cloneElement(
        c,
        this.getControlled(c)
      );
      return this.renderLayout(returnChildNode);
    }
  }
  __publicField(FormItem, "defaultProps", defaultProps$Z);
  __publicField(FormItem, "contextType", FormItemContext);
  class FormStore {
    constructor() {
      __publicField(this, "store", {});
      // 存放表单中所有的数据 eg. {password: "ddd",username: "123"}
      __publicField(this, "fieldEntities", []);
      // 所有的组件实例
      // 成功和失败的回调
      __publicField(this, "callbacks", {});
      __publicField(this, "errList", []);
      /**
       * 注册组件实例
       * @param field
       */
      __publicField(this, "registerField", (field) => {
        this.fieldEntities.push(field);
        return () => {
          this.fieldEntities = this.fieldEntities.filter((item) => item != field);
          delete this.store[field.props.name];
        };
      });
      __publicField(this, "getFieldValue", (name) => {
        return this.store[name];
      });
      /**
       * 存储组件数据
       * @param newStore { [name]: newValue }
       */
      __publicField(this, "setFieldsValue", (newStore) => {
        this.store = {
          ...this.store,
          ...newStore
        };
        this.fieldEntities.forEach((enetity) => {
          const { name } = enetity.props;
          Object.keys(newStore).forEach((key) => {
            if (key === name) {
              enetity.onStoreChange();
            }
          });
        });
      });
      /**
       * 表单校验
       * rules: { required: true, message: '' }
       * descriptor: {
       *    username: {
       *      type: 'string',
       *      required: true,
       *      validator: (rule, value) => {
       *        return /^[a-zA-Z0-9]+$/.test(value)
       *      },
       *    },
       *  }
       */
      __publicField(this, "validate", () => {
        const err = [];
        this.errList.length = 0;
        this.fieldEntities.forEach((entity) => {
          const { name, rules = [] } = entity.props;
          const descriptor = {};
          if (rules.length) {
            if (rules.length > 1) {
              descriptor[name] = [];
              rules.map((v) => {
                descriptor[name].push(v);
              });
            } else {
              descriptor[name] = rules[0];
            }
          }
        });
        return err;
      });
      __publicField(this, "setCallback", (callback) => {
        this.callbacks = {
          ...this.callbacks,
          ...callback
        };
      });
      __publicField(this, "submit", () => {
        var _a, _b, _c, _d;
        const err = this.validate();
        if (err.length === 0) {
          (_b = (_a = this.callbacks).onFinish) == null ? void 0 : _b.call(_a, this.store);
        } else if (err.length > 0) {
          (_d = (_c = this.callbacks).onFinishFailed) == null ? void 0 : _d.call(_c, err);
        }
      });
      __publicField(this, "resetFields", () => {
      });
      __publicField(this, "getForm", () => {
        return {
          setCallback: this.setCallback,
          registerField: this.registerField,
          getFieldValue: this.getFieldValue,
          setFieldsValue: this.setFieldsValue,
          submit: this.submit,
          store: this.store,
          errList: this.errList,
          fieldEntities: this.fieldEntities
        };
      });
      this.callbacks = {
        onFinish: (value) => {
        },
        onFinishFailed: () => {
        }
      };
    }
  }
  const useForm = (form) => {
    const formRef = React.useRef();
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        const formStore = new FormStore();
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  };
  const defaultProps$Y = {
    ...ComponentDefaults,
    className: "",
    style: void 0,
    form: {},
    labelPosition: "Right",
    formGroupTitle: "",
    onFinish: (obj) => {
    },
    onFinishFailed: (value) => {
    },
    starPositon: "Left"
  };
  const PositionInfo = {
    Top: "form-layout-top",
    Left: "form-layout-left",
    Right: "form-layout-right"
  };
  const Form = (props) => {
    const {
      children,
      onFinish,
      onFinishFailed,
      labelPosition,
      starPositon,
      ...rest
    } = {
      ...defaultProps$Y,
      ...props
    };
    const [formInstance] = useForm();
    formInstance.starPositon = starPositon;
    const { setCallback, submit } = formInstance;
    setCallback({
      onFinish,
      onFinishFailed
    });
    return /* @__PURE__ */ React.createElement(
      "form",
      {
        className: `nut-form ${PositionInfo[labelPosition]} ${props.className}`,
        style: props.style,
        onSubmit: (e) => {
          e.preventDefault();
          submit();
        }
      },
      /* @__PURE__ */ React.createElement(CellGroup, null, /* @__PURE__ */ React.createElement(FormItemContext.Provider, { value: formInstance }, children))
    );
  };
  Form.defaultProps = defaultProps$Y;
  Form.displayName = "NutForm";
  Form.Item = FormItem;
  function trimExtraChar(value, char, regExp) {
    const index = value.indexOf(char);
    if (index === -1) {
      return value;
    }
    if (char === "-" && index !== 0) {
      return value.slice(0, index);
    }
    return value.slice(0, index + 1) + value.slice(index).replace(regExp, "");
  }
  function formatNumber(value, allowDot = true, allowMinus = true) {
    if (allowDot) {
      value = trimExtraChar(value, ".", /\./g);
    } else {
      value = value.split(".")[0];
    }
    if (allowMinus) {
      value = trimExtraChar(value, "-", /-/g);
    } else {
      value = value.replace(/-/, "");
    }
    const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value.replace(regExp, "");
  }
  const defaultProps$X = {
    ...ComponentDefaults,
    type: "text",
    name: "",
    defaultValue: "",
    placeholder: "",
    label: "",
    labelClass: "",
    labelWidth: "80",
    labelAlign: "left",
    colon: false,
    inputAlign: "left",
    center: false,
    required: false,
    disabled: false,
    readonly: false,
    error: false,
    maxlength: "9999",
    leftIcon: "",
    leftIconSize: "",
    rightIcon: "",
    rightIconSize: "",
    clearable: false,
    clearIcon: "mask-close",
    clearSize: "14",
    border: true,
    formatTrigger: "onChange",
    rules: [],
    rows: null,
    errorMessage: "",
    errorMessageAlign: "",
    showWordLimit: false,
    autofocus: false,
    slotButton: null,
    slotInput: null
  };
  const Input = React.forwardRef(
    (props, ref) => {
      const { locale } = useConfig$1();
      const {
        children,
        type,
        name,
        defaultValue,
        placeholder,
        label,
        labelClass,
        labelWidth,
        labelAlign,
        colon,
        inputAlign,
        center,
        required,
        disabled,
        readonly,
        error,
        maxlength,
        leftIcon,
        leftIconSize,
        rightIcon,
        rightIconSize,
        clearable,
        clearIcon,
        clearSize,
        border,
        formatTrigger,
        rules,
        errorMessage,
        errorMessageAlign,
        showWordLimit,
        autofocus,
        style,
        className,
        rows,
        slotButton,
        slotInput,
        onChange,
        onBlur,
        onFocus,
        onClear,
        formatter,
        keypress,
        onClickInput,
        onClickLeftIcon,
        onClickRightIcon,
        onClick,
        iconClassPrefix,
        iconFontClassName,
        ...rest
      } = {
        ...defaultProps$X,
        ...props
      };
      const inputPlaceholder = placeholder || locale.placeholder;
      const [inputValue, SetInputValue] = React.useState("");
      const [active, SetActive] = React.useState(false);
      const [classes, setClasses] = React.useState("");
      const getModelValue = () => String(inputValue ?? "");
      const inputRef = React.useRef(null);
      React.useEffect(() => {
        setClasses(inputClass);
        SetInputValue(defaultValue);
      }, [defaultValue]);
      React.useEffect(() => {
        if (inputValue) {
          updateValue(getModelValue());
          resetValidation();
        }
      }, [inputValue]);
      React.useImperativeHandle(ref, () => {
        return inputRef.current;
      });
      const inputClass = React.useCallback(() => {
        const prefixCls = "nut-input";
        return [
          prefixCls,
          `${center ? "center" : ""}`,
          `${disabled ? `${prefixCls}-disabled` : ""}`,
          `${required ? `${prefixCls}-required` : ""}`,
          `${error ? `${prefixCls}-error` : ""}`,
          `${border ? `${prefixCls}-border` : ""}`,
          `${slotButton || rightIcon ? `${prefixCls}-right-mark` : ""}`
        ].filter(Boolean).join(" ");
      }, [disabled, required, error, border, slotButton, rightIcon, center]);
      React.useEffect(() => {
        setClasses(inputClass);
      }, [disabled, required, error, border, slotButton, rightIcon, center]);
      const updateValue = (value, trigger = "onChange") => {
        var _a;
        let val = value;
        if (type === "tel") {
          val = formatNumber(val, false, false);
        }
        if (["number", "digit"].includes(type)) {
          val = formatNumber(val, true, true);
        }
        if (type === "tel" && !formatter) {
          const regTel = /^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$/;
          const regNumber = /[^-0-9]/g;
          val = !regTel.test(val) && val.length > 11 ? val.substring(0, 11) : val.replace(regNumber, "");
        }
        if (formatter && trigger === formatTrigger) {
          val = formatter(val);
        }
        if (((_a = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a.value) !== val) {
          inputRef.current.value = val;
        }
        SetInputValue(val);
      };
      const handleFocus = (event) => {
        const val = event.target.value;
        SetActive(true);
        onFocus && onFocus(val, event);
      };
      const handleInput = (event) => {
        let val = event.target.value;
        if (maxlength && val.length > Number(maxlength)) {
          val = val.slice(0, Number(maxlength));
        }
        updateValue(val, "onChange");
        onChange && onChange(val, event);
      };
      const handleBlur = (event) => {
        setTimeout(() => {
          SetActive(false);
        }, 200);
        let val = event.target.value;
        if (maxlength && val.length > Number(maxlength)) {
          val = val.slice(0, Number(maxlength));
        }
        updateValue(val, "onBlur");
        onBlur && onBlur(val, event);
      };
      const handleClickInput = (event) => {
        onClickInput && onClickInput(event);
      };
      const handleClickLeftIcon = (event) => {
        onClickLeftIcon && onClickLeftIcon(event);
      };
      const handleClickRightIcon = (event) => {
        onClickRightIcon && onClickRightIcon(event);
      };
      const resetValidation = () => {
      };
      const inputType = (type2) => {
        if (type2 === "tel") {
          return "text";
        }
        return type2;
      };
      const handleClear = (event) => {
        setTimeout(() => {
          updateValue("");
          onClear && onClear("", event);
        }, 50);
      };
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classes}  ${className || ""}`,
          style,
          onClick: (e) => {
            onClick && onClick(e);
          }
        },
        slotInput ? /* @__PURE__ */ React.createElement(React.Fragment, null, label ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-input-label ${labelClass}`,
            style: { width: `${labelWidth}px`, textAlign: labelAlign }
          },
          /* @__PURE__ */ React.createElement("div", { className: "label-string" }, label, colon ? ":" : "")
        ) : null, /* @__PURE__ */ React.createElement("div", { className: "nut-input-value" }, /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-input-inner",
            onClick: (e) => {
              handleClickInput(e);
            }
          },
          slotInput
        ))) : /* @__PURE__ */ React.createElement(React.Fragment, null, leftIcon && leftIcon.length > 0 ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-input-left-icon",
            onClick: (e) => {
              handleClickLeftIcon(e);
            }
          },
          /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              name: leftIcon,
              size: leftIconSize
            }
          )
        ) : null, label ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-input-label ${labelClass}`,
            style: { width: `${labelWidth}px`, textAlign: labelAlign }
          },
          /* @__PURE__ */ React.createElement("div", { className: "label-string" }, label, colon ? ":" : "")
        ) : null, /* @__PURE__ */ React.createElement("div", { className: "nut-input-value" }, /* @__PURE__ */ React.createElement("div", { className: "nut-input-main-con" }, /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-input-inner",
            onClick: (e) => {
              handleClickInput(e);
            }
          },
          type === "textarea" ? /* @__PURE__ */ React.createElement(
            "textarea",
            {
              name,
              className: "input-text",
              ref: inputRef,
              style: {
                textAlign: inputAlign,
                height: `${Number(rows) * 24}px`
              },
              maxLength: maxlength,
              placeholder: inputPlaceholder,
              disabled,
              readOnly: readonly,
              value: inputValue,
              autoFocus: autofocus,
              onBlur: (e) => {
                handleBlur(e);
              },
              onFocus: (e) => {
                handleFocus(e);
              },
              onInput: (e) => {
                handleInput(e);
              }
            }
          ) : /* @__PURE__ */ React.createElement(
            "input",
            {
              ...rest,
              name,
              className: "input-text",
              ref: inputRef,
              style: { textAlign: inputAlign },
              type: inputType(type),
              maxLength: maxlength,
              placeholder: inputPlaceholder,
              disabled,
              readOnly: readonly,
              value: inputValue,
              autoFocus: autofocus,
              onBlur: (e) => {
                handleBlur(e);
              },
              onFocus: (e) => {
                handleFocus(e);
              },
              onInput: (e) => {
                handleInput(e);
              }
            }
          ),
          /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              style: {
                display: clearable && !readonly && active && inputValue.length > 0 ? "inline-flex" : "none",
                alignItems: "center"
              },
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              className: "nut-input-clear",
              name: clearIcon,
              size: clearSize,
              onClick: (e) => {
                handleClear(e);
              }
            }
          )
        ), rightIcon && rightIcon.length > 0 ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-input-right-icon",
            onClick: (e) => {
              handleClickRightIcon(e);
            }
          },
          /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              name: rightIcon,
              size: rightIconSize
            }
          )
        ) : null, slotButton ? /* @__PURE__ */ React.createElement("div", { className: "nut-input-button" }, slotButton) : null, showWordLimit && maxlength ? /* @__PURE__ */ React.createElement("div", { className: "nut-input-word-limit" }, /* @__PURE__ */ React.createElement("span", { className: "nut-input-word-num" }, inputValue ? inputValue.length : 0), "/", maxlength) : null), errorMessage ? /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-input-error-message",
            style: {
              textAlign: errorMessageAlign
            }
          },
          errorMessage
        ) : /* @__PURE__ */ React.createElement("div", null)))
      );
    }
  );
  Input.defaultProps = defaultProps$X;
  Input.displayName = "NutInput";
  const defaultProps$W = {
    ...ComponentDefaults,
    disabled: false,
    buttonSize: "",
    min: 1,
    max: 9999,
    inputWidth: "",
    readonly: false,
    modelValue: 0,
    step: 1,
    decimalPlaces: 0,
    isAsync: false
  };
  function pxCheck$1(value) {
    return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
  }
  const InputNumber = (props) => {
    const {
      children,
      disabled,
      buttonSize,
      min,
      max,
      inputWidth,
      readonly,
      modelValue,
      decimalPlaces,
      step,
      isAsync,
      className,
      style,
      add,
      reduce,
      change,
      overlimit,
      blur,
      focus,
      onAdd,
      onReduce,
      onOverlimit,
      onBlurFuc,
      onFocus,
      onChangeFuc,
      iconClassPrefix,
      iconFontClassName,
      ...restProps
    } = {
      ...defaultProps$W,
      ...props
    };
    const [inputValue, setInputValue] = React.useState(modelValue);
    React.useEffect(() => {
      setInputValue(modelValue);
    }, [modelValue]);
    const b2 = cn("inputnumber");
    const classes = classNames(
      {
        [`${b2("")}--disabled`]: disabled
      },
      className,
      b2("")
    );
    const styles = {
      height: pxCheck$1(buttonSize),
      ...style
    };
    const addAllow = (value = Number(inputValue)) => {
      return value < Number(max) && !disabled;
    };
    const reduceAllow = (value = Number(inputValue)) => {
      return value > Number(min) && !disabled;
    };
    const iconMinusClasses = classNames("nut-inputnumber__icon", {
      "nut-inputnumber__icon--disabled": !reduceAllow()
    });
    const iconAddClasses = classNames("nut-inputnumber__icon", {
      "nut-inputnumber__icon--disabled": !addAllow()
    });
    const fixedDecimalPlaces = (v) => {
      return Number(v).toFixed(Number(decimalPlaces));
    };
    const emitChange = (value, e) => {
      const outputValue = fixedDecimalPlaces(value);
      onChangeFuc && onChangeFuc(outputValue, e);
      change && change(outputValue, e);
      if (!isAsync) {
        setInputValue(outputValue);
      }
    };
    const reduceNumber = (e) => {
      onReduce && onReduce(e);
      reduce && reduce(e);
      if (reduceAllow()) {
        const outputValue = Number(inputValue) - Number(step);
        emitChange(outputValue, e);
      } else {
        onOverlimit && onOverlimit(e);
        overlimit && overlimit(e);
      }
    };
    const addNumber = (e) => {
      onAdd && onAdd(e);
      add && add(e);
      if (addAllow()) {
        const outputValue = Number(inputValue) + Number(step);
        emitChange(outputValue, e);
      } else {
        onOverlimit && onOverlimit(e);
        overlimit && overlimit(e);
      }
    };
    const changeValue = (e) => {
      const input = e.target;
      change && change(input.value, e);
      onChangeFuc && onChangeFuc(input.value, e);
      if (!isAsync) {
        setInputValue(input.value);
      }
    };
    const focusValue = (e) => {
      if (disabled)
        return;
      if (readonly)
        return;
      onFocus && onFocus(e);
      focus && focus(e);
    };
    const burValue = (e) => {
      if (disabled)
        return;
      if (readonly)
        return;
      const input = e.target;
      let value = +input.value;
      if (value < Number(min)) {
        value = Number(min);
      } else if (value > Number(max)) {
        value = Number(max);
      }
      emitChange(value, e);
      onBlurFuc && onBlurFuc(e);
      blur && blur(e);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style: styles, ...restProps }, /* @__PURE__ */ React.createElement("div", { className: "nut-input-minus" }, /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        className: iconMinusClasses,
        size: buttonSize,
        name: "minus",
        onClick: reduceNumber
      }
    )), /* @__PURE__ */ React.createElement(
      "input",
      {
        className: "nut-number-input",
        type: "digit",
        min,
        max,
        style: { width: pxCheck$1(inputWidth) },
        disabled,
        readOnly: readonly,
        value: inputValue,
        onInput: changeValue,
        onBlur: burValue,
        onFocus: focusValue
      }
    ), /* @__PURE__ */ React.createElement("div", { className: "nut-input-add" }, /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        className: iconAddClasses,
        size: buttonSize,
        name: "plus",
        onClick: addNumber
      }
    )));
  };
  InputNumber.defaultProps = defaultProps$W;
  InputNumber.displayName = "NutInputNumber";
  const defaultProps$V = {
    confirmText: "",
    title: "",
    visible: false,
    overlay: false,
    type: "default",
    customKey: [],
    className: "",
    randomKeys: false,
    popClass: "",
    onClose: () => {
    }
  };
  const NumberKeyboard = (props) => {
    const { locale } = useConfig$1();
    const {
      title,
      confirmText,
      visible,
      overlay,
      type,
      customKey,
      randomKeys,
      popClass,
      style,
      className,
      onChange,
      onDelete,
      onClose
    } = props;
    const b2 = cn("numberkeyboard");
    const [show, setShow] = React.useState(visible);
    const [clickKeyIndex, setClickKeyIndex] = React.useState(void 0);
    const [keysList, setKeysList] = React.useState([]);
    React.useEffect(() => {
      setShow(visible);
    }, [visible]);
    const defaultKey = () => {
      let leftBottomKey = {
        id: "lock",
        type: "lock"
      };
      if (customKey) {
        const customKeys = Array.isArray(customKey) ? customKey : [customKey];
        if (customKeys.length > 0) {
          const newCustomKey = customKeys[0];
          leftBottomKey = {
            id: newCustomKey,
            type: "custom"
          };
        }
      }
      return [
        ...getBasicKeys(),
        leftBottomKey,
        { id: 0, type: "number" },
        { id: "delete", type: "delete" }
      ];
    };
    const getBasicKeys = () => {
      const keys = [];
      for (let i = 1; i <= 9; i++) {
        keys.push({ id: i, type: "number" });
      }
      if (randomKeys) {
        return keys.sort(() => Math.random() > 0.5 ? 1 : -1);
      }
      return keys;
    };
    const genCustomKeys = () => {
      const keys = getBasicKeys();
      if (!customKey)
        return [];
      let customKeys = Array.isArray(customKey) ? customKey : [customKey];
      if (customKeys.length > 2) {
        customKeys = [customKeys[0], customKeys[1]];
      }
      if (customKeys.length === 2 && props.title && props.type !== "rightColumn") {
        customKeys = [customKeys[0]];
      }
      if (customKeys.length === 1) {
        if (props.title && props.type !== "rightColumn") {
          keys.push(
            { id: customKeys[0], type: "custom" },
            { id: 0, type: "number" },
            { id: "delete", type: "delete" }
          );
        } else {
          keys.push(
            { id: 0, type: "number" },
            { id: customKeys[0], type: "custom" }
          );
        }
      } else if (customKeys.length === 2) {
        keys.push(
          { id: customKeys[0], type: "custom" },
          { id: 0, type: "number" },
          { id: customKeys[1], type: "custom" }
        );
      }
      return keys;
    };
    React.useEffect(() => {
      if (props.type === "rightColumn" || props.title !== "") {
        setKeysList(genCustomKeys());
      } else {
        setKeysList(defaultKey());
      }
    }, []);
    const onTouchstart = (item, event) => {
      event.stopPropagation();
      setClickKeyIndex(item.id);
      if (item.type === "number" || item.type === "custom") {
        onChange && onChange(item.id);
      }
      if (item.type === "lock") {
        onClose && onClose();
      }
      if (item.type === "delete") {
        onDelete && onDelete();
      }
    };
    const onTouchMove = (event) => {
      event.stopPropagation();
    };
    const onTouchEnd = (event) => {
      event.preventDefault();
      setClickKeyIndex(void 0);
    };
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: show,
        overlay,
        position: "bottom",
        popClass,
        onClickOverlay: onClose,
        onClickCloseIcon: onClose,
        overlayStyle: { backgroundColor: "rgba(0, 0, 0, 0)" }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, style: { ...style } }, title ? /* @__PURE__ */ React.createElement("div", { className: b2("header") }, /* @__PURE__ */ React.createElement("h3", { className: b2("header__tit") }, title), type === "default" ? /* @__PURE__ */ React.createElement("span", { className: b2("header__close"), onClick: onClose }, locale.done) : null) : null, /* @__PURE__ */ React.createElement("div", { className: b2("body") }, /* @__PURE__ */ React.createElement("div", { className: b2("body__keys") }, keysList == null ? void 0 : keysList.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            key: index,
            className: classNames({
              "key-board-wrapper": true,
              "key-board-wrapper-large": item.id === 0 && type === "rightColumn" && Array.isArray(customKey) && customKey.length === 1
            })
          },
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: classNames({
                key: true,
                active: item.id === clickKeyIndex,
                lock: item.type === "lock",
                delete: item.type === "delete"
              }),
              onTouchStart: (event) => onTouchstart(item, event),
              onTouchMove,
              onTouchEnd
            },
            item.type === "number" || item.type === "custom" ? /* @__PURE__ */ React.createElement("div", null, item.id) : null,
            item.type === "lock" ? /* @__PURE__ */ React.createElement(
              "img",
              {
                src: "https://img11.360buyimg.com/imagetools/jfs/t1/146371/38/8485/738/5f606425Eca239740/14f4b4f5f20d8a68.png",
                alt: ""
              }
            ) : null,
            item.type === "delete" ? /* @__PURE__ */ React.createElement(
              "img",
              {
                src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png",
                alt: ""
              }
            ) : null
          )
        );
      })), type === "rightColumn" ? /* @__PURE__ */ React.createElement("div", { className: b2("sidebar") }, /* @__PURE__ */ React.createElement("div", { className: "key-board-wrapper" }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames({
            key: true,
            active: clickKeyIndex === "delete"
          }),
          onTouchStart: (event) => onTouchstart({ id: "delete", type: "delete" }, event),
          onTouchMove,
          onTouchEnd
        },
        /* @__PURE__ */ React.createElement(
          "img",
          {
            src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png",
            alt: ""
          }
        )
      )), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "key-board-wrapper key-board-finish",
          onClick: onClose
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: classNames({
              key: true,
              finish: true,
              activeFinsh: clickKeyIndex === "finish"
            })
          },
          confirmText || locale.done
        )
      )) : null))
    ));
  };
  NumberKeyboard.defaultProps = defaultProps$V;
  NumberKeyboard.displayName = "NutNumberKeyboard";
  const radioContext = {
    onChange: (val) => {
    }
  };
  const RadioContext = React.createContext(radioContext);
  const defaultProps$U = {
    value: null,
    textPosition: "right",
    onChange: (value) => {
    },
    direction: "vertical",
    options: []
  };
  const RadioGroup = React.forwardRef(
    (props, ref) => {
      const { children } = { ...defaultProps$U, ...props };
      cn("RadioGroup");
      const {
        className,
        value,
        onChange,
        textPosition,
        direction,
        options,
        ...rest
      } = props;
      const [val2State, setVal2State] = React.useState(value);
      React.useEffect(() => {
        setVal2State(value);
      }, [value]);
      function validateChildChecked(child) {
        if (val2State === null)
          return false;
        return val2State === child.props.value;
      }
      function validateChecked(value2) {
        if (val2State === null)
          return false;
        return val2State === value2;
      }
      function cloneChildren() {
        return React.Children.map(children, (child, index) => {
          const childChecked = validateChildChecked(child);
          if (child.type.displayName !== "NutRadio") {
            return React.cloneElement(child);
          }
          return React.cloneElement(child, {
            textPosition,
            checked: childChecked
            // onChange: handleChildChange,
          });
        });
      }
      const renderOptionsChildren = React.useCallback(() => {
        return options == null ? void 0 : options.map(({ label, value: value2, disabled, onChange: onChange2, ...rest2 }) => {
          const childChecked = validateChecked(value2);
          return /* @__PURE__ */ React.createElement(
            Radio,
            {
              key: value2 == null ? void 0 : value2.toString(),
              children: label,
              value: value2,
              disabled,
              onChange: onChange2,
              ...rest2,
              textPosition,
              checked: childChecked
            }
          );
        });
      }, [val2State, options]);
      return /* @__PURE__ */ React.createElement(
        RadioContext.Provider,
        {
          value: {
            onChange: (val) => {
              setVal2State(val);
              onChange && onChange(val);
            }
          }
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `nut-radiogroup nut-radiogroup--${props.direction} ${className || ""}`,
            ...rest
          },
          (options == null ? void 0 : options.length) ? renderOptionsChildren() : cloneChildren()
        )
      );
    }
  );
  RadioGroup.defaultProps = defaultProps$U;
  RadioGroup.displayName = "NutRadioGroup";
  const defaultProps$T = {
    ...ComponentDefaults,
    className: "",
    style: {},
    disabled: false,
    checked: false,
    shape: "round",
    value: "",
    textPosition: "right",
    iconName: "check-normal",
    iconActiveName: "check-checked",
    iconSize: 18,
    onChange: (e) => {
    }
  };
  const Radio = (props) => {
    const { children } = {
      ...defaultProps$T,
      ...props
    };
    const {
      className,
      disabled,
      checked,
      shape,
      textPosition,
      value,
      iconName,
      iconActiveName,
      iconSize,
      onChange,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = props;
    const componentName = "nut-radio";
    const [checkedStatement, setCheckedStatement] = React.useState(checked);
    const [valueStatement, setValueStatement] = React.useState(value);
    const [disabledStatement, setDisabledStatement] = React.useState(disabled);
    const context = React.useContext(RadioContext);
    React.useEffect(() => {
      setDisabledStatement(disabled);
      setValueStatement(value);
      setCheckedStatement(checked);
    }, [disabled, value, checked]);
    const renderLabel = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${componentName}__label ${disabledStatement ? `${componentName}__label--disabled` : ""}`
        },
        children
      );
    };
    const renderButton = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${componentName}__button ${!disabledStatement && checkedStatement && `${componentName}__button--active`} ${disabledStatement ? `${componentName}__button--disabled` : ""}`
        },
        children
      );
    };
    const color = () => {
      if (disabledStatement) {
        return "nut-radio__icon--disable";
      }
      if (checkedStatement) {
        return "nut-radio__icon";
      }
      return "nut-radio__icon--unchecked";
    };
    const renderIcon = () => {
      const { iconName: iconName2, iconSize: iconSize2, iconActiveName: iconActiveName2 } = props;
      return /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: !disabledStatement && checkedStatement ? iconActiveName2 : iconName2,
          size: iconSize2,
          className: color()
        }
      );
    };
    const reverseState = textPosition === "left";
    const renderRadioItem = () => {
      if (shape === "button") {
        return renderButton();
      }
      if (reverseState) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, renderLabel(), renderIcon());
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, renderIcon(), renderLabel());
    };
    const handleClick = (e) => {
      if (disabledStatement || checkedStatement)
        return;
      setCheckedStatement(!checkedStatement);
      onChange && onChange(e);
      context && context.onChange(valueStatement);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `nut-radio ${className} ${reverseState ? `${componentName}--reverse` : ""}`,
        onClick: handleClick,
        ...rest
      },
      renderRadioItem()
    );
  };
  Radio.defaultProps = defaultProps$T;
  Radio.displayName = "NutRadio";
  Radio.RadioGroup = RadioGroup;
  const defaultProps$S = {
    name: "",
    size: "",
    classPrefix: "nut-icon",
    fontClassName: "nutui-iconfont",
    color: "",
    tag: "i",
    onClick: (e) => {
    },
    className: ""
  };
  function pxCheck(value) {
    if (value === "") {
      return value;
    }
    if (Number.isNaN(Number(value))) {
      return String(value);
    }
    return `${value}px`;
  }
  function Icon(props) {
    const {
      name,
      size,
      classPrefix,
      color,
      tag,
      children,
      className,
      fontClassName,
      style,
      onClick,
      ...rest
    } = {
      ...defaultProps$S,
      ...props
    };
    const isImage = name ? name.indexOf("/") !== -1 : false;
    const type = isImage ? "img" : tag;
    const b2 = cn("icon");
    const handleClick = (e) => {
      if (onClick) {
        onClick(e);
      }
    };
    const hasSrc = () => {
      if (isImage)
        return { src: name };
      return {};
    };
    const styles = {};
    const checkedSize = pxCheck(size);
    if (checkedSize) {
      styles.width = styles.height = styles.fontSize = checkedSize;
    }
    return React.createElement(
      type,
      {
        className: isImage ? `${b2("img")} ${className || ""} ` : `${fontClassName} ${b2(null)} ${classPrefix}-${name} ${className || ""}`,
        style: {
          color,
          ...styles,
          ...style
        },
        ...rest,
        onClick: handleClick,
        ...hasSrc()
      },
      children
    );
  }
  Icon.defaultProps = defaultProps$S;
  Icon.displayName = "NutIcon";
  const defaultProps$R = {
    id: "",
    style: {},
    icon: null,
    iconSize: "20",
    msg: "",
    bottom: "30px",
    // center为false时生效，距离底部位置
    duration: 2,
    // 时长,duration为0则一直展示
    center: true,
    // toast是否居中展示
    type: "text",
    title: "",
    customClass: "",
    // 自定义样式名
    size: "base",
    // 设置字体大小，默认base,可选large\small\base
    textAlignCenter: true,
    // 文字是否居中显示,true为居中，false为left
    bgColor: "rgba(0, 0, 0, .8)",
    cover: false,
    // 是否展示透明遮罩层
    coverColor: "rgba(0, 0, 0, 0)",
    // 遮罩颜色设定
    closeOnClickOverlay: false,
    // 是否点击遮罩可关闭
    visible: false,
    onClose: () => {
    }
    // 未实现
  };
  const Toast = (props) => {
    const {
      children,
      id,
      style,
      icon,
      iconSize,
      msg,
      bottom,
      duration,
      center,
      type,
      title,
      customClass,
      size,
      textAlignCenter,
      bgColor,
      cover,
      coverColor,
      closeOnClickOverlay,
      visible,
      onClose,
      ...rest
    } = { ...defaultProps$R, ...props };
    let timer;
    const [openState, SetOpenState] = React.useState(false);
    React.useEffect(() => {
      if (visible) {
        SetOpenState(true);
        show();
      } else {
        hide();
      }
    }, [visible]);
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const hide = () => {
      SetOpenState(false);
      onClose();
    };
    const show = () => {
      clearTimer();
      if (duration) {
        timer = window.setTimeout(() => {
          hide();
        }, duration * 1e3);
      }
    };
    const clickCover = () => {
      if (closeOnClickOverlay) {
        hide();
      }
    };
    const toastBem = cn("toast");
    const hasIcon = () => {
      if (type !== "text") {
        return true;
      }
      return !!icon;
    };
    const iconName = () => {
      if (icon) {
        return icon;
      }
      return {
        success: "success",
        fail: "failure",
        warn: "tips",
        loading: "loading"
      }[type];
    };
    const classes = classNames({
      "nut-toast-center": center,
      "nut-toast-has-icon": icon,
      "nut-toast-cover": cover,
      "nut-toast-loading": type === "loading",
      [`${customClass}`]: true,
      [`nut-toast-${size}`]: true
    });
    return /* @__PURE__ */ React.createElement(React.Fragment, null, openState ? /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${toastBem()} ${classes}`,
        id,
        style: {
          bottom: center ? "auto" : `${bottom}`,
          backgroundColor: cover ? coverColor : "",
          ...style
        },
        onClick: () => {
          clickCover();
        }
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: toastBem("inner"),
          style: {
            textAlign: textAlignCenter ? "center" : "left",
            backgroundColor: bgColor
          }
        },
        hasIcon() ? /* @__PURE__ */ React.createElement("p", { className: toastBem("icon-wrapper") }, /* @__PURE__ */ React.createElement(Icon, { name: iconName(), color: "#ffffff", size: iconSize })) : null,
        title ? /* @__PURE__ */ React.createElement("div", { className: "nut-toast-title" }, title) : null,
        /* @__PURE__ */ React.createElement("span", { className: toastBem("text") }, msg)
      )
    ) : null);
  };
  Toast.defaultProps = defaultProps$R;
  Toast.displayName = "NutToast";
  const defaultProps$Q = {
    range: false,
    hiddenRange: false,
    hiddenTag: false,
    min: 0,
    max: 100,
    step: 1,
    modelValue: 0,
    vertical: false,
    marks: {}
  };
  let startValue;
  let currentValue;
  const Range = (props) => {
    const { locale } = useConfig$1();
    const {
      className,
      range,
      disabled,
      activeColor,
      inactiveColor,
      buttonColor,
      hiddenRange,
      hiddenTag,
      modelValue,
      button,
      vertical,
      marks,
      dragStart,
      dragEnd,
      onChange,
      onDragStart,
      onDragEnd,
      minDesc,
      maxDesc,
      curValueDesc
    } = { ...defaultProps$Q, ...props };
    let { min, max, step } = { ...defaultProps$Q, ...props };
    min = Number(min);
    max = Number(max);
    step = Number(step);
    const [buttonIndex, SetButtonIndex] = React.useState(0);
    const [initValue, SetInitValue] = React.useState();
    const [dragStatus, SetDragStatus] = React.useState("start");
    const touch = useTouch();
    const root2 = React.useRef(null);
    const [marksList, SetMarksList] = React.useState([]);
    const [show, SetShow] = React.useState(false);
    const [toastMsg, SetToastMsg] = React.useState("");
    const toastShow = (msg) => {
      SetToastMsg(msg);
      SetShow(true);
    };
    React.useEffect(() => {
      if (!range && typeof modelValue === "number") {
        if (modelValue < min || modelValue > max) {
          SetInitValue(0);
          toastShow(`${modelValue} ${locale.range.rangeText}`);
          return;
        }
        SetInitValue(modelValue);
      } else if (range && Array.isArray(modelValue) && [0, 1].every((i) => typeof modelValue[i] === "number")) {
        SetInitValue(modelValue);
      }
    }, [modelValue]);
    React.useEffect(() => {
      if (marks) {
        const marksKeys = Object.keys(marks);
        const list = marksKeys.map(parseFloat).sort((a, b2) => a - b2).filter((point) => point >= min && point <= max);
        SetMarksList(list);
      }
    }, [marks]);
    const scope = () => {
      return Number(max) - Number(min);
    };
    const classes = React.useCallback(() => {
      const prefixCls = "nut-range";
      return [
        prefixCls,
        `${disabled ? `${prefixCls}-disabled` : ""}`,
        `${vertical ? `${prefixCls}-vertical` : ""}`,
        `${!hiddenRange ? `${prefixCls}-show-number` : ""}`
      ].filter(Boolean).join(" ");
    }, [disabled, vertical, hiddenRange]);
    const containerClasses = React.useCallback(() => {
      const prefixCls = "nut-range-container";
      return [prefixCls, `${vertical ? `${prefixCls}-vertical` : ""}`, className].filter(Boolean).join(" ");
    }, [vertical, className]);
    const markClassName = React.useCallback(
      (mark) => {
        const classPrefix = "nut-range-mark";
        let lowerBound = Number(min);
        let upperBound = Number(max);
        if (range) {
          const [left, right] = modelValue;
          lowerBound = left;
          upperBound = right;
        } else {
          upperBound = modelValue;
        }
        const isActive = mark <= upperBound && mark >= lowerBound;
        return [
          `${classPrefix}-text`,
          `${isActive ? `${classPrefix}-text-active` : ""}`
        ].filter(Boolean).join(" ");
      },
      [range, modelValue, min, max]
    );
    const [rangeName, setRangeName] = React.useState(classes());
    const [containerName, setContainerName] = React.useState(containerClasses());
    React.useEffect(() => {
      setRangeName(classes());
      setContainerName(containerClasses());
    }, [classes, containerClasses]);
    const wrapperStyle = () => {
      return {
        background: inactiveColor
      };
    };
    const buttonStyle = () => {
      return {
        borderColor: buttonColor
      };
    };
    const isRange = (val) => {
      return !!range && Array.isArray(val);
    };
    const calcMainAxis = () => {
      const modelVal = initValue || initValue === 0 ? initValue : modelValue;
      if (isRange(modelVal)) {
        return `${(modelVal[1] - modelVal[0]) * 100 / scope()}%`;
      }
      return `${(modelVal - Number(min)) * 100 / scope()}%`;
    };
    const calcOffset = () => {
      const modelVal = initValue || initValue === 0 ? initValue : modelValue;
      if (isRange(modelVal)) {
        return `${(modelVal[0] - Number(min)) * 100 / scope()}%`;
      }
      return `0%`;
    };
    const barStyle = () => {
      if (vertical) {
        return {
          height: calcMainAxis(),
          top: calcOffset(),
          background: activeColor,
          transition: dragStatus ? "none" : void 0
        };
      }
      return {
        width: calcMainAxis(),
        left: calcOffset(),
        background: activeColor,
        transition: dragStatus ? "none" : void 0
      };
    };
    const marksStyle = (mark) => {
      let style = {
        left: `${(mark - Number(min)) / scope() * 100}%`
      };
      if (vertical) {
        style = {
          top: `${(mark - Number(min)) / scope() * 100}%`
        };
      }
      return style;
    };
    const tickStyle = (mark) => {
      let lowerBound = Number(min);
      let upperBound = Number(max);
      if (range) {
        const [left, right] = modelValue;
        lowerBound = left;
        upperBound = right;
      }
      const isActive = mark <= upperBound && mark >= lowerBound;
      const style = {
        background: !isActive ? inactiveColor : activeColor
      };
      return style;
    };
    const format = (value) => {
      value = Math.max(+min, Math.min(value, +max));
      return Math.round(value / +step) * +step;
    };
    const isSameValue = (newValue, oldValue) => {
      return JSON.stringify(newValue) === JSON.stringify(oldValue);
    };
    const handleOverlap = (value) => {
      if (value[0] > value[1]) {
        return value.slice(0).reverse();
      }
      return value;
    };
    const updateValue = (value, end) => {
      if (isRange(value)) {
        value = handleOverlap(value).map(format);
      } else {
        value = format(value);
      }
      const modelVal = initValue || initValue === 0 ? initValue : modelValue;
      if (!isSameValue(value, modelVal)) {
        SetInitValue(value);
      }
      if ((marks || end) && !isSameValue(value, startValue)) {
        onChange && onChange(value);
      }
    };
    const click = async (event) => {
      if (disabled || !root2.current) {
        return;
      }
      SetDragStatus("");
      const rect = await getRectByTaro(root2.current);
      let delta = (event.detail.x ? event.detail.x : event.clientX) - rect.left;
      let total = rect.width;
      if (vertical) {
        delta = (event.detail.y ? event.detail.y : event.clientY) - rect.top;
        total = rect.height;
      }
      const value = Number(min) + delta / total * scope();
      currentValue = initValue || initValue === 0 ? initValue : modelValue;
      if (isRange(currentValue)) {
        const [left, right] = currentValue;
        const middle = (left + right) / 2;
        if (value <= middle) {
          updateValue([value, right], true);
        } else {
          updateValue([left, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    const onTouchStart = (event) => {
      if (disabled) {
        return;
      }
      touch.start(event);
      currentValue = initValue || initValue === 0 ? initValue : modelValue;
      if (isRange(currentValue)) {
        startValue = currentValue.map(format);
      } else {
        startValue = format(currentValue);
      }
      SetDragStatus("start");
    };
    const onTouchMove = async (event) => {
      if (disabled || !root2.current) {
        return;
      }
      if (dragStatus === "start") {
        dragStart && dragStart();
        onDragStart && onDragStart();
      }
      touch.move(event);
      SetDragStatus("draging");
      const rect = await getRectByTaro(root2.current);
      let delta = touch.deltaX;
      let total = rect.width;
      let diff = delta / total * scope();
      if (vertical) {
        delta = touch.deltaY;
        total = rect.height;
        diff = delta / total * scope();
      }
      if (isRange(startValue)) {
        currentValue[buttonIndex] = startValue[buttonIndex] + diff;
      } else {
        currentValue = startValue + diff;
      }
      updateValue(currentValue);
    };
    const onTouchEnd = (event) => {
      if (disabled) {
        return;
      }
      if (dragStatus === "draging") {
        updateValue(currentValue, true);
        dragEnd && dragEnd();
        onDragEnd && onDragEnd();
      }
      SetDragStatus("");
    };
    const curValue = (idx) => {
      const modelVal = initValue || initValue === 0 ? initValue : modelValue;
      const value = typeof idx === "number" ? modelVal[idx] : modelVal;
      return value;
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${containerName}` }, !hiddenRange ? /* @__PURE__ */ React.createElement("div", { className: "min" }, minDesc || +min) : null, /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: root2,
        style: wrapperStyle(),
        className: `${rangeName}`,
        onClick: (e) => {
          click(e);
        }
      },
      marksList.length > 0 ? /* @__PURE__ */ React.createElement("div", { className: "nut-range-mark" }, marksList.map((marks2) => {
        return /* @__PURE__ */ React.createElement(
          "span",
          {
            key: marks2,
            className: markClassName(marks2),
            style: marksStyle(marks2)
          },
          marks2,
          /* @__PURE__ */ React.createElement("span", { className: "nut-range-tick", style: tickStyle(marks2) })
        );
      })) : null,
      /* @__PURE__ */ React.createElement("div", { className: "nut-range-bar", style: barStyle() }, range ? [0, 1].map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            role: "slider",
            key: index,
            className: `${index === 0 ? "nut-range-button-wrapper-left" : ""}
                  ${index === 1 ? "nut-range-button-wrapper-right" : ""}`,
            tabIndex: disabled ? -1 : 0,
            "aria-valuemin": +min,
            "aria-valuenow": curValue(index),
            "aria-valuemax": +max,
            "aria-orientation": vertical ? "vertical" : "horizontal",
            onTouchStart: (e) => {
              if (typeof index === "number") {
                SetButtonIndex(index);
              }
              onTouchStart(e);
            },
            onTouchMove: (e) => {
              onTouchMove(e);
            },
            onTouchEnd: (e) => {
              onTouchEnd();
            },
            onTouchCancel: (e) => {
              onTouchEnd();
            },
            onClick: (e) => {
              e.stopPropagation();
            }
          },
          button || /* @__PURE__ */ React.createElement("div", { className: "nut-range-button", style: buttonStyle() }, !hiddenTag ? /* @__PURE__ */ React.createElement("div", { className: "number" }, curValueDesc || curValue(index)) : null)
        );
      }) : /* @__PURE__ */ React.createElement(
        "div",
        {
          role: "slider",
          className: "nut-range-button-wrapper",
          tabIndex: disabled ? -1 : 0,
          "aria-valuemin": +min,
          "aria-valuenow": curValue(),
          "aria-valuemax": +max,
          "aria-orientation": vertical ? "vertical" : "horizontal",
          onTouchStart: (e) => {
            onTouchStart(e);
          },
          onTouchMove: (e) => {
            onTouchMove(e);
          },
          onTouchEnd: (e) => {
            onTouchEnd();
          },
          onTouchCancel: (e) => {
            onTouchEnd();
          },
          onClick: (e) => {
            e.stopPropagation();
          }
        },
        button || /* @__PURE__ */ React.createElement("div", { className: "nut-range-button", style: buttonStyle() }, !hiddenTag ? /* @__PURE__ */ React.createElement("div", { className: "number" }, curValueDesc || curValue()) : null)
      ))
    ), !hiddenRange ? /* @__PURE__ */ React.createElement("div", { className: "max" }, maxDesc || +max) : null, /* @__PURE__ */ React.createElement(
      Toast,
      {
        type: "text",
        visible: show,
        msg: toastMsg,
        onClose: () => {
          SetShow(false);
        }
      }
    ));
  };
  Range.defaultProps = defaultProps$Q;
  Range.displayName = "NutRange";
  const defaultProps$P = {
    ...ComponentDefaults,
    count: 5,
    modelValue: 0,
    minimizeValue: 0,
    iconSize: 18,
    activeColor: "",
    voidColor: "",
    checkedIcon: "star-fill-n",
    uncheckedIcon: "star-n",
    disabled: false,
    readonly: false,
    allowHalf: false,
    spacing: 14
  };
  const Rate = (props) => {
    const {
      className,
      style,
      count,
      modelValue,
      minimizeValue,
      iconSize,
      activeColor,
      voidColor,
      checkedIcon,
      uncheckedIcon,
      disabled,
      readonly,
      allowHalf,
      spacing,
      onChange,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$P,
      ...props
    };
    const b2 = cn("rate");
    const bi = cn("rate-item");
    const [countArray, setCountArray] = React.useState([1, 2, 3, 4, 5]);
    const [score, setScore] = React.useState(0);
    React.useEffect(() => {
      const tmp = [];
      for (let i = 1; i <= Number(count); i++) {
        tmp.push(i);
      }
      setCountArray(tmp);
    }, [count]);
    React.useEffect(() => {
      setScore(Math.max(Number(modelValue), Number(minimizeValue)));
    }, [modelValue]);
    const pxCheck2 = (value) => {
      return Number.isNaN(Number(value)) ? String(value) : `${value}px`;
    };
    const onClick = (e, index) => {
      e.preventDefault();
      e.stopPropagation();
      if (disabled || readonly)
        return;
      let value = 0;
      if (!(index === 1 && score === index)) {
        value = index;
      }
      value = Math.max(value, Number(minimizeValue));
      setScore(value);
      onChange && onChange(value);
    };
    const onHalfClick = (event, n) => {
      event.preventDefault();
      event.stopPropagation();
      const value = Math.max(Number(minimizeValue), n - 0.5);
      setScore(value);
      onChange && onChange(value);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(b2(), className), style }, countArray.map((n) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: bi(),
          key: n,
          onClick: (event) => onClick(event, n),
          style: { marginRight: pxCheck2(spacing) }
        },
        /* @__PURE__ */ React.createElement(
          Icon,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            size: iconSize,
            className: classNames(bi("icon"), {
              [bi("icon--disabled")]: disabled || n > score
            }),
            name: n <= score ? checkedIcon : uncheckedIcon,
            color: n <= score ? activeColor : voidColor
          }
        ),
        allowHalf && score > n - 1 && /* @__PURE__ */ React.createElement(
          Icon,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            onClick: (event) => onHalfClick(event, n),
            className: `${bi("icon")} ${bi("icon--half")}`,
            color: n <= score ? activeColor : voidColor,
            size: iconSize,
            name: checkedIcon
          }
        )
      );
    }));
  };
  Rate.defaultProps = defaultProps$P;
  Rate.displayName = "NutRate";
  const defaultProps$O = {
    ...ComponentDefaults,
    placeholder: "",
    shape: "square",
    disabled: false,
    maxLength: 9999,
    clearable: true,
    clearIconSize: "12px",
    align: "left",
    readonly: true,
    autoFocus: false,
    label: "",
    leftinIcon: /* @__PURE__ */ React.createElement(Icon$1, { name: "search", size: "12" })
  };
  const SearchBar = (props) => {
    const searchbarBem = cn("searchbar");
    const { locale } = useConfig$1();
    const searchRef = React.useRef(null);
    const [value, setValue] = React.useState(() => props.value);
    const {
      placeholder,
      shape,
      className,
      disabled,
      maxLength,
      clearable,
      clearIconSize,
      align,
      readOnly,
      autoFocus,
      label,
      actionText,
      leftinIcon,
      rightinIcon,
      leftoutIcon,
      rightoutIcon,
      onChange,
      onFocus,
      onBlur,
      onClear,
      onCancel,
      onSearch,
      onClickInput,
      onClickLeftinIcon,
      onClickLeftoutIcon,
      onClickRightinIcon,
      onClickRightoutIcon,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$O,
      ...props
    };
    const alignClass = `${align}`;
    const forceFocus = () => {
      const searchSelf = searchRef.current;
      searchSelf && searchSelf.focus();
    };
    const change = (event) => {
      const { value: value2 } = event.target;
      onChange && (onChange == null ? void 0 : onChange(value2, event));
      setValue(value2);
      value2 === "" && forceFocus();
    };
    const focus = (event) => {
      const { value: value2 } = event.target;
      onFocus && (onFocus == null ? void 0 : onFocus(value2, event));
    };
    const blur = (event) => {
      const searchSelf = searchRef.current;
      searchSelf && searchSelf.blur();
      const { value: value2 } = event.target;
      onBlur && (onBlur == null ? void 0 : onBlur(value2, event));
    };
    React.useEffect(() => {
      setValue(props.value);
    }, [props.value]);
    React.useEffect(() => {
      autoFocus && forceFocus();
    }, [autoFocus]);
    const renderField = () => {
      return /* @__PURE__ */ React.createElement(
        "input",
        {
          className: `${searchbarBem("input")}  ${searchbarBem(alignClass)} ${shape === "round" ? searchbarBem("round") : ""} ${clearable ? searchbarBem("input-clear") : ""}`,
          ref: searchRef,
          style: { ...props.style },
          value: value || "",
          placeholder: placeholder || locale.placeholder,
          disabled,
          readOnly,
          maxLength,
          onKeyPress: onKeypress,
          onChange: (e) => change(e),
          onFocus: (e) => focus(e),
          onBlur: (e) => blur(e),
          onClick: (e) => clickInput(e)
        }
      );
    };
    const clickInput = (e) => {
      onClickInput && onClickInput(e);
    };
    const renderLeftinIcon = () => {
      if (!leftinIcon)
        return null;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("leftin-icon")} ${searchbarBem("icon")}`,
          onClick: (e) => clickLeftIcon("in-left", e)
        },
        leftinIcon
      );
    };
    const renderLeftoutIcon = () => {
      if (!leftoutIcon)
        return null;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("leftout-icon")}`,
          onClick: (e) => clickLeftIcon("out-left", e)
        },
        leftoutIcon
      );
    };
    const clickLeftIcon = (flag, event) => {
      if (flag === "in-left") {
        onClickLeftinIcon && onClickLeftinIcon(value, event);
      } else {
        onClickLeftoutIcon && onClickLeftoutIcon(value, event);
      }
    };
    const renderRightinIcon = () => {
      if (!rightinIcon)
        return null;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("rightin-icon")} ${searchbarBem("icon")}`,
          onClick: (e) => clickRightIcon("in-right", e)
        },
        rightinIcon
      );
    };
    const renderRightoutIcon = () => {
      if (!rightoutIcon)
        return null;
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("rightout-icon")}`,
          onClick: (e) => clickRightIcon("out-right", e)
        },
        rightoutIcon
      );
    };
    const clickRightIcon = (flag, event) => {
      if (flag === "in-left") {
        onClickRightinIcon && onClickRightinIcon(value, event);
      } else {
        onClickRightoutIcon && onClickRightoutIcon(value, event);
      }
    };
    const handleClear = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("clear")} ${rightinIcon ? "pos-right" : ""}`,
          onClick: (e) => clearaVal(e)
        },
        /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "circle-close",
            size: clearIconSize,
            color: "#555"
          }
        )
      );
    };
    const clearaVal = (event) => {
      if (disabled || readOnly) {
        return;
      }
      setValue("");
      onClear && onClear(event);
      forceFocus();
    };
    const renderRightLabel = () => {
      if (actionText) {
        return /* @__PURE__ */ React.createElement("div", { className: searchbarBem("action-text"), onClick: search }, actionText);
      }
      return null;
    };
    const onKeypress = (e) => {
      if (e.key === "Enter" || e.keyCode === 13) {
        if (typeof e.cancelable !== "boolean" || e.cancelable) {
          e.preventDefault();
        }
        onSearch && onSearch(value);
      }
    };
    const search = () => {
      onSearch && onSearch(value);
    };
    const renderLabel = () => {
      if (label) {
        return /* @__PURE__ */ React.createElement("div", { className: searchbarBem("label") }, label);
      }
      return null;
    };
    const envClass = () => {
      return Taro.getEnv() === "WEB" ? "nut-searchbar-taro" : "";
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${searchbarBem()} ${envClass()} ${disabled ? searchbarBem("disabled") : ""}  ${className || ""}`,
        style: { ...props.style, background: props.background }
      },
      renderLeftoutIcon(),
      renderLabel(),
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${searchbarBem("content")}`,
          style: { background: props.inputBackground }
        },
        renderLeftinIcon(),
        /* @__PURE__ */ React.createElement("div", { className: "nut-searchbar__input-box" }, renderField()),
        renderRightinIcon(),
        clearable && value && handleClear()
      ),
      renderRightoutIcon(),
      renderRightLabel()
    );
  };
  SearchBar.defaultProps = defaultProps$O;
  SearchBar.displayName = "NutSearchBar";
  const defaultProps$N = {
    ...ComponentDefaults,
    title: "",
    desc: "",
    tips: "",
    visible: false,
    modelValue: "",
    errorMsg: "",
    noButton: true,
    closeOnClickOverlay: true,
    length: 6,
    // 1~6
    className: "",
    autoFocus: false,
    onChange: (value) => {
    },
    onOk: (value) => {
    },
    onCancel: () => {
    },
    onClose: () => {
    },
    onTips: () => {
    },
    onComplete: (value) => {
    }
  };
  const ShortPassword = (props) => {
    const { locale } = useConfig$1();
    const {
      title,
      desc,
      tips,
      visible,
      modelValue,
      errorMsg,
      noButton,
      closeOnClickOverlay,
      length,
      style,
      className,
      onChange,
      onOk,
      onTips,
      onCancel,
      onClose,
      onComplete,
      iconClassPrefix,
      iconFontClassName,
      autoFocus,
      ...reset
    } = props;
    const b2 = cn("shortpassword");
    const textInput = React.useRef(null);
    const range = (val) => {
      return Math.min(Math.max(4, val), 6);
    };
    const [innerVisible, setInnerVisible] = React.useState(visible);
    const [comLen, setComLen] = React.useState(range(Number(length)));
    const [inputValue, setInputValue] = React.useState("");
    React.useEffect(() => {
      setInnerVisible(visible);
    }, [visible]);
    React.useEffect(() => {
      if (typeof modelValue !== "undefined") {
        setInputValue(modelValue);
      }
    }, [modelValue]);
    const changeValue = (e) => {
      let inputValue2 = e.target.value;
      if (String(inputValue2).length > comLen) {
        inputValue2 = inputValue2.slice(0, comLen);
      }
      setInputValue(inputValue2);
      if (String(inputValue2).length === comLen) {
        onComplete && onComplete(inputValue2);
      }
      onChange && onChange(inputValue2);
    };
    const systemStyle = () => {
      const u = navigator.userAgent;
      const isAndroid = u.indexOf("Android") > -1 || u.indexOf("Linux") > -1;
      const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      let style2 = {};
      if (isIOS) {
        style2 = {
          paddingRight: "1200px"
        };
      }
      if (isAndroid) {
        style2 = {
          opacity: 0,
          zIndex: 10
        };
      }
      return style2;
    };
    const focus = () => {
      if (textInput.current) {
        textInput.current.focus();
      }
    };
    const sure = () => {
      onOk && onOk(inputValue);
    };
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(
      Popup,
      {
        style: {
          padding: "32px 24px 28px 24px",
          borderRadius: "12px",
          textAlign: "center"
        },
        visible: innerVisible,
        closeable: true,
        "close-on-click-overlay": closeOnClickOverlay,
        onClickOverlay: onClose,
        onClickCloseIcon: onClose
      },
      /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, style: { ...style }, ...reset }, /* @__PURE__ */ React.createElement("div", { className: b2("title") }, title || locale.shortpassword.title), /* @__PURE__ */ React.createElement("div", { className: b2("subtitle") }, desc || locale.shortpassword.desc), /* @__PURE__ */ React.createElement("div", { className: b2("input") }, /* @__PURE__ */ React.createElement(
        "input",
        {
          ref: textInput,
          className: b2("input-real"),
          type: "number",
          style: systemStyle(),
          maxLength: 6,
          pattern: "[0-9]*",
          value: inputValue,
          autoFocus,
          onChange: (e) => changeValue(e)
        }
      ), /* @__PURE__ */ React.createElement("div", { className: b2("input-site") }), /* @__PURE__ */ React.createElement("div", { className: b2("input-fake"), onClick: () => focus() }, [...new Array(comLen).keys()].map((item, index) => {
        return /* @__PURE__ */ React.createElement("div", { className: b2("input-fake__li"), key: index }, String(inputValue).length > index ? /* @__PURE__ */ React.createElement("div", { className: b2("input-fake__li__icon") }) : null);
      }))), /* @__PURE__ */ React.createElement("div", { className: b2("message") }, /* @__PURE__ */ React.createElement("div", { className: b2("message__error") }, errorMsg), tips || locale.shortpassword.tips ? /* @__PURE__ */ React.createElement("div", { className: b2("message__forget") }, /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          className: "icon",
          size: "11px",
          name: "tips"
        }
      ), /* @__PURE__ */ React.createElement("div", { onClick: onTips }, tips || locale.shortpassword.tips)) : null), !noButton ? /* @__PURE__ */ React.createElement("div", { className: b2("footer") }, /* @__PURE__ */ React.createElement("div", { className: b2("footer__cancel"), onClick: onCancel }, locale.cancel), /* @__PURE__ */ React.createElement("div", { className: b2("footer__sure"), onClick: () => sure() }, locale.confirm)) : null)
    ));
  };
  ShortPassword.defaultProps = defaultProps$N;
  ShortPassword.displayName = "NutShortPassword";
  const defaultProps$M = {
    defaultValue: "",
    textAlign: "left",
    limitshow: false,
    maxlength: "",
    rows: "",
    placeholder: "",
    readonly: false,
    disabled: false,
    autosize: false
  };
  const TextArea = (props) => {
    const { locale } = useConfig$1();
    const {
      className,
      defaultValue,
      textAlign,
      limitshow,
      maxlength,
      rows,
      placeholder,
      readonly,
      disabled,
      autosize,
      style,
      onChange,
      onBlur,
      onFocus
    } = { ...defaultProps$M, ...props };
    const textareaBem = cn("textarea");
    const [inputValue, SetInputValue] = React.useState("");
    const compositingRef = React.useRef(false);
    const [, updateState] = React.useState({});
    const forceUpdate = React.useCallback(() => updateState({}), []);
    React.useEffect(() => {
      let initValue = defaultValue;
      if (initValue && maxlength && [...initValue].length > Number(maxlength)) {
        initValue = initValue.substring(0, Number(maxlength));
      }
      SetInputValue(initValue);
    }, [defaultValue]);
    const textChange = (event) => {
      if (disabled)
        return;
      if (readonly)
        return;
      const text = event.detail ? event.detail : event.target;
      if (maxlength && [...text.value].length > Number(maxlength) && !compositingRef.current) {
        text.value = text.value.substring(0, Number(maxlength));
      }
      if (text.value === inputValue) {
        forceUpdate();
      } else {
        SetInputValue(text.value);
      }
      onChange && onChange(text.value, event);
    };
    const textFocus = (event) => {
      if (disabled)
        return;
      if (readonly)
        return;
      onFocus && onFocus(event);
    };
    const textBlur = (event) => {
      if (disabled)
        return;
      if (readonly)
        return;
      const text = event.detail ? event.detail : event.target;
      onChange && onChange(text.value, event);
      onBlur && onBlur(event);
    };
    const startComposing = () => {
      compositingRef.current = true;
    };
    const endComposing = () => {
      compositingRef.current = false;
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${textareaBem()} ${disabled ? textareaBem("disabled") : ""} ${className || ""}`
      },
      /* @__PURE__ */ React.createElement(
        "textarea",
        {
          className: textareaBem("textarea"),
          style: {
            textAlign,
            resize: `${autosize ? "vertical" : "none"}`,
            ...style
          },
          readOnly: disabled || readonly,
          value: inputValue,
          onInput: (e) => {
            textChange(e);
          },
          onChange: (e) => {
            textChange(e);
          },
          onBlur: (e) => {
            textBlur(e);
          },
          onFocus: (e) => {
            textFocus(e);
          },
          onCompositionEnd: (e) => endComposing(),
          onCompositionStart: (e) => startComposing(),
          rows,
          maxLength: maxlength < 0 ? 0 : maxlength,
          placeholder: placeholder || locale.placeholder
        }
      ),
      limitshow ? /* @__PURE__ */ React.createElement("div", { className: textareaBem("limit") }, [...inputValue].length, "/", maxlength < 0 ? 0 : maxlength) : null
    );
  };
  TextArea.defaultProps = defaultProps$M;
  TextArea.displayName = "NutTextArea";
  const defaultProps$L = {
    ...ComponentDefaults,
    className: "",
    style: {},
    isShowPercentage: true,
    percentage: 0,
    fillColor: "#f3f3f3",
    strokeColor: "linear-gradient(135deg, #fa2c19 0%, #fa6419 100%)",
    strokeWidth: "",
    textColor: "",
    textWidth: "",
    showText: true,
    textInside: false,
    textBackground: "linear-gradient(135deg, #fa2c19 0%, #fa6419 100%)",
    textType: "text",
    status: false,
    iconName: "checked",
    iconColor: "#439422",
    iconSize: "16px",
    children: void 0
  };
  const Progress = (props) => {
    const {
      className,
      style,
      isShowPercentage,
      percentage,
      fillColor,
      strokeColor,
      strokeWidth,
      size,
      textColor,
      textWidth,
      showText,
      textInside,
      textBackground,
      textType,
      status,
      iconName,
      iconColor,
      iconSize,
      children,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$L,
      ...props
    };
    const b2 = cn("progress");
    const classes = classNames(b2(""));
    const classesOuter = classNames({
      [`${b2("")}-outer`]: true,
      [`${b2("")}-${size || "base"}`]: true
    });
    const classesInner = classNames({
      [`${b2("")}-inner`]: true,
      [`${b2("")}-active`]: status
    });
    const classesText = classNames({
      [`${b2("")}-text`]: true
    });
    const classesInsideText = classNames({
      [`${b2("")}-text`]: true,
      [`${b2("")}-insidetext`]: true
    });
    const classesTextInner = classNames({
      [`${b2("")}-text__inner`]: true
    });
    const stylesOuter = {
      height: `${strokeWidth}px`,
      // eslint-disable-next-line no-nested-ternary
      background: `${fillColor}`
    };
    const stylesInner = {
      width: `${percentage}%`,
      // eslint-disable-next-line no-nested-ternary
      background: `${strokeColor}`
    };
    const stylesInsideText = {
      width: `${textWidth}px`,
      left: `${percentage}%`,
      background: textBackground || strokeColor
    };
    const stylesInsideIcon = {
      width: `${textWidth}px`,
      left: `${percentage}%`
    };
    const stylesText = {
      width: `${textWidth}px`
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${classes} ${className}`, style, ...rest }, /* @__PURE__ */ React.createElement("div", { className: classesOuter, style: stylesOuter }, /* @__PURE__ */ React.createElement("div", { className: classesInner, style: stylesInner }, showText && textInside && /* @__PURE__ */ React.createElement(React.Fragment, null, children ? /* @__PURE__ */ React.createElement("div", { className: classesInsideText, style: stylesInsideIcon }, children) : /* @__PURE__ */ React.createElement("div", { className: classesInsideText, style: stylesInsideText }, /* @__PURE__ */ React.createElement(
      "span",
      {
        className: classesTextInner,
        style: { color: textColor }
      },
      percentage,
      isShowPercentage ? "%" : ""
    ))))), showText && !textInside && /* @__PURE__ */ React.createElement("div", { className: classesText, style: stylesText }, textType === "text" && /* @__PURE__ */ React.createElement("span", { className: classesTextInner, style: { color: textColor } }, percentage, isShowPercentage ? "%" : ""), textType === "icon" && /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        size: iconSize,
        name: iconName,
        color: iconColor
      }
    )));
  };
  Progress.defaultProps = defaultProps$L;
  Progress.displayName = "NutProgress";
  class UploadOptions {
    constructor() {
      __publicField(this, "url", "");
      __publicField(this, "name", "file");
      __publicField(this, "fileType", "image");
      __publicField(this, "formData");
      __publicField(this, "sourceFile");
      __publicField(this, "method", "post");
      __publicField(this, "xhrState", 200);
      __publicField(this, "timeout", 30 * 1e3);
      __publicField(this, "headers", {});
      __publicField(this, "withCredentials", false);
      __publicField(this, "onStart");
      __publicField(this, "taroFilePath");
      __publicField(this, "onProgress");
      __publicField(this, "onSuccess");
      __publicField(this, "onFailure");
      __publicField(this, "beforeXhrUpload");
    }
  }
  class Upload {
    constructor(options) {
      __publicField(this, "options");
      this.options = options;
    }
    upload() {
      var _a;
      const { options } = this;
      const xhr = new XMLHttpRequest();
      xhr.timeout = options.timeout;
      if (xhr.upload) {
        xhr.upload.addEventListener(
          "progress",
          (e) => {
            var _a2;
            (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, e, options);
          },
          false
        );
        xhr.onreadystatechange = () => {
          var _a2, _b;
          if (xhr.readyState === 4) {
            if (xhr.status === options.xhrState) {
              (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, xhr.responseText, options);
            } else {
              (_b = options.onFailure) == null ? void 0 : _b.call(options, xhr.responseText, options);
            }
          }
        };
        xhr.withCredentials = options.withCredentials;
        xhr.open(options.method, options.url, true);
        for (const [key, value] of Object.entries(options.headers)) {
          xhr.setRequestHeader(key, value);
        }
        (_a = options.onStart) == null ? void 0 : _a.call(options, options);
        if (options.beforeXhrUpload) {
          options.beforeXhrUpload(xhr, options);
        } else {
          xhr.send(options.formData);
        }
      } else {
        console.warn("浏览器不支持 XMLHttpRequest");
      }
    }
  }
  class UploaderTaro extends Upload {
    constructor(options) {
      super(options);
    }
    uploadTaro(uploadFile, env) {
      var _a;
      const options = this.options;
      if (options.beforeXhrUpload) {
        options.beforeXhrUpload(uploadFile, options);
      } else {
        const uploadTask = uploadFile({
          url: options.url,
          filePath: options.taroFilePath,
          fileType: options.fileType,
          header: {
            "Content-Type": "multipart/form-data",
            ...options.headers
          },
          //
          formData: options.formData,
          name: options.name,
          success(response) {
            var _a2, _b;
            if (options.xhrState == response.statusCode) {
              (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, response, options);
            } else {
              (_b = options.onFailure) == null ? void 0 : _b.call(options, response, options);
            }
          },
          fail(e) {
            var _a2;
            (_a2 = options.onFailure) == null ? void 0 : _a2.call(options, e, options);
          }
        });
        (_a = options.onStart) == null ? void 0 : _a.call(options, options);
        uploadTask.progress(
          (res) => {
            var _a2;
            (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, res, options);
          }
        );
      }
    }
  }
  const isObject = (val) => val !== null && typeof val === "object";
  const isFunction = (val) => typeof val === "function";
  const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const funcInterceptor = (interceptor, {
    args = [],
    done,
    canceled
  }) => {
    if (interceptor) {
      const returnVal = interceptor.apply(null, args);
      if (isPromise(returnVal)) {
        returnVal.then((value) => {
          if (value) {
            done(value);
          } else if (canceled) {
            canceled();
          }
        }).catch(() => {
        });
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  };
  const defaultProps$K = {
    ...ComponentDefaults,
    url: "",
    maximum: 1,
    sizeType: ["original", "compressed"],
    sourceType: ["album", "camera"],
    mediaType: ["image", "video"],
    camera: "back",
    uploadIcon: "photograph",
    uploadIconSize: "",
    uploadIconTip: "",
    listType: "picture",
    name: "file",
    accept: "*",
    disabled: false,
    autoUpload: true,
    multiple: false,
    maximize: Number.MAX_VALUE,
    data: {},
    headers: {},
    method: "post",
    defaultImg: "",
    xhrState: 200,
    timeout: 1e3 * 30,
    isPreview: true,
    isDeletable: true,
    maxDuration: 10,
    onBeforeDelete: (file, files) => {
      return true;
    }
  };
  class FileItem {
    constructor() {
      __publicField(this, "status", "ready");
      __publicField(this, "message", "准备中..");
      __publicField(this, "uid", (/* @__PURE__ */ new Date()).getTime().toString());
      __publicField(this, "name");
      __publicField(this, "url");
      __publicField(this, "type");
      __publicField(this, "path");
      __publicField(this, "percentage", 0);
      __publicField(this, "formData", {});
    }
  }
  const InternalUploader = (props, ref) => {
    const { locale } = useConfig$1();
    const {
      children,
      uploadIcon,
      uploadIconSize,
      uploadIconTip,
      accept,
      name,
      camera,
      defaultFileList,
      listType,
      disabled,
      multiple,
      url,
      defaultImg,
      headers,
      timeout,
      method,
      xhrState,
      data,
      isPreview,
      isDeletable,
      maximum,
      maximize,
      mediaType,
      className,
      autoUpload,
      sizeType,
      sourceType,
      maxDuration,
      iconClassPrefix,
      iconFontClassName,
      onStart,
      onRemove,
      onChange,
      onFileItemClick,
      onProgress,
      onSuccess,
      onUpdate,
      onFailure,
      onOversize,
      onBeforeXhrUpload,
      onBeforeDelete,
      ...restProps
    } = { ...defaultProps$K, ...props };
    const [fileList, setFileList] = React.useState([]);
    const [uploadQueue, setUploadQueue] = React.useState([]);
    React.useEffect(() => {
      if (defaultFileList) {
        setFileList(defaultFileList);
      }
    }, [defaultFileList]);
    const b2 = cn("uploader");
    const classes = classNames(className, b2(""));
    React.useImperativeHandle(ref, () => ({
      submit: () => {
        Promise.all(uploadQueue).then((res) => {
          res.forEach((i) => i.uploadTaro(Taro.uploadFile, Taro.getEnv()));
        });
      },
      clear: () => {
        clearUploadQueue();
      }
    }));
    const clearUploadQueue = (index = -1) => {
      if (index > -1) {
        uploadQueue.splice(index, 1);
        setUploadQueue(uploadQueue);
      } else {
        setUploadQueue([]);
        fileList.splice(0, fileList.length);
        setFileList([...fileList]);
      }
    };
    const _chooseImage = () => {
      if (disabled) {
        return;
      }
      if (Taro.getEnv() == "WEB") {
        let el = document.getElementById("taroChooseImage");
        if (el) {
          el == null ? void 0 : el.setAttribute("accept", accept);
        } else {
          const obj = document.createElement("input");
          obj.setAttribute("type", "file");
          obj.setAttribute("id", "taroChooseImage");
          obj.setAttribute("accept", accept);
          obj.setAttribute(
            "style",
            "position: fixed; top: -4000px; left: -3000px; z-index: -300;"
          );
          document.body.appendChild(obj);
        }
      }
      if (Taro.getEnv() == "WEAPP") {
        Taro.chooseMedia({
          /** 最多可以选择的文件个数 */
          count: multiple ? maximum * 1 - fileList.length : 1,
          /** 文件类型 */
          mediaType,
          /** 图片和视频选择的来源 */
          sourceType,
          /** 拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 30s 之间 */
          maxDuration,
          /** 仅对 mediaType 为 image 时有效，是否压缩所选文件 */
          sizeType: [],
          /** 仅在 sourceType 为 camera 时生效，使用前置或后置摄像头 */
          camera,
          /** 接口调用失败的回调函数 */
          fail: (res) => {
            onFailure && onFailure(res);
          },
          /** 接口调用成功的回调函数 */
          success: onChangeMedia
        });
      } else {
        Taro.chooseImage({
          // 选择数量
          count: multiple ? maximum * 1 - fileList.length : 1,
          // 可以指定是原图还是压缩图，默认二者都有
          sizeType,
          sourceType,
          success: onChangeImage,
          fail: (res) => {
            onFailure && onFailure(res);
          }
        });
      }
    };
    const executeUpload = (fileItem, index) => {
      const uploadOption = new UploadOptions();
      uploadOption.name = name;
      uploadOption.url = url;
      uploadOption.fileType = fileItem.type;
      uploadOption.formData = fileItem.formData;
      uploadOption.timeout = timeout * 1;
      uploadOption.method = method;
      uploadOption.xhrState = xhrState;
      uploadOption.headers = headers;
      uploadOption.taroFilePath = fileItem.path;
      uploadOption.beforeXhrUpload = onBeforeXhrUpload;
      uploadOption.onStart = (option) => {
        clearUploadQueue(index);
        setFileList((fileList2) => {
          fileList2.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = "ready";
              item.message = locale.uploader.readyUpload;
            }
          });
          return [...fileList2];
        });
        onStart && onStart(option);
      };
      uploadOption.onProgress = (e, option) => {
        setFileList((fileList2) => {
          fileList2.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = "uploading";
              item.message = locale.uploader.uploading;
              item.percentage = e.progress;
              onProgress && onProgress({ e, option, percentage: item.percentage });
            }
          });
          return [...fileList2];
        });
      };
      uploadOption.onSuccess = (responseText, option) => {
        setFileList((fileList2) => {
          onUpdate && onUpdate(fileList2);
          fileList2.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = "success";
              item.message = locale.uploader.success;
            }
          });
          return [...fileList2];
        });
        onSuccess && onSuccess({
          responseText,
          option,
          fileList,
          file: fileItem
        });
      };
      uploadOption.onFailure = (responseText, option) => {
        setFileList((fileList2) => {
          fileList2.map((item) => {
            if (item.uid === fileItem.uid) {
              item.status = "error";
              item.message = locale.uploader.error;
            }
          });
          return [...fileList2];
        });
        onFailure && onFailure({
          responseText,
          option,
          fileList,
          file: fileItem
        });
      };
      const task = new UploaderTaro(uploadOption);
      if (props.autoUpload) {
        task.uploadTaro(Taro.uploadFile, Taro.getEnv());
      } else {
        uploadQueue.push(
          new Promise((resolve, reject) => {
            resolve(task);
          })
        );
        setUploadQueue(uploadQueue);
      }
    };
    const readFile = (files) => {
      files.forEach((file, index) => {
        var _a, _b;
        let fileType = file.type;
        let filepath = file.tempFilePath || file.path;
        const fileItem = new FileItem();
        if (file.fileType) {
          fileType = file.fileType;
        } else {
          const imgReg = /\.(png|jpeg|jpg|webp|gif)$/i;
          if (!fileType && (imgReg.test(filepath) || filepath.includes("data:image"))) {
            fileType = "image";
          }
        }
        fileItem.path = filepath;
        fileItem.name = filepath;
        fileItem.status = "ready";
        fileItem.type = fileType;
        if (autoUpload) {
          fileItem.message = locale.uploader.readyUpload;
        } else {
          fileItem.message = locale.uploader.waitingUpload;
        }
        if (Taro.getEnv() === "WEB") {
          const formData = new FormData();
          for (const [key, value] of Object.entries(data)) {
            formData.append(key, value);
          }
          formData.append(name, file.originalFileObj);
          fileItem.name = (_a = file.originalFileObj) == null ? void 0 : _a.name;
          fileItem.type = (_b = file.originalFileObj) == null ? void 0 : _b.type;
          fileItem.formData = formData;
        } else {
          fileItem.formData = data;
        }
        if (isPreview) {
          fileItem.url = fileType == "video" ? file.thumbTempFilePath : filepath;
        }
        fileList.push(fileItem);
        setFileList([...fileList]);
        executeUpload(fileItem, index);
      });
    };
    const filterFiles = (files) => {
      const maximum2 = props.maximum * 1;
      const maximize2 = props.maximize * 1;
      const oversizes = new Array();
      const filterFile = files.filter((file) => {
        if (file.size > maximize2) {
          oversizes.push(file);
          return false;
        }
        return true;
      });
      if (oversizes.length) {
        onOversize && onOversize(files);
      }
      const currentFileLength = filterFile.length + fileList.length;
      if (currentFileLength > maximum2) {
        filterFile.splice(filterFile.length - (currentFileLength - maximum2));
      }
      return filterFile;
    };
    const deleted = (file, index) => {
      fileList.splice(index, 1);
      onRemove && onRemove(file, fileList);
      setFileList([...fileList]);
    };
    const onDelete = (file, index) => {
      clearUploadQueue(index);
      funcInterceptor(onBeforeDelete, {
        args: [file, fileList],
        done: () => deleted(file, index)
      });
    };
    const onChangeMedia = (res) => {
      const { tempFiles } = res;
      const _files = filterFiles(tempFiles);
      readFile(_files);
      onChange && onChange({ fileList });
    };
    const onChangeImage = (res) => {
      const { tempFiles } = res;
      const _files = filterFiles(tempFiles);
      readFile(_files);
      onChange && onChange({ fileList });
    };
    const handleItemClick = (file) => {
      onFileItemClick && onFileItemClick(file);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, children && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__slot" }, /* @__PURE__ */ React.createElement(React.Fragment, null, children, maximum > fileList.length && /* @__PURE__ */ React.createElement(Button, { className: "nut-uploader__input", onClick: _chooseImage }))), fileList.length !== 0 && fileList.map((item, index) => {
      return /* @__PURE__ */ React.createElement("div", { className: `nut-uploader__preview ${listType}`, key: item.uid }, listType === "picture" && !children && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview-img" }, isDeletable && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          color: "rgba(0,0,0,0.6)",
          className: "close",
          name: "failure",
          onClick: () => onDelete(item, index)
        }
      ), item.status === "ready" ? /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview__progress" }, /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview__progress__msg" }, item.message)) : item.status !== "success" && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview__progress" }, item.failIcon === " " || item.loadingIcon === " " ? null : /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          color: "#fff",
          name: `${item.status === "error" ? `${item.failIcon || "failure"}` : `${item.loadingIcon || "loading"}`}`
        }
      ), /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview__progress__msg" }, item.message)), item.type.includes("image") ? /* @__PURE__ */ React.createElement(React.Fragment, null, item.url && /* @__PURE__ */ React.createElement(
        components.Image,
        {
          className: "nut-uploader__preview-img__c",
          mode: "aspectFit",
          src: item.url,
          onClick: () => handleItemClick(item)
        }
      )) : /* @__PURE__ */ React.createElement(React.Fragment, null, defaultImg ? /* @__PURE__ */ React.createElement(
        components.Image,
        {
          className: "nut-uploader__preview-img__c",
          mode: "aspectFit",
          src: defaultImg,
          onClick: () => handleItemClick(item)
        }
      ) : /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview-img__file" }, /* @__PURE__ */ React.createElement(
        "div",
        {
          onClick: () => handleItemClick(item),
          className: "nut-uploader__preview-img__file__name"
        },
        /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            color: "#808080",
            name: "link"
          }
        ),
        " ",
        item.name
      ))), item.status === "success" ? /* @__PURE__ */ React.createElement("div", { className: "tips" }, item.name) : null), listType === "list" && /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__preview-list" }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `nut-uploader__preview-img__file__name ${item.status}`,
          onClick: () => handleItemClick(item)
        },
        /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "link"
          }
        ),
        " ",
        item.name
      ), isDeletable && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          color: "#808080",
          className: "nut-uploader__preview-img__file__del",
          name: "del",
          onClick: () => onDelete(item, index)
        }
      ), item.status === "uploading" && /* @__PURE__ */ React.createElement(
        Progress,
        {
          size: "small",
          percentage: item.percentage,
          strokeColor: "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
          showText: false
        }
      )));
    }), maximum > fileList.length && listType === "picture" && !children && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `nut-uploader__upload ${listType} ${disabled ? "nut-uploader__upload-disabled" : ""}`
      },
      /* @__PURE__ */ React.createElement("div", { className: "nut-uploader__icon" }, /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          size: uploadIconSize,
          color: "#808080",
          name: uploadIcon
        }
      ), /* @__PURE__ */ React.createElement("span", { className: "nut-uploader__icon-tip" }, uploadIconTip)),
      /* @__PURE__ */ React.createElement(Button, { className: "nut-uploader__input", onClick: _chooseImage })
    ));
  };
  const Uploader = React.forwardRef(InternalUploader);
  Uploader.defaultProps = defaultProps$K;
  Uploader.displayName = "NutUploader";
  const defaultProps$J = {
    cancelTxt: "",
    optionTag: "name",
    optionSubTag: "subname",
    chooseTagValue: "",
    title: "",
    color: "#ee0a24",
    description: "",
    menuItems: [],
    onCancel: () => {
    },
    onChoose: () => {
    },
    visible: false,
    className: "",
    style: {}
  };
  const ActionSheet = (props) => {
    const {
      children,
      cancelTxt,
      optionTag,
      optionSubTag,
      chooseTagValue,
      title,
      color,
      description,
      menuItems,
      onCancel,
      onChoose,
      visible,
      className,
      style,
      ...rest
    } = { ...defaultProps$J, ...props };
    const b2 = cn("actionsheet");
    const isHighlight = (item) => {
      return props.chooseTagValue && props.chooseTagValue === item[props.optionTag || "name"] ? props.color : "#1a1a1a";
    };
    const cancelActionSheet = () => {
      onCancel && onCancel();
    };
    const chooseItem = (item, index) => {
      if (!item.disable) {
        onChoose && onChoose(item, index);
      }
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        round: true,
        visible,
        position: "bottom",
        onClose: () => {
          onCancel && onCancel();
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, style, ...rest }, title && /* @__PURE__ */ React.createElement("div", { className: b2("title") }, title), description && /* @__PURE__ */ React.createElement("div", { className: `${b2("item")} desc` }, description), menuItems.length ? /* @__PURE__ */ React.createElement("div", { className: b2("menu") }, menuItems.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2("item")} ${item.disable ? b2("item-disabled") : ""}`,
            style: { color: isHighlight(item) },
            key: index,
            onClick: () => chooseItem(item, index)
          },
          item[optionTag],
          /* @__PURE__ */ React.createElement("div", { className: "subdesc" }, item[optionSubTag])
        );
      })) : children, cancelTxt && /* @__PURE__ */ React.createElement("div", { className: b2("cancel"), onClick: () => cancelActionSheet() }, cancelTxt))
    );
  };
  ActionSheet.defaultProps = defaultProps$J;
  ActionSheet.displayName = "NutActionSheet";
  const defaultProps$I = {
    ...ComponentDefaults,
    bottom: 20,
    right: 10,
    elId: "body",
    distance: 200,
    zIndex: 10,
    isAnimation: true,
    duration: 1e3
  };
  const BackTop = (props) => {
    const {
      children,
      bottom,
      right,
      elId,
      distance,
      zIndex,
      isAnimation,
      className,
      duration,
      style,
      onClick,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$I,
      ...props
    };
    const [backTop, SetBackTop] = React.useState(false);
    Taro.usePageScroll((res) => {
      const { scrollTop } = res;
      scrollTop >= distance ? SetBackTop(true) : SetBackTop(false);
    });
    const goTop = (e) => {
      onClick && onClick(e);
      Taro.pageScrollTo({
        scrollTop: 0,
        duration: isAnimation && duration > 0 ? duration : 0
      });
    };
    const backTopClass = {
      right: `${right}px`,
      bottom: `${bottom}px`,
      zIndex
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `nut-backtop ${backTop ? "show" : ""} ${className || ""}`,
        style: { ...backTopClass, ...style },
        onClick: (e) => {
          goTop(e);
        }
      },
      children || /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          size: "19px",
          className: "nut-backtop-main",
          name: "top"
        }
      )
    ));
  };
  BackTop.defaultProps = defaultProps$I;
  BackTop.displayName = "NutBackTop";
  const Content = (props) => {
    const {
      visible,
      title,
      footer,
      textAlign,
      footerDirection,
      onClickSelf,
      children
    } = props;
    let headerNode;
    if (title) {
      headerNode = /* @__PURE__ */ React.createElement("div", { className: "nut-dialog__header" }, title);
    }
    let footerNode;
    if (footer) {
      footerNode = /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames("nut-dialog__footer", {
            [footerDirection]: footerDirection
          })
        },
        footer
      );
    }
    const handleClick = () => {
      onClickSelf && onClickSelf();
    };
    return /* @__PURE__ */ React.createElement("div", { className: "nut-dialog__outer", onClick: handleClick }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-dialog",
        style: { display: visible ? "flex" : "none" }
      },
      headerNode,
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-dialog__content",
          style: { textAlign }
        },
        /* @__PURE__ */ React.createElement("div", null, children)
      ),
      footerNode
    ));
  };
  Content.displayName = "NutContent";
  function Mask(props) {
    return /* @__PURE__ */ React__namespace.createElement("div", { className: "nut-dialog__mask" });
  }
  const DialogWrap = (props) => {
    const {
      className,
      style,
      visible,
      mask,
      closeOnClickOverlay,
      lockScroll,
      onClosed,
      onCancel
    } = props;
    const handleClick = (e) => {
      if (closeOnClickOverlay && visible && e.target === e.currentTarget) {
        onClosed == null ? void 0 : onClosed();
        onCancel == null ? void 0 : onCancel();
        lockScroll && document.body.classList.remove("nut-overflow-hidden");
      }
    };
    const wrapStyle = {
      ...style,
      display: visible ? "block" : "none"
    };
    if (lockScroll && visible) {
      document.body.classList.add("nut-overflow-hidden");
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, mask ? /* @__PURE__ */ React.createElement(
      CSSTransition$1,
      {
        in: visible,
        timeout: 300,
        classNames: "fadeDialog",
        unmountOnExit: true,
        appear: true
      },
      /* @__PURE__ */ React.createElement(Mask, null)
    ) : null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames("nut-dialog__wrap", className),
        onClick: handleClick,
        style: wrapStyle
      },
      /* @__PURE__ */ React.createElement(Content, { ...props, visible })
    ));
  };
  DialogWrap.displayName = "NutDialogWrap";
  const DialogWrapper = (props) => {
    const { visible, lockScroll } = props;
    return /* @__PURE__ */ React.createElement(
      components.View,
      {
        style: { display: visible ? "block" : "none" },
        catchMove: lockScroll
      },
      /* @__PURE__ */ React.createElement(DialogWrap, { ...props })
    );
  };
  DialogWrapper.displayName = "NutDialogWrapper";
  const defaultProps$H = {
    okText: "",
    cancelText: "",
    mask: true,
    closeOnClickOverlay: true,
    noFooter: false,
    noOkBtn: false,
    noCancelBtn: false,
    okBtnDisabled: false,
    cancelAutoClose: true,
    textAlign: "center",
    footerDirection: "horizontal",
    lockScroll: false
  };
  const BaseDialog = React.forwardRef(
    (props, ref) => {
      const { locale } = useConfig$1();
      const {
        visible,
        footer,
        noOkBtn,
        noCancelBtn,
        lockScroll,
        okBtnDisabled,
        cancelAutoClose,
        okText,
        cancelText,
        onClosed,
        onCancel,
        onOk,
        ...restProps
      } = props;
      const renderFooter = function() {
        if (footer === null)
          return "";
        const handleCancel = function(e) {
          e.stopPropagation();
          if (!cancelAutoClose)
            return;
          onClosed == null ? void 0 : onClosed();
          onCancel == null ? void 0 : onCancel();
          if (lockScroll && visible) {
            document.body.classList.remove("nut-overflow-hidden");
          }
        };
        const handleOk = function(e) {
          e.stopPropagation();
          onClosed == null ? void 0 : onClosed();
          onOk == null ? void 0 : onOk(e);
          if (lockScroll && visible) {
            document.body.classList.remove("nut-overflow-hidden");
          }
        };
        const footerContent = footer || /* @__PURE__ */ React.createElement(React.Fragment, null, !noCancelBtn && /* @__PURE__ */ React.createElement(
          Button,
          {
            size: "small",
            plain: true,
            type: "primary",
            className: "nut-dialog__footer-cancel",
            onClick: (e) => handleCancel(e)
          },
          cancelText || locale.cancel
        ), !noOkBtn && /* @__PURE__ */ React.createElement(
          Button,
          {
            size: "small",
            type: "primary",
            className: classNames("nut-dialog__footer-ok", {
              disabled: okBtnDisabled
            }),
            disabled: okBtnDisabled,
            onClick: (e) => handleOk(e)
          },
          okText || locale.confirm
        ));
        return footerContent;
      };
      return /* @__PURE__ */ React.createElement(
        DialogWrapper,
        {
          ...restProps,
          visible,
          lockScroll,
          footer: renderFooter(),
          onClosed,
          onCancel
        }
      );
    }
  );
  BaseDialog.defaultProps = defaultProps$H;
  BaseDialog.displayName = "NutDialog";
  const defaultProps$G = {
    attract: false,
    direction: void 0,
    boundary: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    className: "myDrag"
  };
  const Drag = (props) => {
    const { attract, direction, boundary, children, className, style, ...reset } = {
      ...defaultProps$G,
      ...props
    };
    const b2 = cn("drag");
    const [boundaryState, setBoundaryState] = React.useState(boundary);
    const myDrag = React.useRef(null);
    const dragRef = React.useRef(null);
    const [currstyle, setCurrStyle] = React.useState({});
    const timer = React.useRef(0);
    const axisCache = React.useRef({ x: 0, y: 0 });
    const transformCache = React.useRef({ x: 0, y: 0 });
    const translateX = React.useRef(0);
    const translateY = React.useRef(0);
    const middleLine = React.useRef(0);
    const getInfo = () => {
      const el = myDrag.current;
      if (el) {
        const { top, left, bottom, right } = boundary;
        const { screenWidth, windowHeight } = Taro.getSystemInfoSync();
        Taro.createSelectorQuery().select(`.${className}`).boundingClientRect((rec) => {
          setBoundaryState({
            top: -rec.top + top,
            left: -rec.left + left,
            bottom: windowHeight - rec.height - rec.top - bottom,
            right: screenWidth - rec.width - rec.left - right
          });
          middleLine.current = screenWidth - rec.width - rec.left - (screenWidth - rec.width) / 2;
        }).exec();
      }
    };
    const touchStart = (e) => {
      e.currentTarget;
      const touches = e.touches[0];
      axisCache.current = { x: touches.clientX, y: touches.clientY };
      transformCache.current = { x: translateX.current, y: translateY.current };
    };
    const touchMove = (e) => {
      if (e.touches.length === 1 && dragRef.current) {
        const touch = e.touches[0];
        const x = touch.clientX - axisCache.current.x;
        const y = touch.clientY - axisCache.current.y;
        translateX.current = x + transformCache.current.x;
        translateY.current = y + transformCache.current.y;
        if (translateX.current < boundaryState.left) {
          translateX.current = boundaryState.left;
        } else if (translateX.current > boundaryState.right) {
          translateX.current = boundaryState.right;
        }
        if (translateY.current < boundaryState.top) {
          translateY.current = boundaryState.top;
        } else if (translateY.current > boundaryState.bottom) {
          translateY.current = boundaryState.bottom;
        }
        const transform = `translate3d(${props.direction !== "y" ? translateX.current : 0}px, ${props.direction !== "x" ? translateY.current : 0}px, 0px)`;
        setCurrStyle({ transform });
      }
    };
    const touchEnd = (e) => {
      if (props.direction !== "y" && props.attract && dragRef.current) {
        if (translateX.current < middleLine.current) {
          translateX.current = boundaryState.left;
        } else {
          translateX.current = boundaryState.right;
        }
        const transform = `translate3d(${translateX.current}px, ${props.direction !== "x" ? translateY.current : 0}px, 0px)`;
        setCurrStyle({ transform });
      }
    };
    React.useEffect(() => {
      timer.current = window.setTimeout(() => {
        getInfo();
      }, 300);
      return () => {
        clearTimeout(timer.current);
      };
    }, []);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        style,
        className: `${b2()} ${className}`,
        ...reset,
        ref: myDrag
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          onTouchStart: (event) => touchStart(event),
          ref: dragRef,
          onTouchMove: touchMove,
          onTouchEnd: touchEnd,
          style: currstyle
        },
        children
      )
    );
  };
  Drag.defaultProps = defaultProps$G;
  Drag.displayName = "NutDrag";
  const defaultProps$F = {
    ...ComponentDefaults,
    hasMore: true,
    upperThreshold: 40,
    containerId: "",
    isOpenRefresh: false,
    pullIcon: "https://img10.360buyimg.com/imagetools/jfs/t1/169863/6/4565/6306/60125948E7e92774e/40b3a0cf42852bcb.png",
    pullTxt: "松开刷新",
    loadIcon: "https://img10.360buyimg.com/imagetools/jfs/t1/169863/6/4565/6306/60125948E7e92774e/40b3a0cf42852bcb.png",
    loadTxt: "加载中···",
    loadMoreTxt: "哎呀，这里是底部了啦"
  };
  const Infiniteloading = (props) => {
    const { locale } = useConfig$1();
    const {
      children,
      hasMore,
      upperThreshold,
      containerId,
      isOpenRefresh,
      pullIcon,
      pullTxt,
      loadIcon,
      loadTxt,
      loadMoreTxt,
      className,
      onRefresh,
      onLoadMore,
      onScrollChange,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$F,
      ...props
    };
    const [isInfiniting, setIsInfiniting] = React.useState(false);
    const [topDisScoll, setTopDisScoll] = React.useState(0);
    const refreshTop = React.useRef(null);
    const scrollHeight = React.useRef(0);
    const scrollTop = React.useRef(0);
    const direction = React.useRef("down");
    const isTouching = React.useRef(false);
    const y = React.useRef(0);
    const refreshMaxH = React.useRef(0);
    const distance = React.useRef(0);
    const b2 = cn("infiniteloading");
    const classes = classNames(className, b2());
    React.useEffect(() => {
      refreshMaxH.current = upperThreshold;
      setTimeout(() => {
        getScrollHeight();
      }, 200);
    }, [hasMore, isInfiniting]);
    const getScrollHeight = () => {
      const parentElement = getParentElement("scroller");
      parentElement.boundingClientRect((rect) => {
        scrollHeight.current = Array.isArray(rect) ? rect[0].height : rect.height;
      }).exec();
    };
    const getStyle = () => {
      return {
        height: topDisScoll < 0 ? `0px` : `${topDisScoll}px`,
        transition: `height 0.2s cubic-bezier(0.25,0.1,0.25,1)`
      };
    };
    const getParentElement = (el) => {
      return Taro.createSelectorQuery().select(
        containerId ? `#${containerId} #${el}` : `#${el}`
      );
    };
    const infiniteDone = () => {
      setIsInfiniting(false);
    };
    const refreshDone = () => {
      distance.current = 0;
      setTopDisScoll(0);
      isTouching.current = false;
    };
    const scrollAction = (e) => {
      if (e.detail.scrollTop <= 0) {
        e.detail.scrollTop = 0;
      } else if (e.detail.scrollTop >= scrollHeight.current) {
        e.detail.scrollTop = scrollHeight.current;
      }
      if (e.detail.scrollTop > scrollTop.current || e.detail.scrollTop >= scrollHeight.current) {
        direction.current = "down";
      } else {
        direction.current = "up";
      }
      scrollTop.current = e.detail.scrollTop;
      onScrollChange && onScrollChange(e.detail.scrollTop);
    };
    const lower = () => {
      if (direction.current == "up" || !hasMore || isInfiniting) {
        return false;
      }
      setIsInfiniting(true);
      onLoadMore && onLoadMore(infiniteDone);
    };
    const touchStart = (event) => {
      if (scrollTop.current == 0 && !isTouching.current && isOpenRefresh) {
        y.current = event.touches[0].pageY;
        isTouching.current = true;
      }
    };
    const touchMove = (event) => {
      distance.current = event.touches[0].pageY - y.current;
      if (distance.current > 0 && isTouching.current) {
        event.preventDefault();
        setTopDisScoll(distance.current);
        if (distance.current >= refreshMaxH.current) {
          distance.current = refreshMaxH.current;
          setTopDisScoll(refreshMaxH.current);
        }
      } else {
        distance.current = 0;
        setTopDisScoll(0);
        isTouching.current = false;
      }
    };
    const touchEnd = () => {
      if (distance.current < refreshMaxH.current) {
        distance.current = 0;
        setTopDisScoll(0);
      } else {
        onRefresh && onRefresh(refreshDone);
      }
    };
    return /* @__PURE__ */ React.createElement(
      components.ScrollView,
      {
        className: classes,
        scrollY: true,
        id: "scroller",
        style: { height: "100%" },
        onScroll: scrollAction,
        onScrollToLower: lower,
        onTouchStart: touchStart,
        onTouchMove: touchMove,
        onTouchEnd: touchEnd
      },
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-top", ref: refreshTop, style: getStyle() }, /* @__PURE__ */ React.createElement("div", { className: "top-box" }, /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          className: "top-img",
          name: pullIcon
        }
      ), /* @__PURE__ */ React.createElement("span", { className: "top-text" }, pullTxt || locale.infiniteloading.pullRefreshText))),
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-container" }, children),
      /* @__PURE__ */ React.createElement("div", { className: "nut-infinite-bottom" }, isInfiniting ? /* @__PURE__ */ React.createElement("div", { className: "bottom-box" }, /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          className: "bottom-img",
          name: loadIcon
        }
      ), /* @__PURE__ */ React.createElement("div", { className: "bottom-text" }, loadTxt || locale.infiniteloading.loadText)) : !hasMore && /* @__PURE__ */ React.createElement("div", { className: "tips" }, loadMoreTxt || locale.infiniteloading.loadMoreText))
    );
  };
  Infiniteloading.defaultProps = defaultProps$F;
  Infiniteloading.displayName = "NutInfiniteloading";
  const defaultProps$E = {
    id: "",
    msg: "",
    color: "",
    duration: 3e3,
    // 时长
    type: "danger",
    className: "",
    background: "",
    position: "top",
    isWrapTeleport: true,
    visible: false,
    onClosed: () => {
    },
    onClick: () => {
    }
  };
  const Notify = (props) => {
    const {
      id,
      children,
      style,
      msg,
      color,
      background,
      type,
      className,
      position,
      isWrapTeleport,
      visible,
      duration,
      onClosed,
      onClick,
      ...rest
    } = { ...defaultProps$E, ...props };
    let timer;
    const [showNotify, SetShow] = React.useState(false);
    React.useEffect(() => {
      if (visible) {
        SetShow(true);
        show();
      } else {
        hide();
      }
    }, [visible]);
    const clickHandle = () => {
      onClick();
    };
    const show = () => {
      clearTimer();
      if (duration) {
        timer = window.setTimeout(() => {
          hide();
        }, duration);
      }
    };
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const hide = () => {
      SetShow(false);
      if (id) {
        const element = document.getElementById(id);
        element && element.parentNode && element.parentNode.removeChild(element);
      }
      onClosed();
    };
    cn("notify");
    const classes = classNames({
      "nut-notify--popup-top": position === "top",
      "nut-notify--popup-bottom": position === "bottom",
      "nut-notify": true,
      [`nut-notify--${type}`]: true
    });
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      CSSTransition$1,
      {
        in: showNotify,
        timeout: 300,
        classNames: "fade",
        unmountOnExit: true,
        appear: true,
        position,
        id
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${classes} ${className}`,
          style: {
            color: `${color || ""}`,
            background: `${background || ""}`
          },
          onClick: clickHandle
        },
        children || msg
      )
    ));
  };
  Notify.defaultProps = defaultProps$E;
  Notify.displayName = "NutNotify";
  function clamp$1(v, min, max) {
    return Math.max(min, Math.min(v, max));
  }
  const V = {
    toVector(v, fallback) {
      if (v === void 0)
        v = fallback;
      return Array.isArray(v) ? v : [v, v];
    },
    add(v1, v2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    },
    sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    },
    addTo(v1, v2) {
      v1[0] += v2[0];
      v1[1] += v2[1];
    },
    subTo(v1, v2) {
      v1[0] -= v2[0];
      v1[1] -= v2[1];
    }
  };
  function rubberband$1(distance, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity)
      return Math.pow(distance, constant * 5);
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds$1(position, min, max, constant = 0.15) {
    if (constant === 0)
      return clamp$1(position, min, max);
    if (position < min)
      return -rubberband$1(min - position, max - min, constant) + min;
    if (position > max)
      return +rubberband$1(position - max, max - min, constant) + max;
    return position;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds$1(Vx, X0, X1, Rx), rubberbandIfOutOfBounds$1(Vy, Y0, Y1, Ry)];
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  const EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string) {
    if (!string)
      return "";
    return string[0].toUpperCase() + string.slice(1);
  }
  const actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop) {
    let eventKey = prop.substring(2).toLowerCase();
    const passive = !!~eventKey.indexOf("passive");
    if (passive)
      eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture)
      eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event))
      return "touch";
    if ("pointerType" in event)
      return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e) => {
      var _event$currentTarget, _event$currentTarget$;
      return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
    });
  }
  function getTouchList(event) {
    return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
  }
  function getValueEvent(event) {
    return isTouch(event) ? getTouchList(event)[0] : event;
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function pointerId(event) {
    const valueEvent = getValueEvent(event);
    return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
  }
  function pointerValues(event) {
    const valueEvent = getValueEvent(event);
    return [valueEvent.clientX, valueEvent.clientY];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event)
      payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call$1(v, ...args) {
    if (typeof v === "function") {
      return v(...args);
    } else {
      return v;
    }
  }
  function noop$1() {
  }
  function chain(...fns) {
    if (fns.length === 0)
      return noop$1;
    if (fns.length === 1)
      return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value, fallback) {
    return Object.assign({}, fallback, value || {});
  }
  const BEFORE_LAST_KINEMATICS_DELAY = 32;
  class Engine {
    constructor(ctrl, args, key) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init)
          this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config2.from ? call$1(config2.from, state) : state.offset;
        state.offset = state.lastOffset;
      }
      state.startTime = state.timeStamp = event.timeStamp;
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config: config2,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config2.preventDefault && event.cancelable)
          state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent)
        this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config2.threshold;
      const {
        _step,
        values
      } = state;
      if (config2.hasCustomTransform) {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional)
        return;
      const movement = [0, 0];
      if (config2.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked)
        this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config2)
              state._bounds = call$1(config2.bounds, state);
            if (this.setup)
              this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config2 = this.config;
      if (!state._active)
        this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents)
        return;
      const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo !== void 0)
        state.memo = memo;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  }
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  class CoordinatesEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state.axis && event) {
        const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
    }
    restrictToAxis(v) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v[1] = 0;
            break;
          case "y":
            v[0] = 0;
            break;
        }
      }
    }
  }
  const identity = (v) => v;
  const DEFAULT_RUBBERBAND = 0.15;
  const commonConfigResolver = {
    enabled(value = true) {
      return value;
    },
    eventOptions(value, _k, config2) {
      return _objectSpread2(_objectSpread2({}, config2.shared.eventOptions), value);
    },
    preventDefault(value = false) {
      return value;
    },
    triggerAllEvents(value = false) {
      return value;
    },
    rubberband(value = 0) {
      switch (value) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value);
      }
    },
    from(value) {
      if (typeof value === "function")
        return value;
      if (value != null)
        return V.toVector(value);
    },
    transform(value, _k, config2) {
      const transform = value || config2.shared.transform;
      this.hasCustomTransform = !!transform;
      if (process.env.NODE_ENV === "development") {
        const originalTransform = transform || identity;
        return (v) => {
          const r = originalTransform(v);
          if (!isFinite(r[0]) || !isFinite(r[1])) {
            console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
          }
          return r;
        };
      }
      return transform || identity;
    },
    threshold(value) {
      return V.toVector(value, 0);
    }
  };
  if (process.env.NODE_ENV === "development") {
    Object.assign(commonConfigResolver, {
      domTarget(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
        }
        return NaN;
      },
      lockDirection(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
        }
        return NaN;
      },
      initial(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
        }
        return NaN;
      }
    });
  }
  const DEFAULT_AXIS_THRESHOLD = 0;
  const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection)
        return axis;
    },
    axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
      return value;
    },
    bounds(value = {}) {
      if (typeof value === "function") {
        return (state) => coordinatesConfigResolver.bounds(value(state));
      }
      if ("current" in value) {
        return () => value.current;
      }
      if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
        return value;
      }
      const {
        left = -Infinity,
        right = Infinity,
        top = -Infinity,
        bottom = Infinity
      } = value;
      return [[left, right], [top, bottom]];
    }
  });
  const DISPLACEMENT = 10;
  const KEYS_DELTA_MAP = {
    ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
    ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
    ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
    ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
  };
  class DragEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "dragging");
    }
    reset() {
      super.reset();
      const state = this.state;
      state._pointerId = void 0;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
    setup() {
      const state = this.state;
      if (state._bounds instanceof HTMLElement) {
        const boundRect = state._bounds.getBoundingClientRect();
        const targetRect = state.currentTarget.getBoundingClientRect();
        const _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled)
        return;
      state.canceled = true;
      state._active = false;
      setTimeout(() => {
        this.compute();
        this.emit();
      }, 0);
    }
    setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
    clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;
      super.clean();
    }
    pointerDown(event) {
      const config2 = this.config;
      const state = this.state;
      if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons))
        return;
      const ctrlIds = this.ctrl.setEventIds(event);
      if (config2.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }
      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
        return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();
      if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config2.delay > 0) {
        this.setupDelayTrigger(event);
        if (config2.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
    startPointerDrag(event) {
      const state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
    pointerMove(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._pointerActive)
        return;
      if (state.type === event.type && event.timeStamp === state.timeStamp)
        return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId)
        return;
      const _values = pointerValues(event);
      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = V.sub(_values, state._values);
        this.computeValues(_values);
      }
      V.addTo(state._movement, state._delta);
      this.compute(event);
      if (state._delayed && state.intentional) {
        this.timeoutStore.remove("dragDelay");
        state.active = false;
        this.startPointerDrag(event);
        return;
      }
      if (config2.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove("startPointerDrag");
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }
      this.emit();
    }
    pointerUp(event) {
      this.ctrl.setEventIds(event);
      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
        }
      }
      const state = this.state;
      const config2 = this.config;
      if (!state._active || !state._pointerActive)
        return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId)
        return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);
      const [dx, dy] = state._distance;
      state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
      if (state.tap && config2.filterTaps) {
        state._force = true;
      } else {
        const [dirx, diry] = state.direction;
        const [vx, vy] = state.velocity;
        const [mx, my] = state.movement;
        const [svx, svy] = config2.swipe.velocity;
        const [sx, sy] = config2.swipe.distance;
        const sdt = config2.swipe.duration;
        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx)
            state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy)
            state.swipe[1] = diry;
        }
      }
      this.emit();
    }
    pointerClick(event) {
      if (!this.state.tap && event.detail > 0) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    setupPointer(event) {
      const config2 = this.config;
      const device = config2.device;
      if (process.env.NODE_ENV === "development") {
        try {
          if (device === "pointer" && config2.preventScrollDelay === void 0) {
            const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
            const style = window.getComputedStyle(currentTarget);
            if (style.touchAction === "auto") {
              console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
            }
          }
        } catch (_unused2) {
        }
      }
      if (config2.pointerLock) {
        event.currentTarget.requestPointerLock();
      }
      if (!config2.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
      }
    }
    pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
    preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
    setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
      this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
      this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
    setupDelayTrigger(event) {
      this.state._delayed = true;
      this.timeoutStore.add("dragDelay", () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      }, this.config.delay);
    }
    keyDown(event) {
      const deltaFn = KEYS_DELTA_MAP[event.key];
      if (deltaFn) {
        const state = this.state;
        const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
    keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP))
        return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      bindFunction(device, "start", this.pointerDown.bind(this));
      if (this.config.pointerCapture) {
        bindFunction(device, "change", this.pointerMove.bind(this));
        bindFunction(device, "end", this.pointerUp.bind(this));
        bindFunction(device, "cancel", this.pointerUp.bind(this));
        bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
      }
      if (this.config.keys) {
        bindFunction("key", "down", this.keyDown.bind(this));
        bindFunction("key", "up", this.keyUp.bind(this));
      }
      if (this.config.filterTaps) {
        bindFunction("click", "", this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  }
  function persistEvent(event) {
    "persist" in event && typeof event.persist === "function" && event.persist();
  }
  const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents() {
    return isBrowser && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents() {
    return isBrowser && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e) {
      return false;
    }
  }
  const SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
  };
  const DEFAULT_PREVENT_SCROLL_DELAY = 250;
  const DEFAULT_DRAG_DELAY = 180;
  const DEFAULT_SWIPE_VELOCITY = 0.5;
  const DEFAULT_SWIPE_DISTANCE = 50;
  const DEFAULT_SWIPE_DURATION = 250;
  const DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  const dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch)
        return "touch";
      if (this.pointerLock)
        return "mouse";
      if (SUPPORT.pointer && !mouse)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
      return "mouse";
    },
    preventScrollAxis(value, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false)
        return void 0;
      return value ? value : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1
      } = {}
    }) {
      this.pointerButtons = buttons;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    keys(value = true) {
      return value;
    },
    threshold(value, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity = DEFAULT_SWIPE_VELOCITY,
      distance = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity)),
        distance: this.transform(V.toVector(distance)),
        duration
      };
    },
    delay(value = 0) {
      switch (value) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value;
      }
    },
    axisThreshold(value) {
      if (!value)
        return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
    }
  });
  if (process.env.NODE_ENV === "development") {
    Object.assign(dragConfigResolver, {
      useTouch(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
        }
        return NaN;
      },
      experimental_preventWindowScrollY(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
        }
        return NaN;
      },
      swipeVelocity(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
        }
        return NaN;
      },
      swipeDistance(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
        }
        return NaN;
      },
      swipeDuration(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
        }
        return NaN;
      }
    });
  }
  _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
        return "gesture";
      if (SUPPORT.touch && touch)
        return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer)
          return "pointer";
        if (SUPPORT.touch)
          return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D = assignDefault(call$1(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D.min, D.max];
      };
      const _angleBounds = (state) => {
        const A = assignDefault(call$1(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A.min, A.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
        return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value, _k, config2) {
      this.lockDirection = config2.axis === "lock";
      const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value) {
      if (value === void 0)
        return "ctrlKey";
      return value;
    }
  });
  _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  const EngineMap = /* @__PURE__ */ new Map();
  const ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  const dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
  };
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  const sharedConfigResolver = {
    target(value) {
      if (value) {
        return () => "current" in value ? value.current : value;
      }
      return void 0;
    },
    enabled(value = true) {
      return value;
    },
    window(value = SUPPORT.isBrowser ? window : void 0) {
      return value;
    },
    eventOptions({
      passive = true,
      capture = false
    } = {}) {
      return {
        passive,
        capture
      };
    },
    transform(value) {
      return value;
    }
  };
  const _excluded$3 = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config2 = {}, resolvers) {
    const result = {};
    for (const [key, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          if (process.env.NODE_ENV === "development") {
            const r = resolver.call(result, config2[key], key, config2);
            if (!Number.isNaN(r))
              result[key] = r;
          } else {
            result[key] = resolver.call(result, config2[key], key, config2);
          }
          break;
        case "object":
          result[key] = resolveWith(config2[key], resolver);
          break;
        case "boolean":
          if (resolver)
            result[key] = config2[key];
          break;
      }
    }
    return result;
  }
  function parse(newConfig, gestureKey, _config = {}) {
    const _ref = newConfig, {
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    } = _ref, rest = _objectWithoutProperties(_ref, _excluded$3);
    _config.shared = resolveWith({
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver);
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread2({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key in rest) {
        const resolver = ConfigResolverMap.get(key);
        if (resolver) {
          _config[key] = resolveWith(_objectSpread2({
            shared: _config.shared
          }, rest[key]), resolver);
        } else if (process.env.NODE_ENV === "development") {
          if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
            if (key === "domTarget") {
              throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
            }
            console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
          }
        }
      }
    }
    return _config;
  }
  class EventStore {
    constructor(ctrl, gestureKey) {
      _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options) {
      const listeners = this._listeners;
      const type = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
      element.addEventListener(type, handler, eventOptions);
      const remove = () => {
        element.removeEventListener(type, handler, eventOptions);
        listeners.delete(remove);
      };
      listeners.add(remove);
      return remove;
    }
    clean() {
      this._listeners.forEach((remove) => remove());
      this._listeners.clear();
    }
  }
  class TimeoutStore {
    constructor() {
      _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key, callback, ms = 140, ...args) {
      this.remove(key);
      this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
    }
    remove(key) {
      const timeout = this._timeouts.get(key);
      if (timeout)
        window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  }
  let Controller$1 = class Controller {
    constructor(handlers) {
      _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty(this, "_targetEventStore", new EventStore(this));
      _defineProperty(this, "gestureEventStores", {});
      _defineProperty(this, "gestureTimeoutStores", {});
      _defineProperty(this, "handlers", {});
      _defineProperty(this, "config", {});
      _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel")
          this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown")
          this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config2, gestureKey) {
      this.config = parse(config2, gestureKey, this.config);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key of this.gestures) {
        this.gestureEventStores[key].clean();
        this.gestureTimeoutStores[key].clean();
      }
    }
    effect() {
      if (this.config.shared.target)
        this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target)
          return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
            event,
            args
          })), void 0, true);
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target)
        return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive
        });
      }
    }
  };
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag)
      setupGesture(ctrl, "drag");
    if (internalHandlers.wheel)
      setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll)
      setupGesture(ctrl, "scroll");
    if (internalHandlers.move)
      setupGesture(ctrl, "move");
    if (internalHandlers.pinch)
      setupGesture(ctrl, "pinch");
    if (internalHandlers.hover)
      setupGesture(ctrl, "hover");
  }
  const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive)
      handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
  function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
    const ctrl = React.useMemo(() => new Controller$1(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config2, gestureKey);
    React.useEffect(ctrl.effect.bind(ctrl));
    React.useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config2.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function useDrag(handler, config2) {
    registerAction(dragAction);
    return useRecognizers({
      drag: handler
    }, config2 || {}, "drag");
  }
  let updateQueue = makeQueue();
  const raf = (fn) => schedule(fn, updateQueue);
  let writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  let onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  let onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  let onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  let timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time = raf.now() + ms;
    let cancel = () => {
      let i = timeouts.findIndex((t) => t.cancel == cancel);
      if (~i)
        timeouts.splice(i, 1);
      pendingCount -= ~i ? 1 : 0;
    };
    let timeout = {
      time,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  let findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  let nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  let ts = -1;
  let pendingCount = 0;
  let sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t) => t.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next = /* @__PURE__ */ new Set();
    let current = next;
    return {
      add(fn) {
        pendingCount += current == next && !next.has(fn) ? 1 : 0;
        next.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next && next.has(fn) ? 1 : 0;
        return next.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next.add(fn));
          pendingCount += next.size;
          current = next;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e) {
        raf.catch(e);
      }
    });
  }
  function noop() {
  }
  const defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
    value,
    writable: true,
    configurable: true
  });
  const is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b2) {
    if (is.arr(a)) {
      if (!is.arr(b2) || a.length !== b2.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b2[i])
          return false;
      }
      return true;
    }
    return a === b2;
  }
  const each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn.call(ctx2, obj[i], `${i}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  const toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  const flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  const isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  let createStringInterpolator$1;
  let to;
  let colors$1 = null;
  let skipAnimation = false;
  let willAdvance = noop;
  const assign = (globals2) => {
    if (globals2.to)
      to = globals2.to;
    if (globals2.now)
      raf.now = globals2.now;
    if (globals2.colors !== void 0)
      colors$1 = globals2.colors;
    if (globals2.skipAnimation != null)
      skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator)
      createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame)
      raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates)
      raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance)
      willAdvance = globals2.willAdvance;
    if (globals2.frameLoop)
      raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  const startQueue = /* @__PURE__ */ new Set();
  let currentFrame = [];
  let prevFrame = [];
  let priority = 0;
  const frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation))
      startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i = 0; i < currentFrame.length; i++) {
      const animation = currentFrame[i];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index = arr.findIndex(test);
    return index < 0 ? arr.length : index;
  }
  const clamp = (min, max, v) => Math.min(Math.max(v, min), max);
  const colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  const rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  const rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  const hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  const hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex6 = /^#([0-9a-fA-F]{6})$/;
  const hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color) {
    let match;
    if (typeof color === "number") {
      return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
    }
    if (match = hex6.exec(color))
      return parseInt(match[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color] !== void 0) {
      return colors$1[color];
    }
    if (match = rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
    if (match = rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
    if (match = hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
    if (match = hex8.exec(color))
      return parseInt(match[1], 16) >>> 0;
    if (match = hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
    if (match = hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
    if (match = hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslToRgb(h, s, l) {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b2 = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0)
      return 0;
    if (int > 255)
      return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0)
      return 0;
    if (num > 1)
      return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0)
      return 0;
    if (int > 100)
      return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null)
      return input;
    int32Color = int32Color || 0;
    let r = (int32Color & 4278190080) >>> 24;
    let g = (int32Color & 16711680) >>> 16;
    let b2 = (int32Color & 65280) >>> 8;
    let a = (int32Color & 255) / 255;
    return `rgba(${r}, ${g}, ${b2}, ${a})`;
  }
  const createInterpolator = (range, output, extrapolate) => {
    if (is.fun(range)) {
      return range;
    }
    if (is.arr(range)) {
      return createInterpolator({
        range,
        output,
        extrapolate
      });
    }
    if (is.str(range.output[0])) {
      return createStringInterpolator$1(range);
    }
    const config2 = range;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t) => t);
    return (input) => {
      const range2 = findRange(input, inputRange);
      return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity")
        return result;
      else if (extrapolateLeft === "clamp")
        result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity")
        return result;
      else if (extrapolateRight === "clamp")
        result = inputMax;
    }
    if (outputMin === outputMax)
      return outputMin;
    if (inputMin === inputMax)
      return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity)
      result = -result;
    else if (inputMax === Infinity)
      result = result - inputMin;
    else
      result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity)
      result = -result;
    else if (outputMax === Infinity)
      result = result + outputMin;
    else
      result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i = 1; i < inputRange.length - 1; ++i)
      if (inputRange[i] >= input)
        break;
    return i - 1;
  }
  const steps = (steps2, direction = "end") => (progress) => {
    progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 1e-3);
    const expanded = progress * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp(0, 1, rounded / steps2);
  };
  const c1 = 1.70158;
  const c2 = c1 * 1.525;
  const c3 = c1 + 1;
  const c4 = 2 * Math.PI / 3;
  const c5 = 2 * Math.PI / 4.5;
  const bounceOut = (x) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  };
  const easings = {
    linear: (x) => x,
    easeInQuad: (x) => x * x,
    easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
    easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
    easeInCubic: (x) => x * x * x,
    easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
    easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
    easeInQuart: (x) => x * x * x * x,
    easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
    easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
    easeInQuint: (x) => x * x * x * x * x,
    easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
    easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
    easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
    easeOutSine: (x) => Math.sin(x * Math.PI / 2),
    easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
    easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
    easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
    easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
    easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
    easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
    easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
    easeInBack: (x) => c3 * x * x * x - c1 * x * x,
    easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
    easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
    easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
    easeInBounce: (x) => 1 - bounceOut(1 - x),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
    steps
  };
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const $get = Symbol.for("FluidValue.get");
  const $observers = Symbol.for("FluidValue.observers");
  const hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  const getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  const getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers = target[$observers];
    if (observers) {
      observers.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  class FluidValue {
    constructor(get) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  }
  const setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer)) {
        observers.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers = target[$observers];
    if (observers && observers.has(observer)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  const setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  const numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  const unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  const rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  const variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable(input);
    if (!token || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  const parseCSSVariable = (current) => {
    const match = cssVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token, fallback] = match;
    return [token, fallback];
  };
  let namedColorRegex;
  const rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  const createStringInterpolator = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes[0].map((_, i) => keyframes.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    }));
    const interpolators = outputRanges.map((output2) => createInterpolator(_extends$2({}, config2, {
      output: output2
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i = 0;
      return output[0].replace(numberRegex, () => `${interpolators[i++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  const prefix = "react-spring: ";
  const once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  const warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  const warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
  }
  const useIsomorphicLayoutEffect = isSSR() ? React.useEffect : React.useLayoutEffect;
  const useIsMounted = () => {
    const isMounted = React.useRef(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update2 = React.useState()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update2(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = React.useState(() => ({
      inputs,
      result: getResult()
    }));
    const committed = React.useRef();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    React.useEffect(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next, prev) {
    if (next.length !== prev.length) {
      return false;
    }
    for (let i = 0; i < next.length; i++) {
      if (next[i] !== prev[i]) {
        return false;
      }
    }
    return true;
  }
  const useOnce = (effect) => React.useEffect(effect, emptyDeps);
  const emptyDeps = [];
  function usePrev(value) {
    const prevRef = React.useRef();
    React.useEffect(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }
  const $node = Symbol.for("Animated:node");
  const isAnimated = (value) => !!value && value[$node] === value;
  const getAnimated = (owner) => owner && owner[$node];
  const setAnimated = (owner, node) => defineHidden(owner, $node, node);
  const getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  class Animated {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  }
  class AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done)
          this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }
  class AnimatedString extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      let value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  }
  const TreeContext = {
    dependencies: null
  };
  class AnimatedObject extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  }
  class AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  }
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  const withAnimated = (Component, host2) => {
    const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
    return React.forwardRef((givenProps, givenRef) => {
      const instanceRef = React.useRef(null);
      const ref = hasInstance && React.useCallback((value) => {
        instanceRef.current = updateRef(givenRef, value);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = React.useRef();
      useIsomorphicLayoutEffect(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      React.useEffect(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React__namespace.createElement(Component, _extends$1({}, usedProps, {
        ref
      }));
    });
  };
  class PropsObserver {
    constructor(update2, deps) {
      this.update = update2;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  }
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = _extends$1({}, props, {
        style: host2.createAnimatedStyle(props.style)
      });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref))
        ref(value);
      else
        ref.current = value;
    }
    return value;
  }
  const cacheKey = Symbol.for("AnimatedComponent");
  const createHost = (components2, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components2, (Component, key) => {
      if (is.arr(components2)) {
        key = getDisplayName(Component);
      }
      animated2[key] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  const getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  const matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
  const resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  const getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  const noopTransform = (value) => value;
  const getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  const DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  const RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return _extends({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _ in props)
      return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _ctrl$ref;
    (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    if (ref && ctrl.ref !== ref) {
      var _ctrl$ref2;
      (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  const config = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  const defaults = _extends({}, config.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  class AnimationConfig {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  }
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = _extends({}, defaultConfig);
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = _extends({}, defaultConfig, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01)
        frequency = 0.01;
      if (damping < 0)
        damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  const emptyArray = [];
  class Animation {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  }
  function scheduleProps(callId, {
    key,
    props,
    defaultProps: defaultProps2,
    state,
    actions
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps2 == null ? void 0 : defaultProps2.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(_extends({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  const getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  const getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  const getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  const getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps2 = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps2, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t) => t.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId)
      state.cancelId = cancelId;
  }
  class BailSignal extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  }
  class SkipAnimationSignal extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  }
  const isFrameValue = (value) => value instanceof FrameValue;
  let nextId$1 = 1;
  class FrameValue extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1)
        this._attach();
    }
    observerRemoved(count) {
      if (count == 0)
        this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  }
  const $P = Symbol.for("SpringPhase");
  const HAS_ANIMATED = 1;
  const IS_ANIMATING = 2;
  const IS_PAUSED = 4;
  const hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  const isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  const isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  const setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  const setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  class SpringValue extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i) => {
        if (node2.done)
          return;
        const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];
        let finished = anim.immediate;
        let position = to2;
        if (!finished) {
          position = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt;
          const from = anim.fromValues[i];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          if (!is.und(config2.duration)) {
            let p = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt;
                }
              }
              p = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p = p > 1 ? 1 : p < 0 ? 0 : p;
              node2.durationProgress = p;
            }
            position = from + config2.easing(p) * (to2 - from);
            velocity = (position - node2.lastPosition) / dt;
            finished = p == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e = Math.exp(-(1 - decay) * elapsed);
            position = from + v0 / (1 - decay) * (1 - e);
            finished = Math.abs(node2.lastPosition - position) <= precision;
            velocity = v0 * e;
          } else {
            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n = 0; n < numSteps; ++n) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position == to2 || position > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position = position + velocity * step;
            }
          }
          node2.lastVelocity = velocity;
          if (Number.isNaN(position)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key = this.key || "";
      let {
        to: to2,
        from
      } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key] : from;
      if (from == null) {
        from = void 0;
      }
      const range = {
        to: to2,
        from
      };
      if (!hasAnimated(this)) {
        if (props.reverse)
          [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range;
    }
    _update(_ref, isLoop) {
      let props = _extends({}, _ref);
      const {
        key,
        defaultProps: defaultProps2
      } = this;
      if (props.default)
        Object.assign(defaultProps2, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps: defaultProps2,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range.to);
      const hasFromProp = !is.und(range.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key,
        defaultProps: defaultProps2,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from = prevFrom
      } = range;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse)
        [to2, from] = [from, to2];
      const hasFromChanged = !isEqual(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay,
        velocity
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps2.config ? callProp(defaultProps2.config, key) : void 0);
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
      const value = reset ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else
            throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              anim.changed = !reset;
              onRest == null ? void 0 : onRest(result, this);
              if (reset) {
                callProp(defaultProps2.onRest, result);
              } else {
                anim.onStart == null ? void 0 : anim.onStart(result, this);
              }
            });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  }
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(_extends({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        from: reset ? props.from : void 0,
        reset
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2))
      findDefined(to2, keys);
    if (is.obj(from))
      findDefined(from, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function declareUpdate(props) {
    const update2 = createUpdate(props);
    if (is.und(update2.default)) {
      update2.default = getDefaultProps(update2);
    }
    return update2;
  }
  function findDefined(values, keys) {
    eachProp(values, (value, key) => value != null && keys.add(key));
  }
  const ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  const BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  let nextId = 1;
  class Controller {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    get() {
      const values = {};
      this.each((spring, key) => values[key] = spring.get());
      return values;
    }
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else
        return;
      raf.onFrame(this._onFrame);
    }
  }
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false)
      props.to = null;
    if (from === false)
      props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished)
                result2.finished = false;
              if (cancelled)
                result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = _extends({}, ctrl.springs);
    if (props) {
      each(toArray(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = _extends({}, props2, {
            to: void 0
          });
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$6 = ["children"];
  const SpringContext = (_ref) => {
    let {
      children
    } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$6);
    const inherited = React.useContext(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider
    } = ctx;
    return React__namespace.createElement(Provider, {
      value: props
    }, children);
  };
  const ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React__namespace.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  const SpringRef = () => {
    const current = [];
    const SpringRef2 = function SpringRef3(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = _getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i = current.indexOf(ctrl);
      if (~i)
        current.splice(i, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl) => ctrl.set(values));
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = this._getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
      return this;
    };
    const _getProps = function _getProps2(arg, ctrl, index) {
      return is.fun(arg) ? arg(index, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps)
      deps = [];
    const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
    const layoutId = React.useRef(0);
    const forceUpdate = useForceUpdate();
    const state = React.useMemo(() => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }), []);
    const ctrls = React.useRef([...state.ctrls]);
    const updates = [];
    const prevLength = usePrev(length) || 0;
    React.useMemo(() => {
      each(ctrls.current.slice(length, prevLength), (ctrl) => {
        detachRefs(ctrl, ref);
        ctrl.stop(true);
      });
      ctrls.current.length = length;
      declareUpdates(prevLength, length);
    }, [length]);
    React.useMemo(() => {
      declareUpdates(0, Math.min(prevLength, length));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i = startIndex; i < endIndex; i++) {
        const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
        const update2 = propsFn ? propsFn(i, ctrl) : props[i];
        if (update2) {
          updates[i] = declareUpdate(update2);
        }
      }
    }
    const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
    const context = React.useContext(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useIsomorphicLayoutEffect(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const {
        queue
      } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb) => cb());
      }
      each(ctrls.current, (ctrl, i) => {
        ref == null ? void 0 : ref.add(ctrl);
        if (hasContext) {
          ctrl.start({
            default: context
          });
        }
        const update2 = updates[i];
        if (update2) {
          replaceRef(ctrl, update2.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update2);
          } else {
            ctrl.start(update2);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x) => _extends({}, x));
    return ref ? [values, ref] : values;
  }
  function useSpring(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
    return isFn || arguments.length == 2 ? [values, ref] : values;
  }
  let TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  class Interpolation extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
      }
    }
  }
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$2 = ["style", "children", "scrollTop", "scrollLeft", "viewBox"];
  const isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "")
      return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  const attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref = props, {
      style,
      children,
      scrollTop,
      scrollLeft,
      viewBox
    } = _ref, attributes = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n) => "-" + n.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names.forEach((name, i) => {
      instance.setAttribute(name, values[i]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance.setAttribute("viewBox", viewBox);
    }
  }
  let isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  const prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  const prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  const _excluded$1 = ["x", "y", "z"];
  const domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  const pxTransforms = /^(translate)/;
  const degTransforms = /^(rotate|skew)/;
  const addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  const isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
  class AnimatedStyle extends AnimatedObject {
    constructor(_ref) {
      let {
        x,
        y,
        z
      } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded$1);
      const inputs = [];
      const transforms = [];
      if (x || y || z) {
        inputs.push([x || 0, y || 0, z || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value))
            return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray(value));
          transforms.push(key === "rotate3d" ? ([x2, y2, z2, deg]) => [`rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v) => addUnit(v, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  }
  class FluidTransform extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each(this.inputs, (input, i) => {
        const arg1 = getFluidValue(input[0]);
        const [t, id] = this.transforms[i](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform += " " + t;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform;
    }
    observerAdded(count) {
      if (count == 1)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
    }
    observerRemoved(count) {
      if (count == 0)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  }
  const primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  const _excluded = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: ReactDOM.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  const host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref) => {
      let props = _objectWithoutPropertiesLoose(_ref, _excluded);
      return props;
    }
  });
  const animated = host.animated;
  function bound(position, min, max) {
    let ret = position;
    if (min !== void 0) {
      ret = Math.max(position, min);
    }
    if (max !== void 0) {
      ret = Math.min(ret, max);
    }
    return ret;
  }
  function rubberband(distance, dimension, constant) {
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds(position, min, max, dimension, constant = 0.15) {
    if (constant === 0)
      return bound(position, min, max);
    if (position < min)
      return -rubberband(min - position, dimension, constant) + min;
    if (position > max)
      return +rubberband(position - max, dimension, constant) + max;
    return position;
  }
  const sleep = (time) => new Promise((resolve) => setTimeout(resolve, time));
  const defaultProps$D = {
    pullingText: "",
    canReleaseText: "",
    refreshingText: "",
    completeText: "",
    completeDelay: 500,
    disabled: false,
    headHeight: 40,
    threshold: 60,
    onRefresh: () => {
    }
  };
  const PullToRefresh = (p) => {
    const { locale } = useConfig$1();
    const props = {
      ...defaultProps$D,
      ...p,
      ...{
        pullingText: p.pullingText || locale.pullToRefresh.pullingText,
        canReleaseText: p.canReleaseText || locale.pullToRefresh.canReleaseText,
        refreshingText: p.refreshingText || locale.pullToRefresh.refreshingText,
        completeText: p.completeText || locale.pullToRefresh.completeText
      }
    };
    const headHeight = props.headHeight;
    const threshold = props.threshold;
    const [status, setStatus] = React.useState("pulling");
    const [springStyles, api] = useSpring(() => ({
      from: { height: 0 },
      config: {
        tension: 300,
        friction: 30,
        clamp: true
      }
    }));
    const elementRef = React.useRef(null);
    const pullingRef = React.useRef(false);
    React.useEffect(() => {
      var _a;
      (_a = elementRef.current) == null ? void 0 : _a.addEventListener("touchmove", () => {
      });
    }, []);
    async function doRefresh() {
      api.start({ height: headHeight });
      setStatus("refreshing");
      try {
        await props.onRefresh();
        setStatus("complete");
      } catch (e) {
        api.start({
          to: async (next) => {
            await next({ height: 0 });
            setStatus("pulling");
          }
        });
        throw e;
      }
      if (props.completeDelay > 0) {
        await sleep(props.completeDelay);
      }
      api.start({
        to: async (next) => {
          await next({ height: 0 });
          setStatus("pulling");
        }
      });
    }
    useDrag(
      (state) => {
        if (status === "refreshing" || status === "complete")
          return;
        const { event } = state;
        if (state.last) {
          pullingRef.current = false;
          if (status === "canRelease") {
            doRefresh();
          } else {
            api.start({ height: 0 });
          }
          return;
        }
        function getScrollTop(element) {
          return "scrollTop" in element ? element.scrollTop : element.scrollY;
        }
        const [, y] = state.movement;
        if (state.first && y > 0) {
          const target = state.event.target;
          if (!target || !(target instanceof Element))
            return;
          let scrollParent = getScrollParent(target);
          while (true) {
            if (!scrollParent)
              return;
            const scrollTop = getScrollTop(scrollParent);
            if (scrollTop > 0) {
              return;
            }
            if (scrollParent instanceof Window) {
              break;
            }
            scrollParent = getScrollParent(scrollParent.parentNode);
          }
          pullingRef.current = true;
        }
        if (!pullingRef.current)
          return;
        if (event.cancelable) {
          event.preventDefault();
        }
        event.stopPropagation();
        const height = Math.max(
          rubberbandIfOutOfBounds(y, 0, 0, headHeight * 5, 0.5),
          0
        );
        api.start({ height });
        setStatus(height > threshold ? "canRelease" : "pulling");
      },
      {
        pointer: { touch: true },
        axis: "y",
        target: elementRef,
        enabled: !props.disabled,
        eventOptions: passiveSupported ? { passive: false } : false
      }
    );
    const renderStatusText = () => {
      var _a;
      if (props.renderText) {
        return (_a = props.renderText) == null ? void 0 : _a.call(props, status);
      }
      if (status === "pulling")
        return props.pullingText;
      if (status === "canRelease")
        return props.canReleaseText;
      if (status === "refreshing")
        return props.refreshingText;
      if (status === "complete")
        return props.completeText;
      return "";
    };
    return /* @__PURE__ */ React.createElement(animated.div, { ref: elementRef, className: "nut-pulltorefresh" }, /* @__PURE__ */ React.createElement(animated.div, { style: springStyles, className: "nut-pulltorefresh-head" }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-pulltorefresh-head-content",
        style: { height: headHeight }
      },
      renderStatusText()
    )), /* @__PURE__ */ React.createElement("div", { className: "nut-pulltorefresh-content" }, props.children));
  };
  PullToRefresh.defaultProps = defaultProps$D;
  PullToRefresh.displayName = "NutPullToRefresh";
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      event.stopPropagation();
    }
  }
  const defaultProps$C = {
    name: "",
    leftWidth: 0,
    rightWidth: 0
  };
  const Swipe = React.forwardRef((props, instanceRef) => {
    const swipeBem = cn("swipe");
    const touch = useTouch();
    Taro.useReady(() => {
      const getWidth = async () => {
        if (leftWrapper.current) {
          const leftRect = await getRectByTaro(leftWrapper.current);
          setActionWidth((v) => ({ ...v, left: leftRect.width }));
        }
        if (rightWrapper.current) {
          const rightRect = await getRectByTaro(rightWrapper.current);
          setActionWidth((v) => ({ ...v, right: rightRect.width }));
        }
      };
      Taro.nextTick(() => getWidth());
    });
    const { children, className, style } = { ...defaultProps$C, ...props };
    const root2 = React.useRef();
    const opened = React.useRef(false);
    const lockClick = React.useRef(false);
    const startOffset = React.useRef(0);
    const [state, setState] = React.useState({
      offset: 0,
      dragging: false
    });
    const [actionWidth, setActionWidth] = React.useState({
      left: 0,
      right: 0
    });
    const wrapperStyle = {
      transform: `translate3d(${state.offset}px, 0, 0)`,
      transitionDuration: state.dragging ? "0s" : ".6s"
    };
    const leftWidth = React.useMemo(
      () => props.leftWidth ? props.leftWidth : actionWidth.left,
      [props.leftWidth, actionWidth.left]
    );
    const rightWidth = React.useMemo(
      () => props.rightWidth ? props.rightWidth : actionWidth.right,
      [props.rightWidth, actionWidth.right]
    );
    const onTouchStart = async (event) => {
      if (leftWrapper.current) {
        const leftRect = await getRectByTaro(leftWrapper.current);
        setActionWidth((v) => ({ ...v, left: leftRect.width }));
      }
      if (rightWrapper.current) {
        const rightRect = await getRectByTaro(rightWrapper.current);
        setActionWidth((v) => ({ ...v, right: rightRect.width }));
      }
      if (!props.disabled) {
        startOffset.current = state.offset;
        touch.start(event);
        props.onTouchStart && props.onTouchStart(event);
      }
    };
    const onTouchMove = (event) => {
      if (props.disabled) {
        return;
      }
      touch.move(event);
      props.onTouchMove && props.onTouchMove(event);
      if (touch.isHorizontal()) {
        lockClick.current = true;
        const newState = { ...state, dragging: true };
        const isEdge = !opened || touch.deltaX * startOffset.current < 0;
        if (isEdge) {
          preventDefault(event, true);
        }
        newState.offset = rangeCalculation(
          touch.deltaX + startOffset.current,
          -rightWidth || 0,
          leftWidth || 0
        );
        setState(newState);
      }
    };
    const onTouchEnd = (event) => {
      if (state.dragging) {
        setState((v) => ({ ...v, dragging: false }));
        toggle(state.offset > 0 ? "left" : "right");
        setTimeout(() => {
          lockClick.current = false;
        }, 0);
        props.onTouchEnd && props.onTouchEnd(event);
      }
    };
    const toggle = (side) => {
      const offset = Math.abs(state.offset);
      const base = 0.3;
      const baseNum = opened ? 1 - base : base;
      const width = side === "left" ? leftWidth : rightWidth;
      if (width && offset > Number(width) * baseNum) {
        open(side);
      } else {
        close(side);
      }
    };
    const open = (side) => {
      var _a;
      opened.current = true;
      const offset = side === "left" ? leftWidth : -rightWidth;
      const name = props.name;
      (_a = props.onOpen) == null ? void 0 : _a.call(props, { name, position: side });
      setState((v) => ({ ...v, offset: Number(offset) || 0 }));
    };
    const close = (position) => {
      var _a;
      if (opened.current) {
        opened.current = false;
        (_a = props.onClose) == null ? void 0 : _a.call(props, {
          name: props.name,
          position: position || "left"
        });
      }
      setState((v) => ({ ...v, offset: 0 }));
    };
    const rangeCalculation = (num, min, max) => {
      return Math.min(Math.max(Number(num), Number(min)), Number(max));
    };
    const leftWrapper = React.useRef(null);
    const rightWrapper = React.useRef(null);
    const renderActionContent = (side) => {
      if (props[`${side}Action`]) {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            id: "left",
            ref: side === "left" ? leftWrapper : rightWrapper,
            className: `${swipeBem(side)}`,
            onClick: (e) => handleOperate(e, side)
          },
          props[`${side}Action`]
        );
      }
      return null;
    };
    const handleOperate = (event, position) => {
      event.stopPropagation();
      if (props.beforeClose) {
        props.beforeClose(position);
      } else {
        props.onActionClick && props.onActionClick(event, position);
      }
    };
    React.useImperativeHandle(instanceRef, () => ({
      open,
      close: () => close()
    }));
    React.useEffect(() => {
      const handler = (event) => {
        const targets = [root2];
        if (targets.some((targetItem) => {
          const targetElement = targetItem.current || targetItem;
          return !targetElement || (targetElement == null ? void 0 : targetElement.contains(event.target));
        })) {
          return;
        }
        close();
      };
      document.addEventListener("touchstart", handler);
      return () => {
        document.removeEventListener("touchstart", handler);
      };
    }, []);
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: root2,
        className: classNames(swipeBem(), className),
        onTouchStart: (e) => onTouchStart(e),
        onTouchMove: (e) => onTouchMove(e),
        onTouchEnd: (e) => onTouchEnd(e),
        style
      },
      /* @__PURE__ */ React.createElement("div", { className: `${swipeBem("wrapper")}`, style: wrapperStyle }, renderActionContent("left"), children, renderActionContent("right"))
    );
  });
  Swipe.defaultProps = defaultProps$C;
  Swipe.displayName = "NutSwipe";
  const defaultProps$B = {
    isAsync: false,
    checked: false,
    disable: false,
    activeColor: "",
    inactiveColor: "",
    activeText: "",
    inactiveText: "",
    className: ""
  };
  const Switch = (props) => {
    const {
      isAsync,
      checked,
      disable,
      activeColor,
      inactiveColor,
      activeText,
      inactiveText,
      onChange,
      className,
      style
    } = {
      ...defaultProps$B,
      ...props
    };
    const [value, setValue] = React.useState(false);
    const b2 = cn("switch");
    React.useEffect(() => {
      setValue(checked);
    }, [checked]);
    const classes = () => {
      return `${b2()} ${value ? "switch-open" : "switch-close"} ${disable ? `${b2()}-disable` : ""} ${`${b2()}-base`} ${className}`;
    };
    const styles = () => {
      const myStyle = {
        backgroundColor: value ? activeColor : inactiveColor,
        ...style || {}
      };
      return myStyle;
    };
    const onClick = (event) => {
      if (disable)
        return;
      if (!isAsync) {
        setValue(!value);
      }
      onChange && onChange(!value, event);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes(), onClick: (e) => onClick(e), style: styles() }, /* @__PURE__ */ React.createElement("div", { className: "switch-button" }, !value && /* @__PURE__ */ React.createElement("div", { className: "close-line" }), activeText && /* @__PURE__ */ React.createElement(React.Fragment, null, value ? /* @__PURE__ */ React.createElement("div", { className: `${b2("label")} open` }, activeText) : /* @__PURE__ */ React.createElement("div", { className: `${b2("label")} close` }, inactiveText))));
  };
  Switch.defaultProps = defaultProps$B;
  Switch.displayName = "NutSwitch";
  const defaultProps$A = {
    type: "shake",
    action: "initial",
    loop: false,
    onClick: (event) => {
    }
  };
  const Animate = (props) => {
    const { className, type, action, loop: loop2, onClick, children, ...rest } = {
      ...defaultProps$A,
      ...props
    };
    const [clicked, setClicked] = React.useState(false);
    const b2 = cn("animate");
    const classes = classNames({
      "nut-ani-container": true,
      [`${b2("")}-${type}`]: action === "initial" || clicked ? type : false,
      loop: loop2
    });
    const cls = classNames(classes, className);
    const handleClick = (event) => {
      setClicked(true);
      if (!loop2) {
        setTimeout(() => {
          setClicked(false);
        }, 1e3);
      }
      onClick && onClick(event);
    };
    return /* @__PURE__ */ React.createElement("div", { className: "nut-animate" }, /* @__PURE__ */ React.createElement("div", { className: cls, onClick: handleClick, ...rest }, children));
  };
  Animate.defaultProps = defaultProps$A;
  Animate.displayName = "NutAnimate";
  const defaultProps$z = {
    maxLen: 0,
    endNumber: "",
    delaySpeed: 300,
    easeSpeed: 1,
    thousands: false,
    className: ""
  };
  const CountUp = (props) => {
    const {
      maxLen,
      endNumber,
      delaySpeed,
      easeSpeed,
      className,
      thousands,
      ...reset
    } = {
      ...defaultProps$z,
      ...props
    };
    const b2 = cn("countup");
    const countupRef = React.useRef(null);
    const timerRef = React.useRef(0);
    const numbers = Array.from({ length: 10 }, (v, i) => i);
    const getShowNumber = () => {
      const splitArr = endNumber.split(".");
      const intNumber = maxLen && splitArr[0].length < maxLen ? (Array(maxLen).join("0") + splitArr[0]).slice(-maxLen) : splitArr[0];
      const currNumber = `${thousands ? intNumber.replace(/(\d)(?=(?:\d{3})+$)/g, "$1,") : intNumber}${splitArr[1] ? "." : ""}${splitArr[1] || ""}`;
      return currNumber.split("");
    };
    const [numerArr, setNumerArr] = React.useState([]);
    const [transformArr, setTransformArr] = React.useState([]);
    const isLoaded = React.useRef(false);
    const setNumberTransform = () => {
      if (countupRef.current && numerArr.length) {
        Taro.createSelectorQuery().selectAll(".nut-countup__listitem").node((numberItems) => {
          const transformArrCache = [];
          Object.keys(numberItems).forEach((key) => {
            const elem = numberItems[Number(key)];
            const idx = Number(numerArr[Number(key)]);
            if (elem) {
              const transform = idx || idx === 0 ? `translate(0, -${(idx === 0 ? 10 : idx) * 5}%)` : "";
              transformArrCache.push(transform);
            }
          });
          setTransformArr([...transformArrCache]);
        }).exec();
      }
    };
    const numberEaseStyle = (idx) => {
      return {
        transition: `transform ${easeSpeed}s ease-in-out`,
        transform: transformArr[idx] ? transformArr[idx] : null
      };
    };
    React.useEffect(() => {
      setNumberTransform();
    }, [numerArr]);
    React.useEffect(() => {
      if (!isLoaded.current) {
        isLoaded.current = true;
        timerRef.current = window.setTimeout(() => {
          setNumerArr(getShowNumber());
        }, delaySpeed);
      } else {
        setNumerArr(getShowNumber());
      }
      return () => {
        window.clearTimeout(timerRef.current);
      };
    }, [endNumber]);
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, ref: countupRef }, /* @__PURE__ */ React.createElement("ul", { className: b2("list") }, numerArr.map((item, idx) => {
      return /* @__PURE__ */ React.createElement(
        "li",
        {
          className: `${b2("listitem", {
            number: !Number.isNaN(Number(item))
          })}`,
          key: idx
        },
        !Number.isNaN(Number(item)) ? /* @__PURE__ */ React.createElement("span", { className: b2("number"), style: numberEaseStyle(idx) }, [...numbers, ...numbers].map((number, subidx) => {
          return /* @__PURE__ */ React.createElement("span", { key: subidx }, number);
        })) : /* @__PURE__ */ React.createElement("span", { className: b2("separator") }, item)
      );
    })));
  };
  CountUp.defaultProps = defaultProps$z;
  CountUp.displayName = "NutCountUp";
  const defaultProps$y = {};
  class AnimatingNumbers extends React.Component {
    constructor(props) {
      super(props);
      this.state = {};
    }
    render() {
      return /* @__PURE__ */ React.createElement("div", { className: "nut-animatingnumbers" });
    }
  }
  __publicField(AnimatingNumbers, "defaultProps", defaultProps$y);
  __publicField(AnimatingNumbers, "displayName", "NutAnimatingNumbers");
  __publicField(AnimatingNumbers, "CountUp", CountUp);
  const b$1 = cn("audio");
  const warn = console.warn;
  const defaultProps$x = {
    ...ComponentDefaults,
    className: "",
    url: "",
    style: {},
    autoplay: false,
    loop: false,
    type: "progress",
    onFastBack: (ctx2) => {
    },
    // type 为 progress时生效
    onForward: (ctx2) => {
    },
    // type 为 progress时生效
    onPause: (ctx2) => {
    },
    onPlay: (ctx2) => {
    },
    onPlayEnd: (ctx2) => {
    },
    onCanPlay: (ctx2) => {
    }
  };
  const Audio = (props) => {
    const { locale } = useConfig$1();
    const {
      className,
      url,
      style,
      autoplay,
      loop: loop2,
      type,
      onFastBack,
      onForward,
      onPause,
      onPlay,
      onPlayEnd,
      onCanPlay,
      children,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$x,
      ...props
    };
    const [playing, setPlaying] = React.useState(false);
    const [totalSeconds, setTotalSeconds] = React.useState(0);
    const [percent, setPercent] = React.useState(0);
    const [isCanPlay, setIsCanPlay] = React.useState(false);
    const [currentDuration, setCurrentDuration] = React.useState("00:00:00");
    const statusRef = React.useRef({
      currentTime: 0,
      currentDuration: "00:00:00",
      percent: 0
    });
    const audioRef = React.useRef(Taro.createInnerAudioContext());
    const audioCtx = audioRef.current;
    audioCtx.src = url;
    audioCtx.autoplay = autoplay || false;
    audioCtx.loop = loop2 || false;
    audioCtx.onPause(() => {
      props.onPause && props.onPause(audioCtx);
    });
    audioCtx.onEnded(() => {
      if (props.loop) {
        warn(locale.audio.tips || "onPlayEnd事件在loop=false时才会触发");
      } else {
        props.onPlayEnd && props.onPlayEnd(audioCtx);
      }
    });
    audioCtx.onPlay(() => {
      const { duration } = audioCtx;
      setTotalSeconds(Math.floor(duration));
      props.onPlay && props.onPlay(audioCtx);
    });
    audioCtx.onCanplay(() => {
      const intervalID = setInterval(function() {
        if (audioCtx.duration !== 0) {
          setTotalSeconds(audioCtx.duration);
          clearInterval(intervalID);
        }
      }, 500);
      setIsCanPlay(true);
      props.onCanPlay && props.onCanPlay(audioCtx);
    });
    audioCtx.onTimeUpdate(() => {
      const time = parseInt(`${audioCtx.currentTime}`);
      const formated = formatSeconds(`${time}`);
      statusRef.current.currentDuration = formated;
      setPercent(time / totalSeconds * 100);
      setCurrentDuration(formatSeconds(audioCtx.currentTime.toString()));
    });
    audioCtx.onError((res) => {
      console.log("code", res.errCode);
      console.log("message", res.errMsg);
    });
    function formatSeconds(value) {
      if (!value) {
        return "00:00:00";
      }
      const time = parseInt(value);
      const hours = Math.floor(time / 3600);
      const minutes = Math.floor((time - hours * 3600) / 60);
      const secondss = time - hours * 3600 - minutes * 60;
      let result = "";
      result += `${`0${hours.toString()}`.slice(-2)}:`;
      result += `${`0${minutes.toString()}`.slice(-2)}:`;
      result += `0${secondss.toString()}`.slice(-2);
      return result;
    }
    const handleBack = () => {
      const currentTime = Math.floor(audioCtx.currentTime);
      statusRef.current.currentTime = Math.max(currentTime - 1, 0);
      setCurrentDuration(formatSeconds(statusRef.current.currentTime.toString()));
      audioCtx.seek(statusRef.current.currentTime);
      props.onFastBack && props.onFastBack(audioCtx);
    };
    const handleForward = () => {
      const currentTime = Math.floor(audioCtx.currentTime);
      statusRef.current.currentTime = Math.min(currentTime + 1, audioCtx.duration);
      setCurrentDuration(formatSeconds(statusRef.current.currentTime.toString()));
      audioCtx.seek(statusRef.current.currentTime);
      props.onForward && props.onForward(audioCtx);
    };
    const handleStatusChange = () => {
      setPlaying(!playing);
      if (!playing) {
        audioCtx.play();
      } else {
        audioCtx.pause();
      }
    };
    const renderIcon = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: b$1("icon") }, /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${b$1("icon-box")} ${playing ? b$1("icon-play") : b$1("icon-stop")}`,
          onClick: handleStatusChange
        },
        playing ? /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "service",
            className: "nut-icon-loading"
          }
        ) : /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "service"
          }
        )
      )));
    };
    const renderProgerss = () => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: b$1("progress") }, /* @__PURE__ */ React.createElement("div", { className: "time" }, currentDuration), /* @__PURE__ */ React.createElement("div", { className: b$1("progress-bar-wrapper") }, /* @__PURE__ */ React.createElement(
        Range,
        {
          modelValue: percent,
          hiddenTag: true,
          hiddenRange: true,
          "inactive-color": "#cccccc",
          "active-color": "#fa2c19"
        }
      )), /* @__PURE__ */ React.createElement("div", { className: "time" }, formatSeconds(`${totalSeconds}`) || "00:00:00")), /* @__PURE__ */ React.createElement(
        "div",
        {
          className: isCanPlay ? "custom-button-group" : "custom-button-group-disable"
        },
        /* @__PURE__ */ React.createElement(
          Button,
          {
            type: "primary",
            size: "small",
            className: "back",
            onClick: handleBack
          },
          locale.audio.back || "快退"
        ),
        /* @__PURE__ */ React.createElement(
          Button,
          {
            type: "primary",
            size: "small",
            className: "start",
            onClick: handleStatusChange
          },
          playing ? `${locale.audio.pause || "暂停"}` : `${locale.audio.start || "开始"}`
        ),
        /* @__PURE__ */ React.createElement(Button, { type: "primary", size: "small", onClick: handleForward }, locale.audio.forward || "快进")
      ));
    };
    const renderNone = () => {
      return /* @__PURE__ */ React.createElement("div", { className: b$1("none-container"), onClick: handleStatusChange }, children);
    };
    const renderAudio = () => {
      switch (type) {
        case "icon":
          return renderIcon();
        case "progress":
          return renderProgerss();
        case "none":
          return renderNone();
        default:
          return null;
      }
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${b$1()} ${className}`, style, ...rest }, renderAudio());
  };
  Audio.defaultProps = defaultProps$x;
  Audio.displayName = "NutAudio";
  const AvatarContext = React.createContext({});
  const defaultProps$w = {
    ...ComponentDefaults,
    size: "",
    icon: "",
    iconSize: "",
    bgColor: "#eee",
    color: "#666",
    prefixCls: "nut-avatar",
    url: ""
  };
  const Avatar = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const {
      children,
      prefixCls,
      size,
      shape,
      bgColor,
      color,
      url,
      icon,
      iconSize,
      className,
      style,
      activeAvatar,
      onActiveAvatar,
      onError,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$w,
      ...props
    };
    const [maxSum, setMaxSum] = React.useState(0);
    const [showMax, setShowMax] = React.useState(false);
    const [avatarIndex, setAvatarIndex] = React.useState(1);
    const avatarRef = React.useRef(null);
    const parent = React.useContext(AvatarContext);
    const b2 = cn("avatar");
    const classes = classNames({
      [`nut-avatar-${size || ((_a = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _a.size) || "normal"}`]: true,
      [`nut-avatar-${shape || ((_b = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _b.shape) || "round"}`]: true
    });
    const cls = classNames(b2(""), classes, className);
    const sizeValue = ["large", "normal", "small"];
    const styles = {
      width: sizeValue.indexOf(size) > -1 ? "" : `${size}px`,
      height: sizeValue.indexOf(size) > -1 ? "" : `${size}px`,
      backgroundColor: `${bgColor}`,
      color: `${color}`,
      marginLeft: avatarIndex !== 1 && ((_c = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _c.span) ? `${(_d = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _d.span}px` : "",
      zIndex: ((_e = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _e.zIndex) === "right" ? `${Math.abs(maxSum - avatarIndex)}` : "",
      ...style
    };
    const maxStyles = {
      backgroundColor: `${(_f = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _f.maxBgColor}`,
      color: `${(_g = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _g.maxColor}`
    };
    const iconStyles = icon || "";
    React.useEffect(() => {
      var _a2;
      const avatarChildren = (_a2 = parent == null ? void 0 : parent.avatarGroupRef) == null ? void 0 : _a2.current.children;
      if (avatarChildren) {
        avatarLength(avatarChildren);
      }
    }, []);
    const avatarLength = (children2) => {
      var _a2, _b2, _c2;
      for (let i = 0; i < children2.length; i++) {
        if (children2[i] && children2[i].classList && (children2[i].classList[0] === "nut-avatar" || children2[i].classList.values().next().value === "nut-avatar")) {
          children2[i].setAttribute("data-index", i + 1);
        }
      }
      const index = (_b2 = (_a2 = avatarRef == null ? void 0 : avatarRef.current) == null ? void 0 : _a2.dataset) == null ? void 0 : _b2.index;
      const maxCount = (_c2 = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _c2.maxCount;
      setMaxSum(children2.length);
      setAvatarIndex(index);
      if (index === children2.length && index !== maxCount && children2.length > maxCount) {
        setShowMax(true);
      }
    };
    const errorEvent = (e) => {
      if (props.onError) {
        props.onError(e);
      }
    };
    const clickAvatar = (e) => {
      activeAvatar && activeAvatar(e);
      onActiveAvatar && onActiveAvatar(e);
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, (showMax || !((_h = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _h.maxCount) || avatarIndex <= ((_i = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _i.maxCount)) && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: cls,
        ...rest,
        style: !showMax ? styles : maxStyles,
        onClick: clickAvatar,
        ref: avatarRef
      },
      (!((_j = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _j.maxCount) || avatarIndex <= ((_k = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _k.maxCount)) && /* @__PURE__ */ React.createElement(React.Fragment, null, url && /* @__PURE__ */ React.createElement(components.Image, { className: "avatar-img", src: url, onError: errorEvent }), icon && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          className: "icon",
          name: iconStyles,
          size: iconSize
        }
      ), children && /* @__PURE__ */ React.createElement("span", { className: "text" }, children)),
      showMax && /* @__PURE__ */ React.createElement("div", { className: "text" }, ((_l = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _l.maxContent) ? (_m = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _m.maxContent : `+ ${avatarIndex - ((_n = parent == null ? void 0 : parent.propAvatarGroup) == null ? void 0 : _n.maxCount)}`)
    ));
  };
  Avatar.defaultProps = defaultProps$w;
  Avatar.displayName = "NutAvatar";
  const defaultProps$v = {
    maxContent: "",
    maxCount: "",
    maxBgColor: "#eee",
    maxColor: "#666",
    size: "",
    shape: "",
    span: "-8",
    zIndex: "left"
  };
  const AvatarGroup = (props) => {
    useConfig();
    const propAvatarGroup = { ...defaultProps$v, ...props };
    const { className, style, children } = propAvatarGroup;
    const avatarGroupRef = React.useRef(null);
    const b2 = cn("avatar-group");
    const cls = classNames(b2(""), className);
    const parentAvatar = {
      propAvatarGroup,
      avatarGroupRef
    };
    return /* @__PURE__ */ React.createElement(AvatarContext.Provider, { value: parentAvatar }, /* @__PURE__ */ React.createElement("div", { className: cls, style, ref: avatarGroupRef }, children));
  };
  AvatarGroup.defaultProps = defaultProps$v;
  AvatarGroup.displayName = "NutAvatarGroup";
  const b = cn("badge");
  const defaultProps$u = {
    ...ComponentDefaults,
    className: "",
    value: "",
    dot: false,
    max: 1e4,
    top: "0",
    right: "0",
    zIndex: "0",
    color: "",
    icons: ""
  };
  const Badge = (props) => {
    const {
      className,
      style,
      children,
      dot,
      top,
      right,
      zIndex,
      color,
      icons,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$u,
      ...props
    };
    function content() {
      if (dot)
        return void 0;
      const { value } = props;
      const { max } = props;
      if (typeof value === "number" && typeof max === "number") {
        return max < value ? `${max}+` : value;
      }
      return value;
    }
    const getStyle = () => {
      const style2 = {};
      style2.top = `${Number(top) || parseFloat(top) || 0}px`;
      style2.right = `${Number(right) || parseFloat(right) || 0}px`;
      style2.zIndex = zIndex;
      style2.background = color;
      return style2;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classNames(b(), className), style }, icons !== "" && /* @__PURE__ */ React.createElement("div", { className: "slot-icons" }, /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        className: "_icon",
        name: icons,
        color: "#ffffff",
        size: "12"
      }
    )), /* @__PURE__ */ React.createElement("div", null, children), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames({ "is-dot": dot }, b("content"), "sup"),
        style: getStyle()
      },
      content()
    ));
  };
  Badge.defaultProps = defaultProps$u;
  Badge.displayName = "NutBadge";
  const defaultProps$t = {
    strokeWidth: 5,
    radius: 50,
    strokeLinecap: "round",
    circleColor: "#fa2c19",
    pathColor: "#e5e9f2",
    clockwise: true
  };
  const CircleProgress = (props) => {
    const {
      children,
      progress,
      className,
      radius,
      pathColor,
      clockwise,
      circleColor,
      strokeWidth,
      style,
      strokeLinecap,
      ...restProps
    } = {
      ...defaultProps$t,
      ...props
    };
    const [oldValue, setOldValue] = React.useState(progress);
    const b2 = cn("circleprogress");
    const classes = classNames(className, b2(""));
    const refRandomId = Math.random().toString(36).slice(-8);
    const styles = {
      height: `${Number(radius) * 2}px`,
      width: `${Number(radius) * 2}px`,
      ...style
    };
    React.useEffect(() => {
      let rafId;
      const startTime = Date.now();
      const startRate = Number(oldValue);
      const endRate = Number(progress);
      const duration = Math.abs((startRate - endRate) * 1e3 / 100);
      const animate = () => {
        const now = Date.now();
        const progress2 = Math.min((now - startTime) / duration, 1);
        const rate = progress2 * (endRate - startRate) + startRate;
        setOldValue(Math.min(Math.max(+rate, 0), 100));
        if (endRate > startRate ? rate < endRate : rate > endRate) {
          rafId = window.requestAnimationFrame(animate);
        }
      };
      if (rafId) {
        cancelAnimationFrame2(rafId);
      }
      rafId = window.requestAnimationFrame(animate);
    }, [progress]);
    const cancelAnimationFrame2 = function(id) {
      clearTimeout(id);
    };
    const stop2 = () => {
      if (!isObject(circleColor)) {
        return [];
      }
      const color = circleColor;
      const colorArr = Object.keys(color).sort(
        (a, b22) => parseFloat(a) - parseFloat(b22)
      );
      const stopArr = [];
      colorArr.map((item) => {
        const obj = {
          key: "",
          value: ""
        };
        obj.key = item;
        obj.value = color[item];
        stopArr.push(obj);
      });
      return stopArr;
    };
    const transColor = (color) => {
      return color && color.replace("#", "%23");
    };
    const format = (progress2) => Math.min(Math.max(+progress2, 0), 100);
    const circleStyle = () => {
      const stopArr = stop2();
      const stopDom = [];
      if (stopArr) {
        stopArr.map((item) => {
          let obj = "";
          obj = `%3Cstop offset='${item.key}' stop-color='${transColor(
            item.value
          )}'/%3E`;
          stopDom.push(obj);
        });
      }
      const perimeter = 283;
      const progress2 = +oldValue;
      const offset = perimeter * Number(format(parseFloat(progress2.toFixed(1)))) / 100;
      const isWise = props.clockwise ? 1 : 0;
      const color = isObject(circleColor) ? `url(%23${refRandomId})` : transColor(circleColor);
      const d = `M 50 50 m 0 -45 a 45 45 0 1 ${isWise} 0 90 a 45 45 0 1, ${isWise} 0 -90`;
      const pa = `%3Cdefs%3E%3ClinearGradient id='${refRandomId}' x1='100%25' y1='0%25' x2='0%25' y2='0%25'%3E${stopDom}%3C/linearGradient%3E%3C/defs%3E`;
      const path = `%3Cpath d='${d}' stroke-width='${strokeWidth}' stroke='${transColor(
        props.pathColor
      )}' fill='none'/%3E`;
      const path1 = `%3Cpath d='${d}' stroke-width='${strokeWidth}' stroke-dasharray='${offset},${perimeter}' stroke-linecap='round' stroke='${transColor(
        color
      )}' fill='none'/%3E`;
      return {
        background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100'  xmlns='http://www.w3.org/2000/svg'%3E${pa}${path}${path1}%3C/svg%3E")`,
        width: "100%",
        height: "100%"
      };
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style: styles, ...restProps }, /* @__PURE__ */ React.createElement("div", { style: circleStyle() }), /* @__PURE__ */ React.createElement("div", { className: "nut-circleprogress-text" }, children || /* @__PURE__ */ React.createElement("div", null, progress, "%")));
  };
  CircleProgress.defaultProps = defaultProps$t;
  CircleProgress.displayName = "NutCircleProgress";
  const defaultProps$s = {
    activeName: ["0"],
    accordion: false,
    icon: "",
    iconSize: "16px",
    iconColor: "",
    rotate: 180
  };
  function areEqual(prevProps, nextProps) {
    return prevProps.children === nextProps.children && JSON.stringify(prevProps.activeName) === JSON.stringify(nextProps.activeName);
  }
  const Collapse = React.memo(
    (props) => {
      const {
        className,
        style,
        children,
        activeName,
        accordion,
        icon,
        rotate,
        iconSize,
        iconColor,
        onChange
      } = {
        ...defaultProps$s,
        ...props
      };
      const childrenDom = React.Children.toArray(children);
      const [defaultOpenIndex, setDefaultOpenIndex] = React.useState([]);
      const handleActiveName = () => {
        let activeArr = [];
        if (!Array.isArray(activeName)) {
          activeArr.push(activeName.toString());
        } else {
          if (accordion && activeName.length > 1) {
            console.warn("手风琴模式不支持传递多个打开页签");
          }
          const activeNameStr = activeName.map((item) => {
            return item.toString();
          });
          activeArr = [...activeNameStr];
        }
        return activeArr;
      };
      const colBem = cn("collapse");
      React.useEffect(() => {
        const activeArr = handleActiveName();
        setDefaultOpenIndex(activeArr);
      }, [activeName]);
      const onToggle = (isOpen, name) => {
        let newOpenIndex = [...defaultOpenIndex];
        if (isOpen) {
          const removeIndex = newOpenIndex.findIndex((value) => {
            return value === name;
          });
          newOpenIndex.splice(removeIndex, 1);
        } else {
          if (accordion) {
            newOpenIndex = [name];
          } else {
            newOpenIndex.push(name);
          }
        }
        setDefaultOpenIndex(newOpenIndex);
        onChange && onChange(!isOpen, name);
      };
      return /* @__PURE__ */ React.createElement("div", { className: classNames(colBem(), className), style }, childrenDom.map((item) => {
        return React.cloneElement(item, {
          isOpen: defaultOpenIndex.includes(item.props.name),
          onToggle: (isOpen, name) => onToggle(isOpen, name),
          icon,
          rotate,
          iconSize,
          iconColor
        });
      }));
    },
    areEqual
  );
  Collapse.defaultProps = defaultProps$s;
  Collapse.displayName = "NutCollapse";
  const defaultProps$r = {
    ...ComponentDefaults,
    title: "",
    name: "",
    isOpen: false,
    icon: "",
    iconSize: "",
    iconColor: "",
    disabled: false,
    rotate: 180,
    subTitle: "",
    titleIcon: "",
    titleIconColor: "",
    titleIconPosition: "",
    titleIconSize: "",
    childnull: true
  };
  const CollapseItem = (props) => {
    const {
      children,
      title,
      isOpen,
      onToggle,
      name,
      disabled,
      icon,
      rotate,
      subTitle,
      titleIcon,
      titleIconColor,
      titleIconPosition,
      titleIconSize,
      iconSize,
      iconColor,
      childnull,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$r,
      ...props
    };
    const [domHeight, setDomHeight] = React.useState(-1);
    const [currHeight, setCurrHeight] = React.useState("auto");
    const [update2, setUpdate] = React.useState(false);
    const [iconStyle, setIconStyle] = React.useState({
      transform: "translateY(-50%)"
    });
    const colBem = cn("collapse-item");
    const measuredRef = React.useCallback(
      (node) => {
        if (node !== null) {
          setDomHeight(node.getBoundingClientRect().height);
        }
      },
      [update2]
    );
    React.useEffect(() => {
      setTimeout(() => {
        if (domHeight !== -1) {
          isOpen ? setCurrHeight(`auto`) : setCurrHeight("0px");
        }
        const newIconStyle = isOpen ? { transform: `translateY(-50%) rotate(${rotate}deg)` } : { transform: "translateY(-50%)" };
        setIconStyle(newIconStyle);
      }, 10);
    }, [isOpen, domHeight, rotate]);
    React.useEffect(() => {
      if (!isOpen) {
        setCurrHeight("0px");
      } else {
        setCurrHeight("auto");
      }
      setUpdate(!update2);
    }, [children, isOpen]);
    return /* @__PURE__ */ React.createElement("div", { className: colBem(), ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: colBem("header", { disabled }),
        onClick: () => {
          if (disabled)
            return;
          onToggle && onToggle(isOpen, name);
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: colBem("title") }, titleIcon && titleIconPosition === "left" && /* @__PURE__ */ React.createElement("b", { className: colBem("title-icon-left") }, /* @__PURE__ */ React.createElement(
        Icon,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: titleIcon,
          size: titleIconSize,
          color: disabled ? "#C2C2C2" : titleIconColor
        }
      )), title, titleIcon && titleIconPosition === "right" && /* @__PURE__ */ React.createElement("b", { className: colBem("title-icon-right") }, /* @__PURE__ */ React.createElement(
        Icon,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: titleIcon,
          size: titleIconSize,
          color: disabled ? "#C2C2C2" : titleIconColor
        }
      ))),
      /* @__PURE__ */ React.createElement("div", { className: colBem("sub-title") }, subTitle),
      /* @__PURE__ */ React.createElement("div", { className: colBem("icon-box") }, /* @__PURE__ */ React.createElement("div", { className: colBem("icon"), style: iconStyle }, /* @__PURE__ */ React.createElement(
        Icon,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: icon,
          size: iconSize,
          color: disabled ? "#C2C2C2" : iconColor
        }
      )))
    ), childnull && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: colBem("content"),
        style: { height: currHeight },
        ref: measuredRef
      },
      /* @__PURE__ */ React.createElement("div", { className: colBem("content-text") }, children)
    ));
  };
  CollapseItem.defaultProps = defaultProps$r;
  CollapseItem.displayName = "NutCollapseItem";
  const defaultProps$q = {
    paused: false,
    startTime: Date.now(),
    endTime: Date.now(),
    remainingTime: 0,
    millisecond: false,
    format: "HH:mm:ss",
    autoStart: true,
    time: 0,
    destroy: false
  };
  const InternalCountDown = (props, ref) => {
    useConfig$1();
    const {
      paused,
      startTime,
      endTime,
      remainingTime,
      millisecond,
      format,
      autoStart,
      time,
      destroy,
      className,
      style,
      onEnd,
      onPaused,
      onRestart,
      onUpdate,
      children,
      ...rest
    } = { ...defaultProps$q, ...props };
    const b2 = cn("countdown");
    const [restTimeStamp, setRestTime] = React.useState(0);
    const stateRef = React.useRef({
      pauseTime: 0,
      curr: 0,
      isPaused: paused,
      isIninted: false,
      timer: 0,
      restTime: 0,
      // 倒计时剩余时间时间
      counting: !paused && autoStart,
      // 是否处于倒计时中
      handleEndTime: Date.now(),
      // 最终截止时间
      diffTime: 0
      // 设置了 startTime 时，与 date.now() 的差异
    });
    const getTimeStamp = (timeStr) => {
      if (!timeStr)
        return Date.now();
      let t = timeStr;
      t = t > 0 ? +t : t.toString().replace(/-/g, "/");
      return new Date(t).getTime();
    };
    const initTime = () => {
      if (remainingTime) {
        stateRef.current.handleEndTime = Date.now() + Number(remainingTime);
      } else {
        stateRef.current.handleEndTime = endTime;
        stateRef.current.diffTime = Date.now() - getTimeStamp(startTime);
      }
      if (!stateRef.current.counting)
        stateRef.current.counting = true;
      tick();
    };
    const tick = () => {
      stateRef.current.timer = requestAnimationFrame(() => {
        if (stateRef.current.counting) {
          const currentTime = Date.now() - stateRef.current.diffTime;
          const remainTime = Math.max(
            stateRef.current.handleEndTime - currentTime,
            0
          );
          stateRef.current.restTime = remainTime;
          setRestTime(remainTime);
          if (!remainTime) {
            stateRef.current.counting = false;
            pause();
            onEnd && onEnd();
          }
          if (remainTime > 0) {
            tick();
          }
        }
      });
    };
    const formatRemainTime = (t, type) => {
      const ts2 = t;
      const rest2 = {
        d: 0,
        h: 0,
        m: 0,
        s: 0,
        ms: 0
      };
      const SECOND = 1e3;
      const MINUTE = 60 * SECOND;
      const HOUR = 60 * MINUTE;
      const DAY = 24 * HOUR;
      if (ts2 > 0) {
        rest2.d = ts2 >= SECOND ? Math.floor(ts2 / DAY) : 0;
        rest2.h = Math.floor(ts2 % DAY / HOUR);
        rest2.m = Math.floor(ts2 % HOUR / MINUTE);
        rest2.s = Math.floor(ts2 % MINUTE / SECOND);
        rest2.ms = Math.floor(ts2 % SECOND);
      }
      return type === "custom" ? rest2 : parseFormat({ ...rest2 });
    };
    const parseFormat = (time2) => {
      const { d } = time2;
      let { h, m, s, ms } = time2;
      let formatCache = format;
      if (formatCache.includes("DD")) {
        formatCache = formatCache.replace("DD", padZero(d));
      } else {
        h += Number(d) * 24;
      }
      if (formatCache.includes("HH")) {
        formatCache = formatCache.replace("HH", padZero(h));
      } else {
        m += Number(h) * 60;
      }
      if (formatCache.includes("mm")) {
        formatCache = formatCache.replace("mm", padZero(m));
      } else {
        s += Number(m) * 60;
      }
      if (formatCache.includes("ss")) {
        formatCache = formatCache.replace("ss", padZero(s));
      } else {
        ms += Number(s) * 1e3;
      }
      if (formatCache.includes("S")) {
        const msC = padZero(ms, 3).toString();
        if (formatCache.includes("SSS")) {
          formatCache = formatCache.replace("SSS", msC);
        } else if (formatCache.includes("SS")) {
          formatCache = formatCache.replace("SS", msC.slice(0, 2));
        } else if (formatCache.includes("S")) {
          formatCache = formatCache.replace("SS", msC.slice(0, 1));
        }
      }
      return formatCache;
    };
    const padZero = (num, length = 2) => {
      num += "";
      while (num.length < length) {
        num = `0${num}`;
      }
      return num.toString();
    };
    const pause = () => {
      cancelAnimationFrame(stateRef.current.timer);
      stateRef.current.counting = false;
      onPaused && onPaused(stateRef.current.restTime);
    };
    React.useImperativeHandle(ref, () => ({
      start: () => {
        if (!stateRef.current.counting && !autoStart) {
          stateRef.current.counting = true;
          stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
          tick();
          onRestart && onRestart(stateRef.current.restTime);
        }
      },
      pause: () => {
        cancelAnimationFrame(stateRef.current.timer);
        stateRef.current.counting = false;
        onPaused && onPaused(stateRef.current.restTime);
      },
      reset: () => {
        if (!autoStart) {
          pause();
          stateRef.current.restTime = time;
          setRestTime(time);
        }
      }
    }));
    React.useEffect(() => {
      const tranTime = formatRemainTime(stateRef.current.restTime, "custom");
      onUpdate && onUpdate(tranTime);
    }, [restTimeStamp]);
    React.useEffect(() => {
      if (stateRef.current.isIninted) {
        if (paused) {
          if (stateRef.current.counting) {
            pause();
          }
        } else {
          if (!stateRef.current.counting) {
            stateRef.current.counting = true;
            stateRef.current.handleEndTime = Date.now() + Number(stateRef.current.restTime);
            tick();
          }
          onRestart && onRestart(stateRef.current.restTime);
        }
      }
    }, [paused]);
    React.useEffect(() => {
      if (stateRef.current.isIninted) {
        initTime();
      }
    }, [endTime, startTime, remainingTime]);
    React.useEffect(() => {
      if (autoStart) {
        initTime();
      } else {
        stateRef.current.restTime = time;
        setRestTime(time);
      }
      if (!stateRef.current.isIninted) {
        stateRef.current.isIninted = true;
      }
      return componentWillUnmount;
    }, []);
    const componentWillUnmount = () => {
      destroy && cancelAnimationFrame(stateRef.current.timer);
    };
    const renderTime = (() => {
      return formatRemainTime(stateRef.current.restTime);
    })();
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className || ""}`, style: { ...style }, ...rest }, children || /* @__PURE__ */ React.createElement(
      "div",
      {
        className: b2("block"),
        dangerouslySetInnerHTML: {
          __html: `${renderTime}`
        }
      }
    ));
  };
  const CountDown = React.forwardRef(InternalCountDown);
  CountDown.defaultProps = defaultProps$q;
  CountDown.displayName = "NutCountDown";
  const defaultProps$p = {
    content: "",
    direction: "end",
    rows: 1,
    expandText: "",
    collapseText: "",
    symbol: "...",
    lineHeight: "20"
  };
  const Ellipsis = (props) => {
    var _a, _b, _c, _d;
    useConfig$1();
    const {
      children,
      content,
      direction,
      rows,
      expandText,
      collapseText,
      symbol,
      lineHeight,
      onClick,
      onChange
    } = { ...defaultProps$p, ...props };
    let maxHeight = 0;
    const [exceeded, setExceeded] = React.useState(false);
    const [expanded, setExpanded] = React.useState(false);
    const ellipsis = React.useRef({
      leading: "",
      tailing: ""
    });
    const root2 = React.useRef(null);
    const rootContain = React.useRef(null);
    const symbolContain = React.useRef(null);
    const [contentCopy, setContentCopy] = React.useState(content);
    let lineH = 0;
    let originHeight = 0;
    const refRandomId = Math.random().toString(36).slice(-8);
    const widthRef = React.useRef("auto");
    let widthBase = [14, 10, 7, 8.4, 10];
    let symbolTextWidth = widthBase[0] * 0.7921;
    const chineseReg = /^[\u4e00-\u9fa5]+$/;
    const digitReg = /^[0-9]+$/;
    const letterUpperReg = /^[A-Z]+$/;
    const letterLowerReg = /^[a-z]+$/;
    const init = () => {
      setExceeded(false);
      setExpanded(false);
      setContentCopy(content);
      Taro.nextTick(() => {
        getSymbolInfo();
        getReference();
      });
    };
    Taro.useReady(() => init());
    React.useEffect(() => init(), [content]);
    const getSymbolInfo = async () => {
      const refe = await getRectByTaro(symbolContain == null ? void 0 : symbolContain.current);
      symbolTextWidth = refe.width ? Math.ceil(refe.width) : Math.ceil(widthBase[0] * 0.7921);
    };
    const symbolText = () => {
      if (direction === "end" || direction === "middle") {
        return `${symbol}${expandText}`;
      }
      return `${symbol}${expandText}${symbol}`;
    };
    const getReference = async () => {
      const element = root2.current;
      const query = Taro.createSelectorQuery();
      query.select(`#${element.id}`) && query.select(`#${element.id}`).fields(
        {
          computedStyle: [
            "width",
            "height",
            "lineHeight",
            "paddingTop",
            "paddingBottom",
            "fontSize"
          ]
        },
        (res) => {
          if (!res)
            return;
          lineH = pxToNumber(
            res.lineHeight === "normal" ? lineHeight : res.lineHeight
          );
          maxHeight = Math.floor(
            lineH * (Number(rows) + 0.5) + pxToNumber(res.paddingTop) + pxToNumber(res.paddingBottom)
          );
          originHeight = pxToNumber(res.height);
          widthRef.current = res.width;
          const bsize = pxToNumber(res.fontSize);
          widthBase = [
            bsize,
            bsize * 0.72,
            bsize * 0.53,
            bsize * 0.4,
            bsize * 0.75
          ];
          calcEllipse();
        }
      ).exec();
    };
    const calcEllipse = async () => {
      const refe = await getRectByTaro(rootContain.current);
      if (refe.height <= maxHeight) {
        setExceeded(false);
      } else {
        const rowNum = Math.floor(content.length / (originHeight / lineH - 1));
        if (direction === "middle") {
          const end = content.length;
          ellipsis.current.leading = tailorContent(
            0,
            rowNum * (Number(rows) + 0.5),
            "end"
          );
          ellipsis.current.tailing = tailorContent(
            content.length - rowNum * (Number(rows) + 0.5),
            end,
            "start"
          );
        } else if (direction === "end") {
          const end = rowNum * (Number(rows) + 0.5);
          ellipsis.current.leading = tailorContent(0, end);
        } else {
          const start2 = content.length - rowNum * (Number(rows) + 0.5) - 5;
          ellipsis.current.tailing = tailorContent(start2, content.length);
        }
        assignContent();
        setTimeout(() => {
          verifyEllipsis();
        }, 100);
      }
    };
    const verifyEllipsis = async () => {
      var _a2, _b2, _c2, _d2, _e, _f;
      const refe = await getRectByTaro(rootContain.current);
      if (refe && refe.height && refe.height > maxHeight) {
        if (direction === "end") {
          ellipsis.current.leading = (_c2 = (_a2 = ellipsis.current) == null ? void 0 : _a2.leading) == null ? void 0 : _c2.slice(
            0,
            ((_b2 = ellipsis.current) == null ? void 0 : _b2.leading.length) - 1
          );
        } else {
          ellipsis.current.tailing = (_f = (_d2 = ellipsis.current) == null ? void 0 : _d2.tailing) == null ? void 0 : _f.slice(
            1,
            (_e = ellipsis.current) == null ? void 0 : _e.tailing.length
          );
        }
        assignContent();
        setTimeout(() => {
          verifyEllipsis();
        }, 100);
      }
    };
    const assignContent = () => {
      var _a2, _b2, _c2, _d2;
      const newContent = `${((_a2 = ellipsis.current) == null ? void 0 : _a2.leading) || ""}${((_b2 = ellipsis.current) == null ? void 0 : _b2.leading) ? symbol : ""}${expandText || ""}${((_c2 = ellipsis.current) == null ? void 0 : _c2.tailing) ? symbol : ""}${((_d2 = ellipsis.current) == null ? void 0 : _d2.tailing) || ""}`;
      setContentCopy(newContent);
    };
    const tailorContent = (left, right, type = "") => {
      const threeDotWidth = symbolTextWidth;
      const direc = direction === "middle" && type ? type : direction;
      setExceeded(true);
      let widthPart = -1;
      const start2 = left;
      const end = right;
      let cutoff = 0;
      let marking = 0;
      if (direc === "end") {
        marking = start2;
        cutoff = end;
      } else {
        marking = end;
        cutoff = start2;
      }
      const contentWidth = pxToNumber(widthRef.current) * Number(rows) - threeDotWidth;
      const contentPartWidth = direction === "middle" ? contentWidth / 2 : contentWidth;
      while (widthPart < contentPartWidth) {
        const zi = content[marking];
        if (chineseReg.test(zi)) {
          widthPart = Number(widthPart + widthBase[0]);
        } else if (letterUpperReg.test(zi)) {
          widthPart = Number(widthPart + widthBase[1]);
        } else if (letterLowerReg.test(zi)) {
          widthPart = Number(widthPart + widthBase[2]);
        } else if (digitReg.test(zi)) {
          widthPart = Number(widthPart + widthBase[3]);
        } else {
          widthPart = Number(widthPart + widthBase[4]);
        }
        cutoff = marking;
        direc === "end" ? marking++ : marking--;
      }
      if (direc === "end") {
        return content.slice(0, cutoff);
      }
      return content.slice(cutoff, end);
    };
    const pxToNumber = (value) => {
      if (!value)
        return 0;
      const match = value.match(/^\d*(\.\d*)?/);
      return match ? Number(match[0]) : 0;
    };
    const clickHandle = (type) => {
      if (type === 1) {
        setExpanded(true);
        onChange && onChange("expand");
      } else {
        setExpanded(false);
        onChange && onChange("collapse");
      }
    };
    const handleClick = () => {
      onClick && onClick();
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-ellipsis",
        onClick: handleClick,
        ref: root2,
        id: `root${refRandomId}`
      },
      /* @__PURE__ */ React.createElement("div", null, !exceeded ? /* @__PURE__ */ React.createElement("div", { className: "nut-ellipsis-wordbreak" }, content) : null, exceeded && !expanded ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "nut-ellipsis-wordbreak" }, (_a = ellipsis.current) == null ? void 0 : _a.leading, ((_b = ellipsis.current) == null ? void 0 : _b.leading) && symbol, expandText ? /* @__PURE__ */ React.createElement(
        "span",
        {
          className: "nut-ellipsis-text",
          onClick: (e) => {
            e.stopPropagation();
            clickHandle(1);
          }
        },
        expandText
      ) : null, ((_c = ellipsis.current) == null ? void 0 : _c.tailing) && symbol, (_d = ellipsis.current) == null ? void 0 : _d.tailing)) : null, exceeded && expanded ? /* @__PURE__ */ React.createElement(React.Fragment, null, content, expandText ? /* @__PURE__ */ React.createElement(
        "span",
        {
          className: "nut-ellipsis-text",
          onClick: (e) => {
            e.stopPropagation();
            clickHandle(2);
          }
        },
        collapseText
      ) : null) : null)
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-ellipsis-copy",
        ref: rootContain,
        id: `rootContain${refRandomId}`,
        style: { width: `${widthRef}` }
      },
      /* @__PURE__ */ React.createElement("div", null, contentCopy)
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-ellipsis-copy",
        ref: symbolContain,
        id: `symbolContain${refRandomId}`,
        style: { display: "inline" }
      },
      symbolText()
    ));
  };
  Ellipsis.defaultProps = defaultProps$p;
  Ellipsis.displayName = "NutEllipsis";
  const defaultStatus = {
    empty: "https://static-ftcms.jd.com/p/files/61a9e3183985005b3958672b.png",
    error: "https://ftcms.jd.com/p/files/61a9e33ee7dcdbcc0ce62736.png",
    network: "https://static-ftcms.jd.com/p/files/61a9e31de7dcdbcc0ce62734.png"
  };
  const defaultProps$o = {
    description: "无内容",
    image: "empty",
    imageSize: "",
    className: ""
  };
  const Empty = (props) => {
    const { locale } = useConfig$1();
    defaultProps$o.description = locale.noData || defaultProps$o.description;
    const { image, imageSize, description, children, className, ...rest } = {
      ...defaultProps$o,
      ...props
    };
    const [imgStyle, setImgStyle] = React.useState({});
    const b2 = cn("empty");
    let imageNode = image;
    if (typeof image === "string") {
      const isHttpUrl = image.startsWith("https://") || image.startsWith("http://") || image.startsWith("//");
      const imageUrl = isHttpUrl ? image : defaultStatus[image];
      imageNode = /* @__PURE__ */ React.createElement("img", { className: "img", src: imageUrl, alt: "empty" });
    }
    React.useEffect(() => {
      setImgStyle(() => {
        if (!imageSize) {
          return {};
        }
        if (typeof imageSize === "number") {
          return {
            width: `${imageSize}px`,
            height: `${imageSize}px`
          };
        }
        return {
          width: imageSize,
          height: imageSize
        };
      });
    }, [imageSize]);
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, ...rest }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: b2("image"), style: imgStyle }, imageNode), typeof description === "string" ? /* @__PURE__ */ React.createElement("div", { className: b2("description") }, description) : { description }, children));
  };
  Empty.defaultProps = defaultProps$o;
  Empty.displayName = "NutEmpty";
  const DataContext$1 = React.createContext({});
  const defaultProps$n = {
    width: typeof window === "object" ? window.innerWidth : 375,
    height: 0,
    duration: 500,
    initPage: 0,
    autoPlay: 0,
    direction: "horizontal",
    paginationColor: "#fff",
    paginationBgColor: "#ddd",
    paginationVisible: false,
    loop: true,
    touchable: true,
    isPreventDefault: true,
    isStopPropagation: true,
    isCenter: false,
    className: ""
  };
  const DISTANCE = 5;
  const Swiper = React.forwardRef((props, ref) => {
    const propSwiper = { ...defaultProps$n, ...props };
    const {
      children,
      direction,
      className,
      pageContent,
      onChange,
      initPage,
      paginationColor,
      paginationVisible,
      touchable,
      isPreventDefault,
      isStopPropagation,
      autoPlay,
      isCenter,
      ...rest
    } = propSwiper;
    const container = React.useRef(null);
    const innerRef = React.useRef(null);
    const _swiper = React.useRef({
      moving: false,
      autoplayTimer: null,
      width: 0,
      height: 0,
      offset: 0,
      size: 0
    });
    const [refRandomId] = React.useState(Math.random().toString(36).slice(-8));
    const isVertical = direction === "vertical";
    const [rect, setRect] = React.useState(null);
    let [active, setActive] = React.useState(0);
    const [width, setWidth] = React.useState(0);
    const [height, setHeight] = React.useState(0);
    const [offset, setOffset] = React.useState(0);
    const [childOffset, setChildOffset] = React.useState([]);
    const [ready, setReady] = React.useState(false);
    let size = isVertical ? height : width;
    const [touch, setTouch] = React.useState({
      startX: 0,
      startY: 0,
      deltaX: 0,
      deltaY: 0,
      offsetX: 0,
      offsetY: 0,
      stateDirection: "",
      delta: 0,
      touchTime: 0
    });
    const { childs, childCount } = React.useMemo(() => {
      let childCount2 = 0;
      const childs2 = React.Children.map(props.children, (child) => {
        if (!React.isValidElement(child))
          return null;
        childCount2++;
        return child;
      });
      return {
        childs: childs2,
        childCount: childCount2
      };
    }, [props.children]);
    let trackSize = childCount * Number(size);
    const parent = {
      propSwiper,
      size
    };
    const minOffset = (() => {
      if (rect) {
        const base = isVertical ? rect == null ? void 0 : rect.height : rect == null ? void 0 : rect.width;
        return base - Number(size) * childCount;
      }
      return 0;
    })();
    const stopAutoPlay = () => {
      clearTimeout(_swiper.current.autoplayTimer);
      _swiper.current.autoplayTimer = null;
    };
    const autoplay = () => {
      if (propSwiper.autoPlay <= 0 || childCount <= 1)
        return;
      stopAutoPlay();
      _swiper.current.autoplayTimer = setTimeout(() => {
        next();
        autoplay();
      }, Number(propSwiper.autoPlay));
    };
    const resettPosition = () => {
      _swiper.current.moving = true;
      if (active <= -1) {
        move({ pace: childCount });
      }
      if (active >= childCount) {
        move({ pace: -childCount });
      }
    };
    const prev = () => {
      resettPosition();
      touchReset();
      requestFrame(() => {
        requestFrame(() => {
          _swiper.current.moving = false;
          move({
            pace: -1,
            isEmit: true
          });
        });
      });
    };
    const next = () => {
      resettPosition();
      touchReset();
      requestFrame(() => {
        requestFrame(() => {
          _swiper.current.moving = false;
          move({
            pace: 1,
            isEmit: true
          });
        });
      });
    };
    const to2 = (index) => {
      resettPosition();
      touchReset();
      requestFrame(() => {
        requestFrame(() => {
          _swiper.current.moving = false;
          let targetIndex;
          if (props.loop && childCount === index) {
            targetIndex = active === 0 ? 0 : index;
          } else {
            targetIndex = index % childCount;
          }
          move({
            pace: targetIndex - active,
            isEmit: true
          });
        });
      });
    };
    const resize = () => {
      init(active);
    };
    const move = ({
      pace = 0,
      offset: offset2 = 0,
      isEmit = false,
      movingStatus = false
    }) => {
      if (childCount <= 1)
        return;
      const targetActive = getActive(pace);
      const targetOffset = getOffset(targetActive, offset2);
      if (props.loop) {
        if (Array.isArray(children) && children[0] && targetOffset !== minOffset) {
          const rightBound = targetOffset < minOffset;
          childOffset[0] = rightBound ? trackSize : 0;
        }
        if (Array.isArray(children) && children[childCount - 1] && targetOffset !== 0) {
          const leftBound = targetOffset > 0;
          childOffset[childCount - 1] = leftBound ? -trackSize : 0;
        }
        setChildOffset(childOffset);
      }
      if (isEmit && active !== targetActive) {
        props.onChange && props.onChange((targetActive + childCount) % childCount);
      }
      active = targetActive;
      setActive(targetActive);
      setOffset(targetOffset);
      getStyle(targetOffset);
    };
    const getActive = (pace) => {
      if (pace) {
        const _active = active + pace;
        if (props.loop) {
          return range(_active, -1, childCount);
        }
        return range(_active, 0, childCount - 1);
      }
      return active;
    };
    const getOffset = (active2, offset2 = 0) => {
      let currentPosition = active2 * Number(size);
      if (!props.loop) {
        currentPosition = Math.min(currentPosition, -minOffset);
      }
      let targetOffset = offset2 - currentPosition;
      if (!props.loop) {
        targetOffset = range(targetOffset, minOffset, 0);
      }
      return targetOffset;
    };
    const requestFrame = (fn) => {
      window.requestAnimationFrame.call(window, fn);
    };
    const range = (num, min, max) => {
      return Math.min(Math.max(num, min), max);
    };
    const getDirection2 = (x, y) => {
      if (x > y && x > DISTANCE)
        return "horizontal";
      if (y > x && y > DISTANCE)
        return "vertical";
      return "";
    };
    const touchReset = () => {
      touch.startX = 0;
      touch.startY = 0;
      touch.deltaX = 0;
      touch.deltaY = 0;
      touch.offsetX = 0;
      touch.offsetY = 0;
      touch.delta = 0;
      touch.stateDirection = "";
      touch.touchTime = 0;
    };
    const touchStart = (e) => {
      touchReset();
      touch.startX = e.touches[0].clientX;
      touch.startY = e.touches[0].clientY;
    };
    const touchMove = (e) => {
      touch.deltaX = e.touches[0].clientX - touch.startX;
      touch.deltaY = e.touches[0].clientY - touch.startY;
      touch.offsetX = Math.abs(touch.deltaX);
      touch.offsetY = Math.abs(touch.deltaY);
      touch.delta = isVertical ? touch.deltaY : touch.deltaX;
      if (!touch.stateDirection) {
        touch.stateDirection = getDirection2(touch.offsetX, touch.offsetY);
      }
    };
    const b2 = cn("swiper");
    const classes = classNames(b2(""));
    const contentClass = classNames({
      [`${b2("inner")}`]: true,
      [`${b2("vertical")}`]: isVertical
    });
    const getStyle = (moveOffset = offset) => {
      const target = innerRef.current;
      let _offset = 0;
      if (!isCenter) {
        _offset = moveOffset;
      } else {
        const _size = isVertical ? height : width;
        const val = isVertical ? (rect == null ? void 0 : rect.height) - _size : (rect == null ? void 0 : rect.width) - _size;
        _offset = moveOffset + (active === childCount - 1 && !props.loop ? -val / 2 : val / 2);
      }
      target.style.transitionDuration = `${_swiper.current.moving ? 0 : props.duration}ms`;
      target.style[isVertical ? "height" : "width"] = `${Number(size) * childCount}px`;
      target.style[isVertical ? "width" : "height"] = `${isVertical ? width : height}px`;
      target.style.transform = `translate3D${!isVertical ? `(${_offset}px,0,0)` : `(0,${_offset}px,0)`}`;
    };
    const onTouchStart = (e) => {
      if (props.isPreventDefault)
        e.preventDefault();
      if (props.isStopPropagation)
        e.stopPropagation();
      if (!props.touchable)
        return;
      touchStart(e);
      touch.touchTime = Date.now();
      stopAutoPlay();
      resettPosition();
    };
    const onTouchMove = (e) => {
      if (props.touchable && _swiper.current.moving) {
        touchMove(e);
        if (touch.stateDirection === props.direction) {
          move({
            offset: touch.delta
          });
        }
      }
    };
    const onTouchEnd = (e) => {
      if (!props.touchable || !_swiper.current.moving)
        return;
      const speed = touch.delta / (Date.now() - touch.touchTime);
      const isShouldMove = Math.abs(speed) > 0.3 || Math.abs(touch.delta) > +(size / 2).toFixed(2);
      let pace = 0;
      _swiper.current.moving = false;
      if (isShouldMove && touch.stateDirection === props.direction) {
        const offset2 = isVertical ? touch.offsetY : touch.offsetX;
        if (props.loop) {
          if (offset2 > 0) {
            pace = touch.delta > 0 ? -1 : 1;
          } else {
            pace = 0;
          }
        } else {
          pace = -Math[touch.delta > 0 ? "ceil" : "floor"](touch.delta / size);
        }
        move({
          pace,
          isEmit: true
        });
      } else if (touch.delta) {
        move({ pace: 0 });
      } else {
        getStyle();
      }
      autoplay();
    };
    React.useEffect(() => {
      _swiper.current.activePagination = (active + childCount) % childCount;
    }, [active]);
    const queryRect = (element) => {
      return new Promise((resolve) => {
        const query = Taro.createSelectorQuery();
        query.select(`#${element.id}`) && query.select(`#${element.id}`).boundingClientRect();
        query.exec((res) => {
          resolve(res[0]);
        });
      });
    };
    const init = async (active2 = +propSwiper.initPage) => {
      const rect2 = await queryRect(container.current);
      const _active = Math.max(Math.min(childCount - 1, active2), 0);
      const _width = propSwiper.width ? +propSwiper.width : rect2 == null ? void 0 : rect2.width;
      const _height = propSwiper.height ? +propSwiper.height : rect2 == null ? void 0 : rect2.height;
      size = isVertical ? _height : _width;
      trackSize = childCount * Number(size);
      const targetOffset = getOffset(_active);
      _swiper.current.moving = true;
      if (ready) {
        _swiper.current.moving = false;
      }
      setRect(rect2);
      setActive(_active);
      setWidth(_width);
      setHeight(_height);
      setOffset(targetOffset);
      setReady(true);
    };
    React.useEffect(() => {
      if (ready) {
        getStyle();
      }
    }, [isVertical, width, height, offset, ready]);
    React.useEffect(() => {
      if (ready) {
        stopAutoPlay();
        autoplay();
      }
      return () => {
        setReady(false);
      };
    }, [ready]);
    React.useEffect(() => {
      stopAutoPlay();
      autoplay();
    }, [children]);
    React.useEffect(() => {
      Taro.nextTick(() => {
        init();
      });
    }, [propSwiper.initPage]);
    React.useEffect(() => {
      return () => {
        stopAutoPlay();
      };
    }, []);
    Taro.useReady(() => {
      Taro.nextTick(() => {
        init();
      });
    });
    const itemStyle = (index) => {
      const style = {};
      const _direction = propSwiper.direction || direction;
      const _size = size;
      if (_size) {
        style[_direction === "horizontal" ? "width" : "height"] = `${_size}px`;
      }
      const offset2 = childOffset[index];
      if (offset2) {
        style.transform = `translate3D${_direction === "horizontal" ? `(${offset2}px,0,0)` : `(0,${offset2}px,0)`}`;
      }
      return style;
    };
    React.useImperativeHandle(ref, () => ({
      to: to2,
      next,
      prev,
      resize
    }));
    return /* @__PURE__ */ React.createElement(DataContext$1.Provider, { value: parent }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classes} ${className}`,
        ref: container,
        ...rest,
        id: `container-${refRandomId}`,
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        catchMove: isVertical
      },
      /* @__PURE__ */ React.createElement("div", { className: contentClass, ref: innerRef }, React.Children.map(childs, (child, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: b2("item-wrapper"),
            style: itemStyle(index),
            key: index
          },
          child
        );
      })),
      propSwiper.paginationVisible && !("pageContent" in propSwiper) ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: classNames({
            [`${b2("pagination")}`]: true,
            [`${b2("pagination-vertical")}`]: isVertical
          })
        },
        React.Children.map(childs, (item, index) => {
          return /* @__PURE__ */ React.createElement(
            "i",
            {
              style: (active + childCount) % childCount === index ? {
                backgroundColor: propSwiper.paginationColor
              } : {
                backgroundColor: propSwiper.paginationBgColor
              },
              className: classNames({
                active: (active + childCount) % childCount === index
              }),
              key: index
            }
          );
        })
      ) : /* @__PURE__ */ React.createElement("div", null, pageContent)
    ));
  });
  Swiper.defaultProps = defaultProps$n;
  Swiper.displayName = "NutSwiper";
  const defaultProps$m = {
    direction: "horizontal"
  };
  const SwiperItem = React.forwardRef((props, ref) => {
    const _props = { ...defaultProps$m, ...props };
    const { className, style, children, direction, size } = _props;
    const parent = React.useContext(DataContext$1);
    const b2 = cn("swiper-item");
    const classes = classNames(b2(""), className);
    const getStyle = () => {
      const style2 = {};
      const _direction = (parent == null ? void 0 : parent.propSwiper.direction) || direction;
      const _size = (parent == null ? void 0 : parent.size) || size;
      if (_size) {
        style2[_direction === "horizontal" ? "width" : "height"] = `${_size}px`;
      }
      return style2;
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, style: { ...style, ...getStyle() } }, children);
  });
  SwiperItem.defaultProps = defaultProps$m;
  SwiperItem.displayName = "NutSwiperItem";
  const defaultProps$l = {
    images: [],
    videos: [],
    show: false,
    autoplay: 3e3,
    initNo: 1,
    contentClose: false,
    paginationVisible: false,
    paginationColor: "#fff",
    onClose: () => {
    }
  };
  const ImagePreview = (props) => {
    const {
      images,
      videos,
      show,
      initNo,
      paginationColor,
      paginationVisible,
      autoplay,
      contentClose,
      onClose
    } = props;
    const nutImagePreview = React.useRef(null);
    const [showPop, setShowPop] = React.useState(false);
    const [active, setActive] = React.useState(1);
    const [maxNo, setMaxNo] = React.useState(1);
    const [store, setStore] = React.useState({
      scale: 1,
      moveable: false
    });
    const [lastTouchEndTime, setLastTouchEndTime] = React.useState(0);
    const onTouchStart = (event) => {
      const touches = event.touches;
      const events = touches[0];
      const events2 = touches[1];
      const curTouchTime = (/* @__PURE__ */ new Date()).getTime();
      if (curTouchTime - lastTouchEndTime < 300) {
        const store12 = store;
        if (store12.scale > 1) {
          store12.scale = 1;
        } else if (store12.scale === 1) {
          store12.scale = 2;
        }
        scaleNow();
      }
      const store1 = store;
      store1.moveable = true;
      if (events2) {
        store1.oriDistance = getDistance(
          {
            x: events.pageX,
            y: events.pageY
          },
          {
            x: events2.pageX,
            y: events2.pageY
          }
        );
      }
      store1.originScale = store1.scale || 1;
    };
    const onTouchMove = (event) => {
      const touches = event.touches;
      const events = touches[0];
      const events2 = touches[1];
      if (!store.moveable) {
        return;
      }
      const store1 = store;
      if (events2) {
        const curDistance = getDistance(
          {
            x: events.pageX,
            y: events.pageY
          },
          {
            x: events2.pageX,
            y: events2.pageY
          }
        );
        const curScale = curDistance / store1.oriDistance;
        store1.scale = store1.originScale * curScale;
        if (store1.scale > 3) {
          store1.scale = 3;
        }
        scaleNow();
      }
    };
    const onTouchEnd = () => {
      setLastTouchEndTime((/* @__PURE__ */ new Date()).getTime());
      const store1 = store;
      store1.moveable = false;
      if (store1.scale < 1.1 && store1.scale > 1 || store1.scale < 1) {
        store1.scale = 1;
        scaleNow();
      }
    };
    const init = () => {
      document.addEventListener("touchmove", onTouchMove);
      document.addEventListener("touchend", onTouchEnd);
      document.addEventListener("touchcancel", onTouchEnd);
    };
    React.useEffect(() => {
      if (show !== void 0) {
        setShowPop(show);
        init();
      }
    }, [show]);
    React.useEffect(() => {
      if (initNo !== void 0) {
        setActive(initNo);
      }
      if (show !== void 0) {
        setShowPop(show);
      }
      if (images && videos) {
        setMaxNo(images.length + videos.length);
      }
    }, []);
    const scaleNow = () => {
      if (nutImagePreview.current) {
        nutImagePreview.current.style.transform = `scale(${store.scale})`;
      }
    };
    const onCloseInner = () => {
      setShowPop(false);
      setActive(1);
      scaleNow();
      onClose && onClose();
      setStore({
        ...store,
        scale: 1
      });
    };
    const getDistance = (first, second) => {
      return Math.hypot(
        Math.abs(second.x - first.x),
        Math.abs(second.y - first.y)
      );
    };
    const slideChangeEnd = (page) => {
      setActive(page + 1);
    };
    const closeOnImg = () => {
      if (contentClose) {
        onCloseInner();
      }
    };
    return /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: showPop,
        popClass: "custom-pop",
        style: { width: "100%" },
        onClick: onCloseInner
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "nut-imagepreview",
          ref: nutImagePreview,
          onClick: closeOnImg,
          onTouchStart
        },
        /* @__PURE__ */ React.createElement(
          Swiper,
          {
            autoPlay: autoplay,
            className: "nut-imagepreview-swiper",
            loop: true,
            isPreventDefault: false,
            style: { display: showPop ? "block" : "none" },
            direction: "horizontal",
            onChange: slideChangeEnd,
            initPage: initNo && (initNo > maxNo ? maxNo - 1 : initNo - 1),
            paginationColor,
            paginationVisible
          },
          images && images.length > 0 ? images.map((item, index) => {
            return /* @__PURE__ */ React.createElement(SwiperItem, { key: index }, /* @__PURE__ */ React.createElement(
              "img",
              {
                src: item.src,
                alt: "",
                className: "nut-imagepreview-img"
              }
            ));
          }) : []
        )
      ),
      /* @__PURE__ */ React.createElement("div", { className: "nut-imagepreview-index" }, active, "/", (images ? images.length : 0) + (videos ? videos.length : 0))
    );
  };
  ImagePreview.defaultProps = defaultProps$l;
  ImagePreview.displayName = "NutImagePreview";
  const defaultProps$k = {
    ...ComponentDefaults,
    // 滚动方向  across 横向 vertical 纵向
    direction: "across",
    list: [],
    standTime: 1e3,
    complexAm: false,
    height: 40,
    text: "",
    closeMode: false,
    wrapable: false,
    leftIcon: "",
    color: "",
    background: "",
    delay: 1,
    scrollable: null,
    speed: 50
  };
  const NoticeBar = (props) => {
    const {
      children,
      className,
      style,
      direction,
      list,
      standTime,
      complexAm,
      height,
      text,
      closeMode,
      wrapable,
      leftIcon,
      color,
      background,
      delay,
      scrollable,
      speed,
      rightIcon,
      close,
      click,
      onClose,
      onClick,
      onClickItem,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$k,
      ...props
    };
    const wrap = React.useRef(null);
    const content = React.useRef(null);
    const [showNoticeBar, SetShowNoticeBar] = React.useState(true);
    const scrollList = React.useRef([]);
    const [wrapWidth, SetWrapWidth] = React.useState(0);
    const [firstRound, SetFirstRound] = React.useState(true);
    const [duration, SetDuration] = React.useState(0);
    const [offsetWidth, SetOffsetW] = React.useState(0);
    const [animationClass, SetAnimationClass] = React.useState("");
    const [animate, SetAnimate] = React.useState(false);
    const [distance, SetDistance] = React.useState(0);
    const [timer, SetTimer] = React.useState(0);
    const [isCanScroll, SetIsCanScroll] = React.useState(null);
    const isVertical = direction === "vertical";
    const [rect, setRect] = React.useState(null);
    let active = 0;
    const [vLeftIcon, setLeftIcon] = React.useState("");
    const [ready, setReady] = React.useState(false);
    const container = React.useRef(null);
    const innerRef = React.useRef(null);
    const _swiper = React.useRef({
      moving: false,
      autoplayTimer: null,
      width: 0,
      height: 0,
      offset: 0,
      size: 0
    });
    const [childOffset, setChildOffset] = React.useState([]);
    const [offset, setOffset] = React.useState(0);
    const { childs, childCount } = React.useMemo(() => {
      let childCount2 = 0;
      const childs2 = React.Children.map(children, (child) => {
        if (!React.isValidElement(child))
          return null;
        childCount2++;
        return child;
      });
      return {
        childs: childs2,
        childCount: childCount2
      };
    }, [children]);
    let trackSize = childCount * Number(height);
    const minOffset = (() => {
      if (rect) {
        const base = isVertical ? rect.height : rect.width;
        return base - Number(height) * childCount;
      }
      return 0;
    })();
    React.useEffect(() => {
      if (isVertical) {
        if (leftIcon !== "") {
          setLeftIcon(leftIcon);
        } else {
          setLeftIcon("close");
        }
        if (children) {
          scrollList.current = [].concat(childs);
        } else {
          scrollList.current = [].concat(list);
          setTimeout(() => {
            startRollEasy();
          }, Number(standTime));
        }
        setTimeout(() => {
          complexAm && startRoll();
        }, Number(standTime));
      } else {
        initScrollWrap();
      }
      return () => {
        clearInterval(timer);
      };
    }, []);
    React.useEffect(() => {
      initScrollWrap();
    }, [text]);
    React.useEffect(() => {
      if (list && list.length) {
        scrollList.current = [].concat(list);
      }
    }, [list]);
    const initScrollWrap = (value) => {
      if (showNoticeBar === false) {
        return;
      }
      setTimeout(async () => {
        if (!wrap.current || !content.current) {
          return;
        }
        const warpRes = await getRectByTaro(wrap.current);
        const contentRes = await getRectByTaro(content.current);
        const wrapW = warpRes.width;
        const offsetW = contentRes.width;
        const canScroll = scrollable == null ? offsetW > wrapW : scrollable;
        SetIsCanScroll(canScroll);
        if (canScroll) {
          SetWrapWidth(wrapW);
          SetOffsetW(offsetW);
          SetDuration(offsetW / speed);
          SetAnimationClass("play");
        } else {
          SetAnimationClass("");
        }
      }, 0);
    };
    const handleClick = (event) => {
      click && click(event);
      onClick && onClick(event);
    };
    const onClickIcon = (event) => {
      event.stopPropagation();
      SetShowNoticeBar(!closeMode);
      close && close(event);
      onClose && onClose(event);
    };
    const onAnimationEnd = () => {
      SetFirstRound(false);
      setTimeout(() => {
        SetDuration((offsetWidth + wrapWidth) / speed);
        SetAnimationClass("play-infinite");
      }, 0);
    };
    const startRollEasy = () => {
      showhorseLamp();
      const time = height / speed / 4 < 1 ? Number((height / speed / 4).toFixed(1)) * 1e3 : ~~(height / speed / 4) * 1e3;
      const timerCurr = window.setInterval(
        showhorseLamp,
        time + Number(standTime)
      );
      SetTimer(timerCurr);
    };
    const showhorseLamp = () => {
      SetAnimate(true);
      const time = height / speed / 4 < 1 ? Number((height / speed / 4).toFixed(1)) * 1e3 : ~~(height / speed / 4) * 1e3;
      setTimeout(() => {
        scrollList.current.push(scrollList.current[0]);
        scrollList.current.shift();
        SetAnimate(false);
      }, time);
    };
    const startRoll = () => {
      const timerCurr = window.setInterval(() => {
        const chunk = 100;
        for (let i = 0; i < chunk; i++) {
          scroll(i, !(i < chunk - 1));
        }
      }, Number(standTime) + 100 * speed);
      SetTimer(timerCurr);
    };
    const scroll = (n, last) => {
      SetAnimate(true);
      setTimeout(() => {
        let long = distance;
        long -= height / 100;
        SetDistance(long);
        if (last) {
          scrollList.current.push(scrollList.current[0]);
          scrollList.current.shift();
          SetDistance(0);
          SetAnimate(false);
        }
      }, n * speed);
    };
    const handleClickIcon = (event) => {
      event.stopPropagation();
      SetShowNoticeBar(!closeMode);
      close && close(event);
      onClose && onClose(event);
    };
    const iconShow = () => {
      if (leftIcon === "close" || vLeftIcon === "close") {
        return false;
      }
      return true;
    };
    const iconBg = () => {
      let iconBg2 = "";
      if (leftIcon) {
        iconBg2 = leftIcon;
      }
      return iconBg2;
    };
    const isEllipsis = () => {
      if (isCanScroll == null) {
        return wrapable;
      }
      return !isCanScroll && !wrapable;
    };
    const contentStyle = {
      animationDelay: `${firstRound ? delay : 0}s`,
      animationDuration: `${duration}s`,
      transform: `translateX(${firstRound ? 0 : `${wrapWidth}px`})`
    };
    const barStyle = {
      color,
      background,
      height: isVertical ? `${height}px` : ""
    };
    const duringTime = height / speed / 4 < 1 ? Number((height / speed / 4).toFixed(1)) : ~~(height / speed / 4);
    const noDuring = height / speed < 1 ? (height / speed).toFixed(1) : ~~(height / speed);
    const horseLampStyle = {
      transform: complexAm ? `translateY(${distance}px)` : "",
      transition: animate ? `all ${duringTime === 0 ? noDuring : duringTime}s` : "",
      marginTop: animate ? `-${height}px` : ""
    };
    const b2 = cn("noticebar");
    const noticebarClass = classNames({
      "nut-noticebar-page": true,
      withicon: closeMode,
      close: closeMode,
      wrapable
    });
    const init = (active2 = 0) => {
      if (!(container == null ? void 0 : container.current))
        return;
      setTimeout(async () => {
        const rects = await getRectByTaro(container == null ? void 0 : container.current);
        const _active = Math.max(Math.min(childCount - 1, active2), 0);
        const _height = rects.height;
        trackSize = childCount * Number(_height);
        const targetOffset = getOffset(_active);
        _swiper.current.moving = true;
        if (ready) {
          _swiper.current.moving = false;
        }
        active2 = _active;
        setRect(rects);
        setOffset(targetOffset);
        setReady(true);
      }, 0);
    };
    React.useEffect(() => {
      if (ready) {
        stopAutoPlay();
        autoplay();
      }
      return () => {
        setReady(false);
      };
    }, [ready]);
    React.useEffect(() => {
      if (isVertical && children) {
        setTimeout(() => {
          init();
          stopAutoPlay();
          autoplay();
        }, 300);
      }
    }, [children, container == null ? void 0 : container.current]);
    const stopAutoPlay = () => {
      clearTimeout(_swiper.current.autoplayTimer);
      _swiper.current.autoplayTimer = null;
    };
    const autoplay = () => {
      if (childCount <= 1)
        return;
      stopAutoPlay();
      _swiper.current.autoplayTimer = setTimeout(() => {
        next();
        autoplay();
      }, Number(standTime) + 100 * speed);
    };
    const move = ({ pace = 0, offset: offset2 = 0 }) => {
      if (childCount <= 1)
        return;
      const targetActive = getActive(pace);
      const targetOffset = getOffset(targetActive, offset2);
      if (Array.isArray(children) && children[0] && targetOffset !== minOffset) {
        const rightBound = targetOffset < minOffset;
        childOffset[0] = rightBound ? trackSize : 0;
      }
      if (Array.isArray(children) && children[childCount - 1] && targetOffset !== 0) {
        const leftBound = targetOffset > 0;
        childOffset[childCount - 1] = leftBound ? -trackSize : 0;
      }
      setChildOffset(childOffset);
      active = targetActive;
      setOffset(targetOffset);
      getStyle(targetOffset);
    };
    const next = () => {
      resettPosition();
      requestFrame(() => {
        requestFrame(() => {
          _swiper.current.moving = false;
          move({
            pace: 1
          });
        });
      });
    };
    const handleItemClick = (event, value) => {
      onClickItem && onClickItem(event, value);
    };
    const getStyle = (moveOffset = offset) => {
      const target = innerRef.current;
      let _offset = 0;
      const val = rect.height - height;
      _offset = moveOffset + Number(active === childCount - 1 && val / 2);
      target.style.transitionDuration = `${_swiper.current.moving ? 0 : standTime}ms`;
      target.style.height = `${Number(height) * childCount}px`;
      target.style.transform = `translate3D(0,${_offset}px,0)`;
    };
    const itemStyle = (index) => {
      const style2 = {};
      if (height) {
        style2.height = `${height}px`;
        style2.lineHeight = `${height}px`;
      }
      const offset2 = childOffset[index];
      if (offset2) {
        style2.transform = `translate3D(0,${offset2}px,0)`;
      }
      return style2;
    };
    const getActive = (pace) => {
      if (pace) {
        const _active = active + pace;
        return range(_active, -1, childCount);
      }
      return active;
    };
    const getOffset = (active2, offset2 = 0) => {
      const currentPosition = active2 * Number(height);
      const targetOffset = offset2 - currentPosition;
      return targetOffset;
    };
    const requestFrame = (fn) => {
      window.requestAnimationFrame.call(window, fn);
    };
    const range = (num, min, max) => {
      return Math.min(Math.max(num, min), max);
    };
    const resettPosition = () => {
      _swiper.current.moving = true;
      if (active <= -1) {
        move({ pace: childCount });
      }
      if (active >= childCount) {
        move({ pace: -childCount });
      }
    };
    React.useEffect(() => {
      return () => {
        stopAutoPlay();
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className || ""}`, style }, showNoticeBar && direction === "across" ? /* @__PURE__ */ React.createElement("div", { className: noticebarClass, style: barStyle, onClick: handleClick }, iconShow() ? /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "left-icon",
        style: { backgroundImage: `url(${iconBg() || ""})` }
      },
      !iconBg() ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: "notice",
          size: "16",
          color
        }
      ) : null
    ) : null, /* @__PURE__ */ React.createElement("div", { ref: wrap, className: "wrap" }, /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: content,
        className: `content ${animationClass} ${isEllipsis() ? "nut-ellipsis" : ""}`,
        style: contentStyle,
        onAnimationEnd
      },
      children,
      text
    )), closeMode || rightIcon ? /* @__PURE__ */ React.createElement("div", { className: "right-icon", onClick: onClickIcon }, /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        name: rightIcon || "close",
        color
      }
    )) : null) : null, showNoticeBar && scrollList.current.length > 0 && isVertical ? /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "nut-noticebar-vertical",
        style: barStyle,
        ref: container,
        onClick: handleClick
      },
      iconShow() ? /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "left-icon",
          style: { backgroundImage: `url(${iconBg() || ""})` }
        },
        !iconBg() ? /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: "notice",
            size: "16",
            color
          }
        ) : null
      ) : null,
      children ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", { className: "nut-noticebar__inner", ref: innerRef }, scrollList.current.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "scroll-inner ",
            style: itemStyle(index),
            key: index,
            onClick: (e) => {
              handleItemClick(e, item);
            }
          },
          item
        );
      }))) : /* @__PURE__ */ React.createElement("div", { className: "horseLamp_list", style: horseLampStyle }, scrollList.current.map((item, index) => {
        return (
          // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
          /* @__PURE__ */ React.createElement(
            "div",
            {
              className: "horseLamp_list_item",
              style: { height },
              key: index,
              onClick: (e) => {
                handleItemClick(e, item);
              }
            },
            item
          )
        );
      })),
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: "go",
          onClick: (e) => {
            handleClickIcon(e);
          }
        },
        rightIcon || (closeMode ? /* @__PURE__ */ React.createElement(
          Icon$1,
          {
            classPrefix: iconClassPrefix,
            fontClassName: iconFontClassName,
            name: rightIcon || "close",
            color,
            size: "11px"
          }
        ) : null)
      )
    ) : null);
  };
  NoticeBar.defaultProps = defaultProps$k;
  NoticeBar.displayName = "NutNoticeBar";
  function fillRef(ref, node) {
    if (typeof ref === "function") {
      ref(node);
    } else if (typeof ref === "object" && ref && "current" in ref) {
      ref.current = node;
    }
  }
  function composeRef(...refs) {
    return (node) => {
      refs.forEach((ref) => {
        fillRef(ref, node);
      });
    };
  }
  class Trigger extends React.Component {
    fireEvents(type, e) {
      const childCallback = this.props.children.props[type];
      if (childCallback) {
        childCallback(e);
      }
      const callback = this.props[type];
      if (callback) {
        callback(e);
      }
    }
    render() {
      const { children, className = "" } = this.props;
      const child = React.Children.only(children);
      const newChildProps = {
        key: "trigger"
      };
      if (child && child.props && child.props.className) {
        newChildProps.className = className;
      }
      const cloneProps = {
        ...newChildProps
      };
      cloneProps.ref = composeRef(this.props.forwardedRef, child.ref);
      const trigger = React.cloneElement(child, cloneProps);
      return trigger;
    }
  }
  const defaultProps$j = {
    ...ComponentDefaults,
    list: [],
    theme: "light",
    location: "bottom",
    visible: false,
    offset: 20,
    className: "",
    onClick: (e) => {
    },
    onChoose: (item, index) => {
    }
  };
  const Popover = (props) => {
    const {
      children,
      list,
      theme,
      location,
      visible,
      offset,
      className,
      style,
      onClick,
      onChoose,
      iconClassPrefix,
      iconFontClassName,
      ...reset
    } = {
      ...defaultProps$j,
      ...props
    };
    const goodItem = React.useRef(null);
    setTimeout(async () => {
      if (goodItem.current) {
        const res = await getRectByTaro(goodItem.current);
        setElWidth(res == null ? void 0 : res.width);
        setElHeight(res == null ? void 0 : res.height);
      }
    });
    const [classes, setClasses] = React.useState("");
    const [elWidth, setElWidth] = React.useState(0);
    const [elHeight, setElHeight] = React.useState(0);
    const [popoverContent, setPopoverContent] = React.useState("");
    const [popoverArrow, setPopoverArrow] = React.useState("");
    React.useEffect(() => {
      setClasses(classesSelf());
      setPopoverContent(popoverContentSelf());
      setPopoverArrow(popoverArrowSelf());
    }, [list, theme]);
    const getStyle = () => {
      const offNumer = Number(offset) ? Number(offset) : 0;
      const style2 = {};
      if (location.includes("top")) {
        style2.bottom = `${elHeight + offNumer}px`;
      } else if (location.includes("right")) {
        style2.left = `${elWidth + offNumer}px`;
      } else if (location.includes("left")) {
        style2.right = `${elWidth + offNumer}px`;
      } else {
        style2.top = `${elHeight + offNumer}px`;
      }
      return style2;
    };
    const classesSelf = () => {
      const prefixCls = "nut-popover";
      return `${prefixCls} ${theme ? `${prefixCls}--${theme}` : ""}`;
    };
    const popoverContentSelf = () => {
      const prefixCls = "popover-content";
      return `${prefixCls}-show ${prefixCls} ${location ? `${prefixCls}--${location}` : ""}`;
    };
    const filter = () => {
      const ms = ["top", "bottom", "left", "right"];
      return ms.filter((m) => location.includes(m))[0];
    };
    const popoverArrowSelf = () => {
      const prefixCls = "popover-arrow";
      return `${prefixCls} ${prefixCls}-${filter()} ${location ? `${prefixCls}--${location}` : ""}`;
    };
    const handleClick = (e) => {
      if (props.onClick) {
        props.onClick(e);
      }
    };
    const handleChoose = (item, index) => {
      if (!item.disabled) {
        onChoose(item, index);
      }
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: `${classes} ${className}`,
        style: { ...style },
        ...reset
      },
      /* @__PURE__ */ React.createElement(Trigger, { forwardedRef: goodItem }, /* @__PURE__ */ React.createElement("div", { onClick: (e) => handleClick(e) }, Array.isArray(children) ? children[0] : children, visible ? /* @__PURE__ */ React.createElement("div", { className: `${popoverContent}`, style: getStyle() }, /* @__PURE__ */ React.createElement("div", { className: `${popoverArrow}` }), Array.isArray(children) ? children[1] : "", /* @__PURE__ */ React.createElement("div", null, " ", list.map((item, i) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            key: item.name,
            className: `popover-menu-item ${item.disabled ? "disabled" : ""}`,
            onClick: () => {
              handleChoose(item, i);
            }
          },
          item.icon ? /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              className: "popover-menu-item-img",
              name: item.icon
            }
          ) : "",
          /* @__PURE__ */ React.createElement("div", { className: "popover-menu-item-name" }, item.name)
        );
      }))) : null))
    ), visible ? /* @__PURE__ */ React.createElement(
      Overlay,
      {
        visible,
        onClick: (e) => handleClick(e),
        style: { background: "transparent" }
      }
    ) : "");
  };
  Popover.defaultProps = defaultProps$j;
  Popover.displayName = "NutPopover";
  const defaultProps$i = {
    price: 0,
    needSymbol: true,
    symbol: "&yen;",
    decimalDigits: 2,
    thousands: false,
    position: "before",
    size: "large",
    className: ""
  };
  const Price = (props) => {
    const {
      price,
      needSymbol,
      symbol,
      decimalDigits,
      thousands,
      position,
      size,
      className,
      ...rest
    } = {
      ...defaultProps$i,
      ...props
    };
    const b2 = cn("price");
    const replaceSpecialChar = (url) => {
      url = url.replace(/&quot;/g, '"');
      url = url.replace(/&amp;/g, "&");
      url = url.replace(/&lt;/g, "<");
      url = url.replace(/&gt;/g, ">");
      url = url.replace(/&nbsp;/g, " ");
      url = url.replace(/&yen;/g, "￥");
      return url;
    };
    const showSymbol = () => {
      return { __html: needSymbol ? replaceSpecialChar(symbol) : "" };
    };
    const checkPoint = (price2) => {
      return String(price2).indexOf(".") > 0;
    };
    const formatThousands = (num) => {
      if (Number(num) === 0) {
        num = 0;
      }
      if (checkPoint(num)) {
        num = Number(num).toFixed(decimalDigits);
        num = typeof num.split(".") === "string" ? num.split(".") : num.split(".")[0];
      } else {
        num = num.toString();
      }
      if (thousands) {
        return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
      }
      return num;
    };
    const formatDecimal = (decimalNum) => {
      if (Number(decimalNum) === 0) {
        decimalNum = 0;
      }
      if (checkPoint(decimalNum)) {
        decimalNum = Number(decimalNum).toFixed(decimalDigits);
        decimalNum = typeof decimalNum.split(".") === "string" ? 0 : decimalNum.split(".")[1] || 0;
      } else {
        decimalNum = 0;
      }
      const result = `0.${decimalNum}`;
      const resultFixed = Number(result).toFixed(decimalDigits);
      return String(resultFixed).substring(2, resultFixed.length);
    };
    const renderSymbol = () => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${b2("symbol")} ${b2(`symbol-${size}`)}`,
          dangerouslySetInnerHTML: showSymbol()
        }
      );
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, ...rest }, needSymbol && position === "before" ? renderSymbol() : null, /* @__PURE__ */ React.createElement("div", { className: `${b2("integer")} ${b2(`integer-${size}`)}` }, formatThousands(price)), decimalDigits !== 0 ? /* @__PURE__ */ React.createElement("div", { className: `${b2("decimal")} ${b2(`decimal-${size}`)}` }, ".") : null, /* @__PURE__ */ React.createElement("div", { className: `${b2("decimal")} ${b2(`decimal-${size}`)}` }, formatDecimal(price)), needSymbol && position === "after" ? renderSymbol() : null);
  };
  Price.defaultProps = defaultProps$i;
  Price.displayName = "NutPrice";
  const defaultProps$h = {
    width: "100px",
    height: "100px",
    row: 1,
    animated: false,
    title: false,
    avatar: false,
    round: false,
    avatarSize: "50px",
    loading: false,
    avatarShape: "round"
  };
  const Skeleton = (props) => {
    const {
      className,
      width,
      height,
      animated: animated2,
      row,
      title,
      avatar,
      avatarSize,
      round,
      loading,
      children,
      avatarShape,
      ...restProps
    } = {
      ...defaultProps$h,
      ...props
    };
    const b2 = cn("skeleton");
    const classes = classNames(className, b2());
    const blockClass = classNames({
      blockClass: true,
      "blockClass--round": round
    });
    const avatarClass = classNames({
      avatarClass: true,
      [`avatarClass--${avatarShape}`]: avatarShape
    });
    const repeatLines = (num) => {
      return Array.from({ length: num }, (v, i) => i);
    };
    const getStyle = () => {
      if (avatarSize) {
        return {
          width: avatarSize,
          height: avatarSize
        };
      }
      return {
        width: "50px",
        height: "50px"
      };
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, loading ? /* @__PURE__ */ React.createElement("div", null, children) : /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, animated2 && /* @__PURE__ */ React.createElement("div", { className: "skeleton-animation" }), /* @__PURE__ */ React.createElement("div", { className: "nut-skeleton-content" }, avatar && /* @__PURE__ */ React.createElement(
      Avatar,
      {
        className: avatarClass,
        bgColor: "rgb(239, 239, 239)",
        shape: avatarShape,
        style: getStyle()
      }
    ), row === 1 && /* @__PURE__ */ React.createElement("div", { className: blockClass, style: { width, height } }), /* @__PURE__ */ React.createElement("div", { className: "skeleton-content-line" }, title && /* @__PURE__ */ React.createElement("div", { className: "skeleton-title" }), repeatLines(row).map((item, index) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: blockClass,
          key: index,
          style: { width, height }
        }
      );
    })))));
  };
  Skeleton.defaultProps = defaultProps$h;
  Skeleton.displayName = "NutSkeleton";
  const DataContext = React.createContext({});
  const defaultProps$g = {
    ...ComponentDefaults,
    title: "",
    content: "",
    activeIndex: 0,
    icon: "",
    iconColor: "",
    size: "12px"
  };
  const Step = (props) => {
    const {
      children,
      title,
      content,
      activeIndex,
      icon,
      iconColor,
      size,
      className,
      renderContent,
      iconClassPrefix,
      iconFontClassName,
      ...restProps
    } = {
      ...defaultProps$g,
      ...props
    };
    const parent = React.useContext(DataContext);
    const dot = parent.propSteps.progressDot;
    const getCurrentStatus = () => {
      const index = activeIndex;
      if (index < +parent.propSteps.current)
        return "finish";
      return index === +parent.propSteps.current ? "process" : "wait";
    };
    const handleClickStep = () => {
      var _a, _b, _c, _d;
      ((_a = parent.propSteps) == null ? void 0 : _a.onClickStep) && ((_b = parent.propSteps) == null ? void 0 : _b.onClickStep(activeIndex));
      ((_c = parent.propSteps) == null ? void 0 : _c.clickStep) && ((_d = parent.propSteps) == null ? void 0 : _d.clickStep(activeIndex));
    };
    const b2 = cn("step");
    const classes = classNames(
      {
        [`${b2("")}-${getCurrentStatus()}`]: true
      },
      className,
      b2("")
    );
    const renderIconClass = () => {
      if (!dot && icon) {
        return "nut-step-icon is-icon";
      }
      if (!dot && !icon) {
        return "nut-step-icon is-text";
      }
      return "nut-step-icon";
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps, onClick: handleClickStep }, /* @__PURE__ */ React.createElement("div", { className: "nut-step-head" }, /* @__PURE__ */ React.createElement("div", { className: "nut-step-line" }), /* @__PURE__ */ React.createElement("div", { className: renderIconClass() }, icon ? /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        classPrefix: iconClassPrefix,
        fontClassName: iconFontClassName,
        className: "nut-step-icon-inner",
        color: iconColor,
        name: icon,
        size
      }
    ) : !dot && /* @__PURE__ */ React.createElement("span", { className: "nut-step-inner" }, activeIndex))), /* @__PURE__ */ React.createElement("div", { className: "nut-step-main" }, /* @__PURE__ */ React.createElement("span", { className: "nut-step-title" }, title), content && /* @__PURE__ */ React.createElement("span", { className: "nut-step-content" }, content), renderContent && /* @__PURE__ */ React.createElement("span", { className: "nut-step-content" }, renderContent())));
  };
  Step.defaultProps = defaultProps$g;
  Step.displayName = "NutStep";
  const defaultProps$f = {
    current: 0,
    direction: "horizontal",
    progressDot: false
  };
  const Steps = (props) => {
    const propSteps = { ...defaultProps$f, ...props };
    const {
      children,
      current,
      direction,
      className,
      progressDot,
      clickStep,
      onClickStep,
      ...restProps
    } = propSteps;
    const parentSteps = {
      propSteps
    };
    const b2 = cn("steps");
    const classes = classNames(
      {
        [`${b2("")}-${direction}`]: true,
        [`${b2("")}-dot`]: !!props.progressDot
      },
      className,
      b2("")
    );
    return /* @__PURE__ */ React.createElement(DataContext.Provider, { value: parentSteps }, React.createElement(
      "div",
      {
        className: classes,
        ...restProps
      },
      children
    ));
  };
  Steps.defaultProps = defaultProps$f;
  Steps.displayName = "NutSteps";
  const defaultProps$e = {
    ...ComponentDefaults,
    className: "",
    style: {},
    columns: [],
    data: [],
    bordered: true,
    striped: false,
    noData: "无数据",
    showHeader: true
  };
  const Table = (props) => {
    const { locale } = useConfig$1();
    defaultProps$e.noData = locale.noData;
    const {
      children,
      className,
      style,
      columns,
      data,
      bordered,
      summary,
      striped,
      noData,
      onSorter,
      iconClassPrefix,
      iconFontClassName,
      showHeader,
      ...rest
    } = {
      ...defaultProps$e,
      ...props
    };
    const [curData, setCurData] = React.useState(data);
    React.useEffect(() => {
      if (data && String(data) !== String(curData)) {
        setCurData(data);
      }
    }, [data]);
    const b2 = cn("table");
    const classes = classNames({});
    const cls = classNames(b2(), classes, className);
    const handleSorterClick = (item) => {
      if (item.sorter) {
        onSorter && onSorter(item, curData);
        if (typeof item.sorter === "function") {
          setCurData(curData.sort(item.sorter));
        } else {
          setCurData(item.sorter === "default" ? curData.sort() : curData);
        }
      }
    };
    const cellClasses = (item) => {
      return {
        "nut-table__main__head__tr--border": props.bordered,
        [`nut-table__main__head__tr--align${item.align ? item.align : ""}`]: true
      };
    };
    const getColumnItem = (value) => {
      return columns.filter((item) => item.key === value)[0];
    };
    const renderHeadCells = () => {
      return columns.map((item, index) => {
        return /* @__PURE__ */ React.createElement(
          "span",
          {
            className: classNames(
              "nut-table__main__head__tr__th",
              cellClasses(item)
            ),
            key: item.key,
            onClick: () => handleSorterClick(item)
          },
          item.title,
          item.sorter && /* @__PURE__ */ React.createElement(
            Icon$1,
            {
              classPrefix: iconClassPrefix,
              fontClassName: iconFontClassName,
              name: "down-arrow",
              size: "12px"
            }
          )
        );
      });
    };
    const sortDataItem = () => {
      return columns.map((columns2) => {
        return [columns2.key, columns2.render];
      });
    };
    const renderBodyTds = (item) => {
      return sortDataItem().map(([value, render], index) => {
        return /* @__PURE__ */ React.createElement(
          "span",
          {
            className: classNames(
              "nut-table__main__body__tr__td",
              cellClasses(getColumnItem(value))
            ),
            key: value
          },
          typeof item[value] === "function" || typeof render === "function" ? /* @__PURE__ */ React.createElement("div", null, render ? render(item) : item[value](item)) : item[value]
        );
      });
    };
    const renderBoyTrs = () => {
      return curData.map((item, index) => {
        return /* @__PURE__ */ React.createElement("div", { className: "nut-table__main__body__tr", key: index }, renderBodyTds(item));
      });
    };
    return /* @__PURE__ */ React.createElement("div", { className: cls, style, ...rest }, /* @__PURE__ */ React.createElement(
      "div",
      {
        className: classNames("nut-table__main", {
          "nut-table__main--striped": striped
        })
      },
      showHeader && /* @__PURE__ */ React.createElement("div", { className: "nut-table__main__head" }, /* @__PURE__ */ React.createElement("div", { className: "nut-table__main__head__tr" }, renderHeadCells())),
      /* @__PURE__ */ React.createElement("div", { className: "nut-table__main__body" }, renderBoyTrs())
    ), summary && /* @__PURE__ */ React.createElement("div", { className: "nut-table__summary" }, /* @__PURE__ */ React.createElement("span", { className: "nut-table__summary__text" }, summary)), curData.length === 0 && /* @__PURE__ */ React.createElement("div", { className: "nut-table__nodata" }, /* @__PURE__ */ React.createElement("div", { className: "nut-table__nodata" }, /* @__PURE__ */ React.createElement("div", { className: "nut-table__nodata__text" }, noData))));
  };
  Table.defaultProps = defaultProps$e;
  Table.displayName = "NutTable";
  const defaultProps$d = {
    ...ComponentDefaults,
    type: "default",
    color: "",
    textColor: "",
    plain: false,
    round: false,
    mark: false,
    closeable: false,
    iconSize: "12px",
    prefixCls: "nut-tag",
    onClose: (e) => {
    },
    onClick: (e) => {
    }
  };
  const Tag = (props) => {
    const {
      className,
      style,
      color,
      plain,
      type,
      round,
      prefixCls,
      children,
      mark,
      closeable,
      iconSize,
      textColor,
      onClick,
      onClose,
      iconClassPrefix,
      iconFontClassName
    } = {
      ...defaultProps$d,
      ...props
    };
    const [btnName, setBtnName] = React.useState("");
    const [isTagShow, setIsTagShow] = React.useState(true);
    React.useEffect(() => {
      setBtnName(classes());
    }, [
      type,
      color,
      textColor,
      plain,
      round,
      mark,
      closeable,
      iconSize,
      prefixCls,
      onClick,
      onClose,
      className
    ]);
    const classes = () => {
      const prefixCls2 = "nut-tag";
      return classNames({
        [prefixCls2]: true,
        [`${prefixCls2}--${type}`]: type,
        [`${prefixCls2}--plain`]: plain,
        [`${prefixCls2}--round`]: round,
        [`${prefixCls2}--mark`]: mark,
        [`${prefixCls2}--close`]: closeable,
        [`${className}`]: className
      });
    };
    const handleClick = (e) => {
      if (props.onClick) {
        props.onClick(e);
      }
    };
    const getStyle = () => {
      const style2 = {};
      if (textColor) {
        style2.color = textColor;
      } else if (color && plain) {
        style2.color = color;
      }
      if (plain) {
        style2.background = "#fff";
        style2.borderColor = color;
      } else if (color) {
        style2.background = color;
      }
      return style2;
    };
    return /* @__PURE__ */ React.createElement(React.Fragment, null, closeable ? isTagShow && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: btnName,
        style: { ...style, ...getStyle() },
        onClick: (e) => handleClick(e)
      },
      children && /* @__PURE__ */ React.createElement("span", { className: "nut-tag-text" }, children),
      /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          className: "_icon",
          name: "close",
          size: iconSize,
          onClick: (e) => {
            setIsTagShow(false);
            if (props.onClose) {
              props.onClose(e);
            }
          }
        }
      )
    ) : /* @__PURE__ */ React.createElement(
      "div",
      {
        className: btnName,
        style: { ...style, ...getStyle() },
        onClick: (e) => handleClick(e)
      },
      children && /* @__PURE__ */ React.createElement("span", { className: "nut-tag-text" }, children)
    ));
  };
  Tag.defaultProps = defaultProps$d;
  Tag.displayName = "NutTag";
  const defaultProps$c = {
    rate: 0,
    digits: 2,
    showSign: false,
    showZero: false,
    arrowLeft: false,
    syncTextColor: true,
    textColor: "#333",
    riseColor: "#fa2c19",
    dropColor: "#64b578",
    iconSize: "12px",
    upIconName: "triangle-up",
    downIconName: "triangle-down",
    className: ""
  };
  const TrendArrow = (props) => {
    const {
      rate,
      digits,
      showSign,
      showZero,
      arrowLeft,
      syncTextColor,
      textColor,
      riseColor,
      dropColor,
      iconSize,
      upIconName,
      downIconName,
      className,
      children,
      ...rest
    } = { ...defaultProps$c, ...props };
    const b2 = cn("trendarrow");
    const handleClick = () => {
    };
    const rateTrend = React.useRef(rate > 0);
    const myFixed = (num, digit = 2) => {
      if (Object.is(parseFloat(num), NaN)) {
        return console.log(`传入的值：${num}不是一个数字`);
      }
      num = parseFloat(num);
      const numPow = Math.pow(10, digit);
      return (Math.round((num + Number.EPSILON) * numPow) / numPow).toFixed(digit);
    };
    const calcStyle = (() => {
      const arrowColor = rateTrend.current ? riseColor : dropColor;
      const textEquArrowColor = syncTextColor ? arrowColor : textColor;
      const style = {
        color: rate === 0 ? textColor : textEquArrowColor
      };
      return style;
    })();
    const calcRate = (() => {
      rateTrend.current = rate > 0;
      const absRate = Math.abs(rate);
      if (!showZero && rate === 0) {
        return "--";
      }
      const resultRate = `${// eslint-disable-next-line no-nested-ternary
      showSign && rate !== 0 ? rateTrend.current ? "+" : "-" : ""}${myFixed(Number(absRate), digits)}%`;
      return resultRate;
    })();
    const calcIconProps = (() => {
      const iconProps = {
        name: rateTrend.current ? upIconName : downIconName,
        color: rateTrend.current ? riseColor : dropColor,
        size: iconSize
      };
      return iconProps;
    })();
    const renderContent = (arrowLeft2) => {
      const classNameSuffix = !arrowLeft2 ? "icon-after" : "icon-before";
      return /* @__PURE__ */ React.createElement("span", { className: `${b2(classNameSuffix)} ${b2("rate")}`, style: calcStyle }, calcRate);
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, ...rest, onClick: handleClick }, !arrowLeft && renderContent(!arrowLeft), children || /* @__PURE__ */ React.createElement(React.Fragment, null, Number(rate) !== 0 && /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        size: calcIconProps.size,
        name: calcIconProps.name,
        color: calcIconProps.color
      }
    )), arrowLeft && renderContent(!arrowLeft));
  };
  TrendArrow.defaultProps = defaultProps$c;
  TrendArrow.displayName = "NutTrendArrow";
  const defaultProps$b = {
    source: {
      type: {},
      src: ""
    },
    options: {
      controls: true,
      muted: false,
      // 默认不是静音
      autoplay: false,
      poster: "",
      playsinline: false,
      loop: false
    }
  };
  const Video = (props) => {
    const {
      children,
      source,
      options,
      className,
      play,
      pause,
      playend,
      onPlayFuc,
      onPauseFuc,
      onPlayend,
      ...restProps
    } = {
      ...defaultProps$b,
      ...props
    };
    const rootRef = React.useRef(null);
    const b2 = cn("video");
    const classes = classNames(className, b2(""));
    React.useEffect(() => {
      init();
    }, []);
    const init = () => {
      if (rootRef.current) {
        const videoRef = rootRef.current;
        if (options.autoplay) {
          setTimeout(() => {
            videoRef.play();
          }, 200);
        }
        if (options.playsinline) {
          videoRef.setAttribute("playsinline", String(options.playsinline));
          videoRef.setAttribute("webkit-playsinline", String(options.playsinline));
          videoRef.setAttribute("x5-video-player-type", "h5-page");
          videoRef.setAttribute("x5-video-player-fullscreen", "false");
        }
        videoRef.addEventListener("play", () => {
          onPlayFuc && onPlayFuc(videoRef);
          play && play(videoRef);
        });
        videoRef.addEventListener("pause", () => {
          onPauseFuc && onPauseFuc(videoRef);
          pause && pause(videoRef);
        });
        videoRef.addEventListener("ended", () => {
          videoRef.currentTime = 0;
          onPlayend && onPlayend(videoRef);
          playend && playend(videoRef);
        });
      }
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ...restProps }, /* @__PURE__ */ React.createElement(
      "video",
      {
        className: "nut-video-player",
        muted: options.muted,
        autoPlay: options.autoplay,
        loop: options.loop,
        poster: options.poster,
        controls: options.controls,
        ref: rootRef,
        src: source.src
      },
      /* @__PURE__ */ React.createElement("source", { src: source.src, type: source.type }),
      /* @__PURE__ */ React.createElement("track", { kind: "captions" })
    ));
  };
  Video.defaultProps = defaultProps$b;
  Video.displayName = "NutVideo";
  const initPositinoCache = (reaItemSize, length = 0) => {
    let index = 0;
    const positions = Array(length);
    while (index < length) {
      positions[index] = {
        index,
        height: reaItemSize,
        width: reaItemSize,
        top: index * reaItemSize,
        bottom: (index + 1) * reaItemSize,
        left: index * reaItemSize,
        right: (index + 1) * reaItemSize
      };
      index++;
    }
    return positions;
  };
  const binarySearch = (positionsList, value = 0, horizontal) => {
    let start2 = 0;
    let end = positionsList.length - 1;
    let tempIndex = null;
    const key = horizontal ? "right" : "bottom";
    while (start2 <= end) {
      const midIndex = Math.floor((start2 + end) / 2);
      const midValue = positionsList[midIndex][key];
      if (midValue === value) {
        return midIndex + 1;
      }
      if (midValue < value) {
        start2 = midIndex + 1;
      } else if (midValue > value) {
        if (tempIndex === null || tempIndex > midIndex) {
          tempIndex = midIndex;
        }
        end = midIndex - 1;
      }
    }
    tempIndex = tempIndex || 0;
    return tempIndex;
  };
  const updateItemSize = (positions, items, sizeKey) => {
    const newPos = positions.concat();
    Array.from(items).forEach((item) => {
      const index = Number(item.getAttribute("data-index"));
      const styleVal = item.getAttribute("style");
      if (styleVal && styleVal.includes("none"))
        return;
      const nowSize = item.getBoundingClientRect()[sizeKey];
      const oldSize = positions[index][sizeKey];
      const dValue = oldSize - nowSize;
      if (dValue) {
        if (sizeKey === "width") {
          newPos[index].right -= dValue;
          newPos[index][sizeKey] = nowSize;
          for (let k = index + 1; k < positions.length; k++) {
            newPos[k].left = positions[k - 1].right;
            newPos[k].right -= dValue;
          }
        } else if (sizeKey === "height") {
          newPos[index].bottom -= dValue;
          newPos[index][sizeKey] = nowSize;
          for (let k = index + 1; k < positions.length; k++) {
            newPos[k].top = positions[k - 1].bottom;
            newPos[k].bottom -= dValue;
          }
        }
      }
    });
  };
  const defaultProps$a = {
    sourceData: [],
    itemSize: 66,
    itemEqualSize: true,
    overscan: 2
  };
  const clientHeight = Taro.getSystemInfoSync().windowHeight - 5 || 667;
  Taro.getSystemInfoSync().windowWidth || 375;
  const VirtualList = (props) => {
    const {
      sourceData = [],
      ItemRender,
      itemSize = 66,
      itemEqualSize = true,
      overscan = 2,
      key,
      onScroll,
      className,
      containerSize = clientHeight,
      ...rest
    } = props;
    const [startOffset, setStartOffset] = React.useState(0);
    const [start2, setStart] = React.useState(0);
    const [list, setList] = React.useState(sourceData.slice());
    useConfig$1();
    const scrollRef = React.useRef(null);
    const itemsRef = React.useRef(null);
    const firstItemRef = React.useRef(null);
    const [positions, setPositions] = React.useState([
      {
        index: 0,
        left: 0,
        top: 0,
        bottom: 0,
        width: 0,
        height: 0,
        right: 0
      }
    ]);
    const [offSetSize, setOffSetSize] = React.useState(containerSize || 0);
    const [options, setOptions] = React.useState({
      startOffset: 0,
      // 可视区域距离顶部的偏移量
      startIndex: 0,
      // 可视区域开始索引
      overStart: 0,
      endIndex: 10
      // 可视区域结束索引
    });
    React.useEffect(() => {
      if (sourceData.length) {
        setList(sourceData.slice());
      }
    }, [sourceData]);
    React.useEffect(() => {
      setPositions((options2) => {
        return { ...options2, endIndex: visibleCount() };
      });
    }, [itemSize, overscan, offSetSize]);
    React.useEffect(() => {
      if (containerSize)
        return;
      setOffSetSize(getContainerHeight());
    }, [containerSize]);
    React.useEffect(() => {
      const pos = initPositinoCache(itemSize, sourceData.length);
      setPositions(pos);
    }, [itemSize, sourceData]);
    const getContainerHeight = () => {
      const initH = itemSize * sourceData.length;
      return initH < clientHeight ? initH + overscan * itemSize - 5 : Math.min(containerSize, clientHeight);
    };
    const visibleCount = () => {
      return Math.ceil(getContainerHeight() / itemSize) + overscan;
    };
    const end = () => {
      return start2 + visibleCount();
    };
    const listHeight = () => {
      return list.length * itemSize;
    };
    const visibleData = () => {
      return list.slice(start2, Math.min(end(), list.length));
    };
    const updateTotalSize = React.useCallback(() => {
      if (!itemsRef.current)
        return;
      const items = itemsRef.current.children;
      if (!items.length)
        return;
      updateItemSize(positions, items, "height");
    }, [positions]);
    const listScroll = (e) => {
      const scrollTop = e.detail ? e.detail.scrollTop : e.target.scrollTop;
      const scrollSize = Math.floor(scrollTop);
      const startIndex = binarySearch(positions, scrollSize, false);
      const overStart = startIndex - overscan > -1 ? startIndex - overscan : 0;
      const endIndex = end();
      if (!itemEqualSize) {
        updateTotalSize();
      }
      setStart(Math.floor(scrollTop / itemSize));
      setOptions({ startOffset, startIndex, overStart, endIndex });
      if (end() > list.length - 1) {
        onScroll && onScroll();
      }
      setStartOffset(scrollTop - scrollTop % itemSize);
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: className ? `${className} nut-virtualList-box` : "nut-virtualList-box",
        ...rest,
        style: {
          height: containerSize ? `${offSetSize}px` : ""
        }
      },
      /* @__PURE__ */ React.createElement(
        components.ScrollView,
        {
          scrollY: true,
          ref: scrollRef,
          className: "nut-virtuallist",
          style: {
            height: `${getContainerHeight()}px`
          },
          onScroll: listScroll
        },
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-virtuallist-phantom",
            style: { height: `${listHeight()}px` }
          }
        ),
        /* @__PURE__ */ React.createElement(
          "div",
          {
            className: "nut-virtuallist-container",
            ref: itemsRef,
            style: { transform: `translate3d(0, ${startOffset}px, 0)` }
          },
          visibleData().map((data, index) => {
            const { overStart } = options;
            const dataIndex = overStart + index;
            key && data[key] ? data[key] : dataIndex;
            return /* @__PURE__ */ React.createElement(
              "div",
              {
                ref: dataIndex === 0 ? firstItemRef : null,
                "data-index": `${dataIndex}`,
                className: "nut-virtuallist-item",
                key: `${data}`,
                style: {
                  height: `${itemEqualSize ? `${itemSize}px` : "auto"}`
                }
              },
              ItemRender ? /* @__PURE__ */ React.createElement(ItemRender, { data, index: `${index}` }) : data
            );
          })
        )
      )
    );
  };
  VirtualList.defaultProps = defaultProps$a;
  VirtualList.displayName = "NutVirtualList";
  const defaultProps$9 = {
    content: "",
    fullPage: true,
    zIndex: 2e3,
    gapX: 24,
    gapY: 48,
    width: 120,
    height: 64,
    image: "",
    imageWidth: 120,
    imageHeight: 64,
    rotate: -22,
    fontColor: "rgba(0,0,0,.15)",
    fontStyle: "normal",
    fontFamily: "PingFang SC",
    fontWeight: "normal",
    fontSize: 14
  };
  const WaterMark = (props) => {
    const { locale } = useConfig();
    const {
      content,
      fullPage,
      zIndex,
      className,
      gapX,
      gapY,
      width,
      height,
      image,
      imageWidth,
      imageHeight,
      rotate,
      fontColor,
      fontStyle,
      fontFamily,
      fontWeight,
      fontSize,
      style,
      children
    } = {
      ...defaultProps$9,
      ...props
    };
    const [base64Url, setBase64Url] = React.useState("");
    const b2 = cn("watermark");
    const classes = classNames({
      [`${b2("")}`]: true,
      [`${b2("")}-full-page`]: fullPage
    });
    const cls = classNames(classes, className);
    React.useEffect(() => {
      init();
    }, []);
    const init = () => {
      let ratio = 1;
      Taro.getSystemInfo().then((res) => {
        ratio = res.pixelRatio;
        const canvasWidth = `${(gapX + width) * ratio}`;
        const canvasHeight = `${(gapY + height) * ratio}`;
        const markWidth = width * ratio;
        const markHeight = height * ratio;
        let ctx2;
        let canvas;
        if (process.env.TARO_ENV === "h5") {
          canvas = document.createElement("canvas");
          ctx2 = canvas.getContext("2d");
          canvas.setAttribute("width", `${canvasWidth}px`);
          canvas.setAttribute("height", `${canvasHeight}px`);
        } else {
          canvas = Taro.createOffscreenCanvas({
            type: "2d",
            width: Number(canvasWidth),
            height: Number(canvasHeight)
          });
          ctx2 = canvas.getContext("2d");
        }
        if (ctx2) {
          if (image) {
            ctx2.translate(markWidth / 2, markHeight / 2);
            ctx2.rotate(Math.PI / 180 * Number(rotate));
            let img;
            if (process.env.TARO_ENV === "h5") {
              img = new Image();
            } else {
              img = canvas.createImage();
            }
            img.crossOrigin = "anonymous";
            img.referrerPolicy = "no-referrer";
            img.src = image;
            img.onload = () => {
              ctx2.drawImage(
                img,
                -imageWidth * ratio / 2,
                -imageHeight * ratio / 2,
                imageWidth * ratio,
                imageHeight * ratio
              );
              ctx2.restore();
              setBase64Url(canvas.toDataURL());
            };
          } else if (content) {
            ctx2.textBaseline = "middle";
            ctx2.textAlign = "center";
            ctx2.translate(markWidth / 2, markHeight / 2);
            ctx2.rotate(Math.PI / 180 * Number(rotate));
            const markSize = Number(fontSize) * ratio;
            ctx2.font = `${fontStyle} normal ${fontWeight} ${markSize}px/${markHeight}px ${fontFamily}`;
            ctx2.fillStyle = fontColor;
            ctx2.fillText(content, 0, 0);
            ctx2.restore();
            setBase64Url(canvas.toDataURL());
          }
        } else {
          throw new Error(locale.watermark.errorCanvasTips);
        }
      });
    };
    return /* @__PURE__ */ React.createElement(
      "div",
      {
        className: cls,
        style: {
          zIndex,
          backgroundSize: `${gapX + width}px`,
          backgroundImage: `url('${base64Url}')`,
          ...style
        }
      }
    );
  };
  WaterMark.defaultProps = defaultProps$9;
  WaterMark.displayName = "NutWaterMark";
  const defaultProps$8 = {
    type: "custom",
    existAddress: [],
    defaultIcon: "location2",
    selectedIcon: "Check",
    isShowCustomAddress: true,
    customAndExistTitle: ""
  };
  const ExistRender = (props) => {
    const { locale } = useConfig();
    const {
      children,
      type,
      existAddress,
      selectedIcon,
      defaultIcon,
      isShowCustomAddress,
      customAndExistTitle,
      onSelected,
      onClose,
      onSwitchModule,
      ...rest
    } = { ...defaultProps$8, ...props };
    const b2 = cn("address");
    const selectedExist = (item) => {
      const copyExistAdd = existAddress;
      let prevExistAdd = {
        provinceName: "",
        cityName: "",
        countyName: "",
        townName: "",
        addressDetail: "",
        selectedAddress: false
      };
      copyExistAdd.forEach((list, index) => {
        if (list && list.selectedAddress) {
          prevExistAdd = list;
        }
        list.selectedAddress = false;
      });
      item.selectedAddress = true;
      onSelected && onSelected(prevExistAdd, item, copyExistAdd);
    };
    const switchModule = () => {
      onSwitchModule && onSwitchModule({ type: type === "exist" ? "custom" : "exist" });
    };
    React.useEffect(() => {
    }, [existAddress]);
    return /* @__PURE__ */ React.createElement("div", { className: b2("exist") }, /* @__PURE__ */ React.createElement("div", { className: b2("exist-group") }, /* @__PURE__ */ React.createElement("ul", { className: b2("exist-ul") }, existAddress.map((item, index) => {
      return /* @__PURE__ */ React.createElement("li", { className: b2("exist-item"), key: index }, /* @__PURE__ */ React.createElement("div", { onClick: () => selectedExist(item) }, /* @__PURE__ */ React.createElement(
        Icon,
        {
          className: b2("exist-item-icon"),
          name: item.selectedAddress ? selectedIcon : defaultIcon,
          color: item.selectedAddress ? "#FA2C19" : "",
          size: "13px"
        }
      ), /* @__PURE__ */ React.createElement("div", { className: b2("exist-item-info") }, item.name && item.phone && /* @__PURE__ */ React.createElement("div", { className: "exist-item-info-top" }, /* @__PURE__ */ React.createElement("div", { className: "exist-item-info-name" }, item.name), /* @__PURE__ */ React.createElement("div", { className: "exist-item-info-phone" }, item.phone)), /* @__PURE__ */ React.createElement("div", { className: "exist-item-info-bottom" }, /* @__PURE__ */ React.createElement("div", null, item.provinceName + item.cityName + item.countyName + item.townName + item.addressDetail)))));
    }))), isShowCustomAddress && /* @__PURE__ */ React.createElement("div", { className: b2("choose-other"), onClick: switchModule }, /* @__PURE__ */ React.createElement("div", { className: b2("choose-other-btn") }, customAndExistTitle || locale.address.chooseAnotherAddress)));
  };
  const defaultProps$7 = {
    modelValue: [],
    type: "custom",
    province: [],
    city: [],
    country: [],
    town: [],
    height: "200px"
  };
  const CustomRender = (props) => {
    const { locale } = useConfig();
    const {
      children,
      type,
      modelValue,
      height,
      province,
      city,
      country,
      town,
      onNextArea,
      onTabClick,
      onClose,
      ...rest
    } = {
      ...defaultProps$7,
      ...props
    };
    const b2 = cn("address");
    const [privateType] = React.useState(type);
    const [tabIndex, setTabIndex] = React.useState(0);
    const [tabName] = React.useState(["province", "city", "country", "town"]);
    React.useRef(null);
    React.useRef(null);
    React.useRef(null);
    React.useRef(null);
    const regionLine = React.useRef(null);
    const isCustom2 = () => {
      return type === "custom2";
    };
    const transformData = (data) => {
      if (!Array.isArray(data))
        throw new TypeError("params muse be array.");
      if (!data.length)
        return [];
      data.forEach((item) => {
        if (!item.title) {
          console.error(
            "[NutUI] <Address> 请检查数组选项的 title 值是否有设置 ,title 为必填项 ."
          );
        }
      });
      const newData = [];
      data = data.sort((a, b22) => {
        return a.title.localeCompare(b22.title);
      });
      data.forEach((item) => {
        const index = newData.findIndex(
          (value) => value.title === item.title
        );
        if (index <= -1) {
          newData.push({
            title: item.title,
            list: [].concat(item)
          });
        } else {
          newData[index] = {
            title: item.title,
            list: newData[index].list.concat(item)
          };
        }
      });
      return newData;
    };
    const [regionList, setRegionList] = React.useState({
      province: isCustom2() ? transformData(province) : province,
      city: isCustom2() ? transformData(city) : city,
      country: isCustom2() ? transformData(country) : country,
      town: isCustom2() ? transformData(town) : town
    });
    const [selectedRegion, setSelectedRegion] = React.useState({
      province: { name: "" },
      city: { name: "" },
      country: { name: "" },
      town: { name: "" }
    });
    const [lineDistance, setLineDistance] = React.useState(20);
    const getTabName = (item, index) => {
      if (tabIndex > index) {
        return item.name;
      }
      return locale.select;
    };
    const lineAnimation = (index) => {
      setTimeout(() => {
        const name = tabName[index];
        Taro.createSelectorQuery().selectAll(`.${name}`).boundingClientRect((rects) => {
          rects && rects.length > 0 && rects.forEach((rect) => {
            if (rect.width > 0)
              setLineDistance(rect.left || 20);
          });
        }).exec();
      }, 100);
    };
    const nextAreaList = (item) => {
      const calBack = {
        next: "",
        value: "",
        custom: tabName[tabIndex]
      };
      const bbselectedRegion = selectedRegion ? { ...selectedRegion } : null;
      if (bbselectedRegion) {
        setSelectedRegion({
          ...bbselectedRegion,
          [tabName[tabIndex]]: item
        });
        calBack.selectedRegion = {
          ...bbselectedRegion,
          [tabName[tabIndex]]: item
        };
        for (let i = tabIndex; i < tabIndex - 1; i++) {
          setSelectedRegion({
            ...bbselectedRegion,
            [tabName[i + 1]]: null
          });
          calBack.selectedRegion = {
            ...bbselectedRegion,
            [tabName[i + 1]]: {}
          };
        }
      }
      if (tabIndex < 4) {
        if (tabIndex === 3) {
          calBack.next = "";
        } else {
          setTabIndex(() => tabIndex + 1);
          lineAnimation(tabIndex + 1);
          calBack.next = tabName[tabIndex + 1];
        }
        calBack.value = item;
        onNextArea && onNextArea(calBack);
      } else {
        onClose && onClose();
      }
    };
    const changeRegionTab = (item, index, key) => {
      if (getTabName(item, index)) {
        setTabIndex(index);
        lineAnimation(index);
      }
      onTabClick && onTabClick(key);
    };
    const initCustomSelected = () => {
      if (modelValue.length > 0) {
        let tagIndex = 0;
        const selectedRegionC = selectedRegion && Object.assign(selectedRegion);
        for (let index = 0; index < modelValue.length; index++) {
          if (regionList[tabName[index]].length === 0) {
            tagIndex = index - 1;
            setTabIndex(index - 1);
            break;
          } else {
            const val = modelValue[index];
            const arr = regionList[tabName[index]];
            if (privateType === "custom") {
              selectedRegionC[[tabName[index]]] = arr.filter(
                (item) => item.id === val
              )[0];
            } else if (privateType === "custom2") {
              const sumArr = [];
              arr.forEach((item) => {
                sumArr.push(...item.list);
              });
              selectedRegionC[[tabName[index]]] = sumArr.filter(
                (item) => item.id === val
              )[0];
            }
            tagIndex = index;
            setSelectedRegion(selectedRegionC);
          }
        }
        setTabIndex(tagIndex);
        lineAnimation(tagIndex);
      }
    };
    const handleElevatorItem = (key, item) => {
      nextAreaList(item);
    };
    React.useEffect(() => {
      const { province: province2 } = { ...defaultProps$7, ...props };
      setRegionList({
        ...regionList,
        province: isCustom2() ? transformData(province2) : province2
      });
    }, [province]);
    React.useEffect(() => {
      const { city: city2 } = { ...defaultProps$7, ...props };
      setRegionList({
        ...regionList,
        city: isCustom2() ? transformData(city2) : city2
      });
    }, [city]);
    React.useEffect(() => {
      const { country: country2 } = { ...defaultProps$7, ...props };
      setRegionList({
        ...regionList,
        country: isCustom2() ? transformData(country2) : country2
      });
    }, [country]);
    React.useEffect(() => {
      const { town: town2 } = { ...defaultProps$7, ...props };
      setRegionList({
        ...regionList,
        town: isCustom2() ? transformData(town2) : town2
      });
    }, [town]);
    React.useEffect(() => {
      initCustomSelected();
    }, [modelValue]);
    return /* @__PURE__ */ React.createElement("div", { className: b2("custom") }, /* @__PURE__ */ React.createElement("div", { className: b2("region-tab") }, selectedRegion && Object.keys(selectedRegion).map(
      (key, index) => {
        return /* @__PURE__ */ React.createElement(
          "div",
          {
            className: `${b2("tab-item")} ${index === tabIndex ? "active" : ""} ${tabName[index]}`,
            key: index,
            onClick: () => changeRegionTab(
              selectedRegion[key],
              index,
              key
            )
          },
          index <= tabIndex && /* @__PURE__ */ React.createElement("div", null, getTabName(
            selectedRegion[key],
            index
          ))
        );
      }
    ), /* @__PURE__ */ React.createElement(
      "div",
      {
        className: b2("tab-line"),
        ref: regionLine,
        style: { left: `${lineDistance}px` }
      }
    )), privateType === "custom" && /* @__PURE__ */ React.createElement("div", { className: b2("region-con") }, /* @__PURE__ */ React.createElement("ul", { className: b2("region-group") }, regionList[tabName[tabIndex]].map(
      (item, index) => {
        return /* @__PURE__ */ React.createElement("li", { key: index, className: b2("region-item") }, /* @__PURE__ */ React.createElement(
          "div",
          {
            onClick: () => {
              nextAreaList(item);
            }
          },
          selectedRegion && selectedRegion[tabName[tabIndex]].id === item.id && /* @__PURE__ */ React.createElement(
            Icon,
            {
              className: b2("region-item--icon"),
              name: "Check",
              color: "#FA2C19",
              size: "13px"
            }
          ),
          item.name
        ));
      }
    ))), privateType === "custom2" && /* @__PURE__ */ React.createElement("div", { className: b2("elevator-group") }, /* @__PURE__ */ React.createElement(
      Elevator,
      {
        height,
        indexList: regionList[tabName[tabIndex]],
        onClickItem: handleElevatorItem
      }
    )));
  };
  const defaultProps$6 = {
    ...ComponentDefaults,
    modelValue: false,
    modelSelect: [],
    type: "custom",
    customAddressTitle: "",
    province: [],
    city: [],
    country: [],
    town: [],
    isShowCustomAddress: true,
    existAddress: [],
    existAddressTitle: "",
    customAndExistTitle: "",
    height: "200px",
    defaultIcon: "location2",
    selectedIcon: "Check",
    closeBtnIcon: "circle-close",
    backBtnIcon: "left"
  };
  const Address = (props) => {
    const { locale } = useConfig$1();
    const {
      modelValue,
      modelSelect,
      children,
      type,
      height,
      customAddressTitle,
      existAddress,
      existAddressTitle,
      province,
      city,
      country,
      town,
      isShowCustomAddress,
      customAndExistTitle,
      selectedIcon,
      defaultIcon,
      closeBtnIcon,
      backBtnIcon,
      onChange,
      onSelected,
      onClose,
      closeMask,
      switchModule,
      onTabChecked,
      style,
      className,
      iconClassPrefix,
      iconFontClassName,
      ...rest
    } = {
      ...defaultProps$6,
      ...props
    };
    const b2 = cn("address");
    const [privateType, setPrivateType] = React.useState(type);
    const [tabName] = React.useState(["province", "city", "country", "town"]);
    const [showPopup, setShowPopup] = React.useState(modelValue);
    const [selectedRegion, setSelectedRegion] = React.useState({
      province: { name: "" },
      city: { name: "" },
      country: { name: "" },
      town: { name: "" }
    });
    const [selectedExistAddress, setSelectedExistAddress] = React.useState({});
    const handClose = () => {
      setShowPopup(false);
    };
    const clickOverlay = () => {
      closeMask && closeMask({ closeWay: "mask" });
    };
    const nextAreaList = (item) => {
      const callbackParams = {
        next: item.next,
        value: item.value,
        custom: item.custom
      };
      setSelectedRegion({
        ...item.selectedRegion
      });
      onChange && onChange(callbackParams);
    };
    const selectedExist = (prevExistAdd, item, copyExistAdd) => {
      setSelectedExistAddress(item);
      onSelected && onSelected(prevExistAdd, item, copyExistAdd);
      handClose();
    };
    const initAddress = () => {
      for (let i = 0; i < tabName.length; i++) {
        setSelectedRegion({
          ...selectedRegion,
          [tabName[i]]: {}
        });
      }
    };
    const closeFun = () => {
      const resCopy = {
        addressIdStr: "",
        addressStr: "",
        ...selectedRegion
      };
      const res = {
        data: {
          addressIdStr: "",
          addressStr: "",
          ...selectedRegion
        },
        type: privateType
      };
      if (privateType === "custom" || privateType === "custom2") {
        const { province: province2, city: city2, country: country2, town: town2 } = resCopy;
        resCopy.addressIdStr = [
          province2.id || 0,
          city2.id || 0,
          country2.id || 0,
          town2.id || 0
        ].join("_");
        resCopy.addressStr = [
          province2.name,
          city2.name,
          country2.name,
          town2.name
        ].join("");
        res.data = resCopy;
      } else {
        res.data = selectedExistAddress;
      }
      initAddress();
      onClose && onClose(res);
    };
    const onSwitchModule = () => {
      if (privateType === "exist") {
        setPrivateType("custom");
      } else {
        setPrivateType("exist");
      }
      initAddress();
      switchModule && switchModule({ type: privateType });
    };
    const headerRender = () => {
      return /* @__PURE__ */ React.createElement("div", { className: b2("header") }, /* @__PURE__ */ React.createElement("div", { className: "arrow-back", onClick: onSwitchModule }, privateType === "custom" && backBtnIcon && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: backBtnIcon,
          color: "#cccccc"
        }
      )), /* @__PURE__ */ React.createElement("div", { className: b2("header__title") }, privateType === "custom" ? customAddressTitle || locale.address.selectRegion : existAddressTitle || locale.address.deliveryTo), /* @__PURE__ */ React.createElement("div", { onClick: () => handClose() }, closeBtnIcon && /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          classPrefix: iconClassPrefix,
          fontClassName: iconFontClassName,
          name: closeBtnIcon,
          color: "#cccccc",
          size: "18px"
        }
      )));
    };
    React.useEffect(() => {
      setShowPopup(modelValue);
    }, [modelValue]);
    React.useEffect(() => {
      if (!showPopup) {
        closeFun();
      }
    }, [showPopup]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, showPopup && /* @__PURE__ */ React.createElement(
      Popup,
      {
        visible: showPopup,
        position: "bottom",
        onClickOverlay: clickOverlay,
        onClose: () => {
          closeFun();
        }
      },
      /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `${b2()} ${className || ""}`,
          style: { ...style },
          ...rest
        },
        headerRender(),
        (privateType === "custom" || privateType === "custom2") && /* @__PURE__ */ React.createElement(
          CustomRender,
          {
            modelValue: modelSelect,
            type: privateType,
            province,
            city,
            country,
            town,
            height,
            onNextArea: (cal) => {
              nextAreaList && nextAreaList(cal);
            },
            onTabClick: (type2) => {
              onTabChecked && onTabChecked(type2);
            },
            onClose: handClose
          }
        ),
        privateType === "exist" && /* @__PURE__ */ React.createElement(
          ExistRender,
          {
            type: privateType,
            existAddress,
            selectedIcon,
            defaultIcon,
            isShowCustomAddress,
            customAndExistTitle: customAndExistTitle || locale.address.chooseAnotherAddress,
            onSelected: selectedExist,
            onSwitchModule
          }
        )
      )
    ));
  };
  Address.defaultProps = defaultProps$6;
  Address.displayName = "NutAddress";
  const defaultProps$5 = {
    barrageList: [],
    frequency: 500,
    loop: true,
    speeds: 3e3,
    rows: 3,
    top: 10
  };
  const InternalBarrage = (props, ref) => {
    const {
      className,
      frequency,
      loop: loop2,
      barrageList,
      speeds,
      rows,
      top,
      ...restProps
    } = {
      ...defaultProps$5,
      ...props
    };
    const [styleList, setStyleList] = React.useState([]);
    const [baItemList, setBaItemList] = React.useState(barrageList);
    const barrageListSet = React.useRef(barrageList);
    const barrageBody = React.useRef(null);
    const barrageContainer = React.useRef(null);
    const timeId = React.useRef((/* @__PURE__ */ new Date()).getTime());
    const timer = React.useRef(0);
    React.useRef(0);
    const b2 = cn("barrage");
    const classes = classNames(className, b2(""), {
      [`nut-barrage__body${timeId.current}`]: true
    });
    React.useImperativeHandle(ref, () => ({
      add: (word) => {
        barrageListSet.current = [...barrageListSet.current, word];
        run();
      }
    }));
    React.useEffect(() => {
      barrageListSet.current = [...barrageList];
      run();
      return () => {
        clearInterval(timer.current);
      };
    }, [barrageList]);
    const run = () => {
      setBaItemList(barrageListSet.current);
      barrageListSet.current.forEach((item, index2) => {
        getNode(index2);
      });
    };
    const getNode = (index2) => {
      const query = Taro.createSelectorQuery();
      setTimeout(() => {
        let width = 100;
        query.select(".nut-barrage__body" + timeId.current).boundingClientRect((rec) => {
          width = (Array.isArray(rec) ? rec[0].width : rec.width) || 300;
        });
        query.select(".nut-barrage__item" + index2).boundingClientRect((recs) => {
          let height = Array.isArray(recs) ? recs[0].width : recs.width;
          let nodeTop = index2 % rows * (height + top) + 20 + "px";
          styleInfo(index2, nodeTop, width);
        }).exec();
      }, 500);
    };
    const styleInfo = (index2, nodeTop, width) => {
      let timeIndex = index2 - rows > 0 ? index2 - rows : 0;
      let list = styleList;
      let time = list[timeIndex] ? Number(list[timeIndex]["--time"]) : 0;
      let obj = {
        top: nodeTop,
        "--time": `${frequency * index2 + time}`,
        animationDuration: `${speeds}ms`,
        animationIterationCount: `${loop2 ? "infinite" : 1}`,
        animationDelay: `${frequency * index2 + time}ms`,
        "--move-distance": `-${width}px`
      };
      list.push(obj);
      setStyleList([...list]);
    };
    return /* @__PURE__ */ React.createElement("div", { className: classes, ref: barrageBody, ...restProps }, /* @__PURE__ */ React.createElement("div", { ref: barrageContainer, className: "bContainer" }, baItemList.map((item, index2) => {
      return /* @__PURE__ */ React.createElement(
        "div",
        {
          className: `barrage-item nut-barrage__item${index2} move`,
          style: styleList[index2]
        },
        item.length > 8 ? item.substr(0, 8) + "..." : item
      );
    })));
  };
  const Barrage = React.forwardRef(InternalBarrage);
  Barrage.defaultProps = defaultProps$5;
  Barrage.displayName = "NutBarrage";
  const defaultProps$4 = {};
  const Card = (props) => {
    const {
      className,
      style,
      imgUrl,
      title,
      price,
      vipPrice,
      shopDesc,
      delivery,
      shopName,
      shopTagTpl,
      originTpl,
      prolistTpl,
      footerTpl,
      ...rest
    } = {
      ...defaultProps$4,
      ...props
    };
    const b2 = cn("card");
    return /* @__PURE__ */ React.createElement("div", { className: classNames(b2(), className), style, ...rest }, /* @__PURE__ */ React.createElement("div", { className: b2("left") }, /* @__PURE__ */ React.createElement("img", { src: imgUrl, alt: "" })), /* @__PURE__ */ React.createElement("div", { className: b2("right") }, /* @__PURE__ */ React.createElement("div", { className: b2("right__title") }, title), prolistTpl, /* @__PURE__ */ React.createElement("div", { className: b2("right__price") }, /* @__PURE__ */ React.createElement(Price, { price }), originTpl || /* @__PURE__ */ React.createElement(Price, { className: b2("right__price__origin"), price: vipPrice })), /* @__PURE__ */ React.createElement("div", { className: b2("right__other") }, shopTagTpl || /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Tag, { type: "danger" }, shopDesc), /* @__PURE__ */ React.createElement(Tag, { plain: true }, delivery))), /* @__PURE__ */ React.createElement("div", { className: b2("right__shop") }, /* @__PURE__ */ React.createElement("div", { className: b2("right__shop__name") }, shopName), footerTpl)));
  };
  Card.defaultProps = defaultProps$4;
  Card.displayName = "NutCard";
  const defaultProps$3 = {
    canvasId: "spcanvas",
    type: "png",
    lineWidth: 2,
    strokeStyle: "#000",
    className: ""
  };
  const Signature = (props) => {
    const { locale } = useConfig$1();
    const {
      canvasId,
      type,
      lineWidth,
      strokeStyle,
      unSupportTpl,
      className,
      confirm,
      clear,
      onConfirm,
      onClear,
      ...rest
    } = {
      ...defaultProps$3,
      ...props
    };
    const b2 = cn("signature");
    const canvasRef = React.useRef(null);
    const wrapRef = React.useRef(null);
    const [canvasHeight, setCanvasHeight] = React.useState(0);
    const [canvasWidth, setCanvasWidth] = React.useState(0);
    const ctx2 = React.useRef(null);
    const [disalbeScroll] = React.useState("true");
    const startEventHandler = (event) => {
      if (ctx2.current) {
        ctx2.current.beginPath();
        ctx2.current.lineWidth = lineWidth;
        ctx2.current.strokeStyle = strokeStyle;
      }
    };
    const moveEventHandler = (event) => {
      if (ctx2.current) {
        const evt = event.changedTouches[0];
        let mouseX = evt.x || evt.clientX;
        let mouseY = evt.y || evt.clientY;
        if (Taro.getEnv() === "WEB" && canvasRef.current) {
          const coverPos = canvasRef.current.getBoundingClientRect();
          mouseX = evt.clientX - coverPos.left;
          mouseY = evt.clientY - coverPos.top;
        }
        Taro.nextTick(() => {
          var _a, _b;
          (_a = ctx2.current) == null ? void 0 : _a.lineTo(mouseX, mouseY);
          (_b = ctx2.current) == null ? void 0 : _b.stroke();
        });
      }
    };
    const endEventHandler = (event) => {
    };
    const handleClearBtn = () => {
      if (ctx2.current) {
        ctx2.current.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx2.current.closePath();
      }
      clear && clear();
      onClear && onClear();
    };
    const handleConfirmBtn = () => {
      onSave();
    };
    const onSave = () => {
      Taro.createSelectorQuery().select(`#${canvasId}`).fields({
        node: true,
        size: true
      }).exec((res) => {
        Taro.canvasToTempFilePath({
          canvas: res[0].node,
          fileType: props.type,
          canvasId: `${canvasId}`,
          success: (res2) => {
            handleClearBtn();
            confirm && confirm(res2.tempFilePath);
            onConfirm && onConfirm(res2.tempFilePath);
          },
          fail: (res2) => {
            console.log("保存失败");
          }
        });
      });
    };
    const canvasSetting = (canvasDom, width, height) => {
      const canvas = canvasDom;
      canvas.current = canvas;
      ctx2.current = canvas.getContext("2d");
      setCanvasWidth(width);
      setCanvasHeight(height);
      canvas.width = width;
      canvas.height = height;
      if (ctx2.current) {
        ctx2.current.clearRect(0, 0, width, height);
        ctx2.current.beginPath();
        ctx2.current.lineWidth = lineWidth;
        ctx2.current.strokeStyle = strokeStyle;
      }
    };
    const initCanvas = () => {
      Taro.nextTick(() => {
        setTimeout(() => {
          if (Taro.getEnv() === "WEAPP" || Taro.getEnv() === "JD") {
            Taro.createSelectorQuery().select(`#${canvasId}`).fields(
              {
                node: true,
                size: true
              },
              (res) => {
                const { node, width, height } = res;
                canvasSetting(node, width, height);
              }
            ).exec();
          } else {
            const canvasDom = document.getElementById(
              `${canvasId}`
            );
            let canvas = canvasDom;
            if ((canvasDom == null ? void 0 : canvasDom.tagName) !== "CANVAS") {
              canvas = canvasDom == null ? void 0 : canvasDom.getElementsByTagName(
                "canvas"
              )[0];
            }
            canvasSetting(
              canvas,
              canvasDom == null ? void 0 : canvasDom.offsetWidth,
              canvasDom == null ? void 0 : canvasDom.offsetHeight
            );
          }
        }, 1e3);
      });
    };
    React.useEffect(() => {
      initCanvas();
    }, []);
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className}`, ...rest }, /* @__PURE__ */ React.createElement("div", { className: `${b2("inner")} spcanvas_WEAPP`, ref: wrapRef }, Taro.getEnv() === "WEAPP" || Taro.getEnv() === "JD" ? /* @__PURE__ */ React.createElement(
      "canvas",
      {
        id: canvasId,
        ref: canvasRef,
        canvasId,
        disalbeScroll: true,
        type: "2d",
        onTouchStart: startEventHandler,
        onTouchMove: moveEventHandler,
        onTouchEnd: endEventHandler
      }
    ) : /* @__PURE__ */ React.createElement(
      "canvas",
      {
        id: canvasId,
        ref: canvasRef,
        "canvas-id": canvasId,
        "disalbe-scroll": disalbeScroll,
        onTouchStart: startEventHandler,
        onTouchMove: moveEventHandler,
        onTouchEnd: endEventHandler,
        onTouchCancel: endEventHandler
      }
    )), /* @__PURE__ */ React.createElement(
      Button,
      {
        className: `${b2("btn")}`,
        type: "default",
        onClick: () => handleClearBtn()
      },
      locale.signature.reSign
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        className: `${b2("btn")}`,
        type: "primary",
        onClick: () => handleConfirmBtn()
      },
      locale.confirm
    ));
  };
  Signature.defaultProps = defaultProps$3;
  Signature.displayName = "NutSignature";
  const defaultProps$2 = {
    className: "",
    currentKey: 0,
    currentTime: [],
    times: [],
    select: () => null
  };
  const TimeDetail = (props) => {
    useConfig$1();
    const { children, times, className, currentKey, currentTime, select } = {
      ...defaultProps$2,
      ...props
    };
    const b2 = cn("timedetail");
    const [renderData, setRenderData] = React.useState([]);
    React.useEffect(() => {
      const currentData = times.find(
        (timesItem) => String(timesItem.key) === String(currentKey)
      );
      const renderData2 = currentData ? currentData.list : [];
      setRenderData(renderData2);
    }, [times, currentKey]);
    const handleTime = (time) => {
      select(time);
    };
    const getDetailClass = (item) => {
      let initClass = "nut-timedetail__item";
      const curTimeData = currentTime.find(
        (item2) => String(item2.key) === String(currentKey)
      );
      if (curTimeData && curTimeData.list && curTimeData.list.includes(item)) {
        initClass += " nut-timedetail__item-active";
      }
      return initClass;
    };
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className || ""}` }, renderData.map((item, index) => /* @__PURE__ */ React.createElement(
      "span",
      {
        className: getDetailClass(item),
        key: item,
        onClick: () => handleTime(item)
      },
      item
    )));
  };
  TimeDetail.defaultProps = defaultProps$2;
  TimeDetail.displayName = "NutTimeDetail";
  const defaultProps$1 = {
    className: "",
    date: "",
    curKey: 0
  };
  const TimePannel = (props) => {
    useConfig$1();
    const { children, className, date, curKey, change } = {
      ...defaultProps$1,
      ...props
    };
    const b2 = cn("timepannel");
    return /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className || ""}`, onClick: () => change(curKey) }, date);
  };
  TimePannel.defaultProps = defaultProps$1;
  TimePannel.displayName = "NutTimePannel";
  const defaultProps = {
    className: "",
    style: {},
    visible: false,
    height: "20%",
    multiple: false,
    currentKey: 0,
    currentTime: [],
    title: "取件时间",
    dates: [],
    times: []
  };
  const TimeSelect = (props) => {
    useConfig$1();
    const {
      visible,
      className,
      height,
      title,
      currentKey,
      currentTime,
      dates,
      times,
      multiple,
      select,
      pannelChange,
      timeChange,
      onSelect,
      onPannelChange,
      onTimeChange
    } = {
      ...defaultProps,
      ...props
    };
    const [activeKey, setActiveKey] = React.useState(currentKey);
    const [activeTime, setActiveTime] = React.useState(
      currentTime.length ? currentTime : [
        {
          key: currentKey,
          list: []
        }
      ]
    );
    const [popVisible, setPopVisible] = React.useState(visible);
    const popStyle = {
      width: "100%",
      height
    };
    const b2 = cn("timeselect");
    const closeFun = () => {
      if (onSelect) {
        onSelect(activeTime);
      } else if (select) {
        select(activeTime);
      }
    };
    const handleSelectTime = (time) => {
      let curTimeData = {};
      let curIndex = -1;
      for (let i = 0; i < activeTime.length; i++) {
        if (String(activeTime[i].key) === String(activeKey)) {
          curTimeData = activeTime[i];
          curIndex = i;
          break;
        }
      }
      const curTimeIndex = curTimeData.list.findIndex(
        (item) => String(item) === String(time)
      );
      if (curTimeIndex === -1) {
        curTimeData.list.push(time);
      } else {
        curTimeData.list.splice(curTimeIndex, 1);
      }
      const resultTimeData = [...activeTime];
      resultTimeData.splice(curIndex, 1, curTimeData);
      setActiveTime(resultTimeData);
      if (onTimeChange) {
        onTimeChange(time, resultTimeData);
      } else if (timeChange) {
        timeChange(time, resultTimeData);
      }
    };
    const handleChange = (pannelKey) => {
      const resultTimeData = [...activeTime];
      if (String(pannelKey) !== String(activeKey)) {
        setActiveKey == null ? void 0 : setActiveKey(pannelKey);
        if (multiple) {
          const curTimeDataIndex = activeTime.findIndex(
            (item) => String(item.key) === String(pannelKey)
          );
          if (curTimeDataIndex === -1) {
            resultTimeData.push({
              key: pannelKey,
              list: []
            });
            setActiveTime(resultTimeData);
          }
        } else {
          setActiveTime([
            {
              key: pannelKey,
              list: []
            }
          ]);
        }
      }
      if (onPannelChange) {
        onPannelChange(pannelKey, resultTimeData);
      } else if (pannelChange) {
        pannelChange(pannelKey, resultTimeData);
      }
    };
    const getTimePannelClass = (dataItem) => {
      if (String(dataItem["pannel-key"]) === String(activeKey)) {
        return "nut-timepannel-active";
      }
      return "";
    };
    React.useEffect(() => {
      setPopVisible(visible);
    }, [visible]);
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Popup,
      {
        closeable: true,
        round: true,
        visible: popVisible,
        position: "bottom",
        style: popStyle,
        onClose: () => {
          closeFun();
        }
      },
      /* @__PURE__ */ React.createElement("div", { className: `${b2()} ${className || ""}` }, /* @__PURE__ */ React.createElement("div", { className: "nut-timeselect__title" }, title), /* @__PURE__ */ React.createElement("div", { className: "nut-timeselect__content" }, /* @__PURE__ */ React.createElement("div", { className: "nut-timeselect__content-left" }, dates.map((dataItem, index) => /* @__PURE__ */ React.createElement(
        TimePannel,
        {
          date: dataItem.date,
          className: getTimePannelClass(dataItem),
          key: String(dataItem["pannel-key"] || index),
          curKey: String(dataItem["pannel-key"] || index),
          change: handleChange
        }
      ))), /* @__PURE__ */ React.createElement(
        TimeDetail,
        {
          times,
          currentKey: String(activeKey),
          currentTime: activeTime,
          select: handleSelectTime
        }
      )))
    ));
  };
  TimeSelect.defaultProps = defaultProps;
  TimeSelect.displayName = "NutTimeSelect";
  exports2.ActionSheet = ActionSheet;
  exports2.Address = Address;
  exports2.Animate = Animate;
  exports2.AnimatingNumbers = AnimatingNumbers;
  exports2.Audio = Audio;
  exports2.Avatar = Avatar;
  exports2.AvatarGroup = AvatarGroup;
  exports2.BackTop = BackTop;
  exports2.Badge = Badge;
  exports2.Barrage = Barrage;
  exports2.Button = Button;
  exports2.Calendar = Calendar;
  exports2.CalendarItem = CalendarItem;
  exports2.Card = Card;
  exports2.Cascader = Cascader;
  exports2.Cell = Cell;
  exports2.CellGroup = CellGroup;
  exports2.Checkbox = Checkbox;
  exports2.CheckboxGroup = CheckboxGroup;
  exports2.CircleProgress = CircleProgress;
  exports2.Col = Col;
  exports2.Collapse = Collapse;
  exports2.CollapseItem = CollapseItem;
  exports2.ConfigProvider = ConfigProvider;
  exports2.CountDown = CountDown;
  exports2.DatePicker = DatePicker;
  exports2.Dialog = BaseDialog;
  exports2.Divider = Divider;
  exports2.Drag = Drag;
  exports2.Elevator = Elevator;
  exports2.Ellipsis = Ellipsis;
  exports2.Empty = Empty;
  exports2.FixedNav = FixedNav;
  exports2.Form = Form;
  exports2.FormItem = FormItem;
  exports2.Grid = Grid;
  exports2.GridItem = GridItem;
  exports2.Icon = Icon$1;
  exports2.Image = Image$1;
  exports2.ImagePreview = ImagePreview;
  exports2.Indicator = Indicator;
  exports2.Infiniteloading = Infiniteloading;
  exports2.Input = Input;
  exports2.InputNumber = InputNumber;
  exports2.Layout = Layout;
  exports2.Menu = Menu;
  exports2.MenuItem = MenuItem;
  exports2.NavBar = NavBar;
  exports2.NoticeBar = NoticeBar;
  exports2.Notify = Notify;
  exports2.NumberKeyboard = NumberKeyboard;
  exports2.Overlay = Overlay;
  exports2.Pagination = Pagination;
  exports2.Picker = Picker$1;
  exports2.Popover = Popover;
  exports2.Popup = Popup;
  exports2.Price = Price;
  exports2.Progress = Progress;
  exports2.PullToRefresh = PullToRefresh;
  exports2.Radio = Radio;
  exports2.RadioGroup = RadioGroup;
  exports2.Range = Range;
  exports2.Rate = Rate;
  exports2.Row = Row;
  exports2.SearchBar = SearchBar;
  exports2.ShortPassword = ShortPassword;
  exports2.SideNavBar = SideNavBar;
  exports2.SideNavBarItem = SideNavBarItem;
  exports2.Signature = Signature;
  exports2.Skeleton = Skeleton;
  exports2.Step = Step;
  exports2.Steps = Steps;
  exports2.Sticky = Sticky;
  exports2.SubSideNavBar = SubSideNavBar;
  exports2.Swipe = Swipe;
  exports2.Swiper = Swiper;
  exports2.SwiperItem = SwiperItem;
  exports2.Switch = Switch;
  exports2.TabPane = TabPane;
  exports2.Tabbar = Tabbar;
  exports2.TabbarItem = TabbarItem;
  exports2.Table = Table;
  exports2.Tabs = Tabs;
  exports2.Tag = Tag;
  exports2.TextArea = TextArea;
  exports2.TimeDetail = TimeDetail;
  exports2.TimePannel = TimePannel;
  exports2.TimeSelect = TimeSelect;
  exports2.Toast = Toast;
  exports2.TrendArrow = TrendArrow;
  exports2.Uploader = Uploader;
  exports2.Video = Video;
  exports2.VirtualList = VirtualList;
  exports2.WaterMark = WaterMark;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
